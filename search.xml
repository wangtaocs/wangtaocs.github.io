<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>VSCode</title>
    <url>/2020/06/17/%E5%85%B6%E4%BB%96/VSCode/</url>
    <content><![CDATA[<!-- build time:Wed Jun 17 2020 15:45:34 GMT+0800 (GMT+08:00) --><p>由于经常使用VSCode刷C语言的题，这两天又在写30天自制操作系统，实在受不了VSCode默认的C代码风格，用了一个Prettier -Code formatter插件也不是很满意，在网上找到了使用Clang-format格式化，这是自带的。</p><p>Clang-format有多种风格，我最喜欢<strong>WebKit</strong>：</p><p><img src="https://s1.ax1x.com/2020/06/17/NABuiq.jpg" alt="NABuiq.jpg"></p><p>啊，舒服了~~</p><p>设置方式：</p><p>进入VSCode设置，搜索clang-format：</p><p><img src="https://s1.ax1x.com/2020/06/17/NABcTA.png" alt="NABcTA.png"></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>常用排序算法</title>
    <url>/2020/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<!-- build time:Mon Apr 06 2020 22:59:46 GMT+0800 (GMT+08:00) --><div class="table-container"><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">性能分析</th><th>特点</th><th>稳定性</th></tr></thead><tbody><tr><td style="text-align:left">直接插入</td><td style="text-align:left">时间：- 最好：O(n)，- 最差：O(n^2)；空间：O(1)</td><td>适合元素基本有序的场景</td><td>稳定</td></tr><tr><td style="text-align:left">折半插入</td><td style="text-align:left">时间：- 最好：O(nlogn)，- 最差：O(n^2)；空间：O(1)</td><td>适合元素较多的场景</td><td>稳定</td></tr><tr><td style="text-align:left">希尔排序</td><td style="text-align:left">时间：- 最好：O(n^1.5)，- 最差：O(n^2)；空间：O(1)</td><td></td><td>不稳定</td></tr><tr><td style="text-align:left">冒泡排序</td><td style="text-align:left">时间：- 最好：O(n)，- 最差：O(n^2)；空间：O(1)</td><td>适合元素基本有序的场景</td><td>稳定</td></tr><tr><td style="text-align:left">快速排序</td><td style="text-align:left">时间：- 最好：O(nlogn)， - 最差：O(n^2)；空间：O(logn)</td><td>序列越无序，效率越高；反之，效率越低</td><td>不稳定</td></tr><tr><td style="text-align:left">选择排序</td><td style="text-align:left">时间：O(n^2)；空间：O(1)</td><td></td><td>不稳定</td></tr><tr><td style="text-align:left">堆排序</td><td style="text-align:left">时间：O(nlogn)；空间：O(1)</td><td>适合元素较多的场景</td><td>不稳定</td></tr><tr><td style="text-align:left">归并排序</td><td style="text-align:left">时间：O(nlogn)；空间：O(n)</td><td></td><td>稳定</td></tr></tbody></table></div><h1 id="1-插入类排序"><a href="#1-插入类排序" class="headerlink" title="1.插入类排序"></a>1.插入类排序</h1><h2 id="1-1-直接插入排序"><a href="#1-1-直接插入排序" class="headerlink" title="1.1 直接插入排序"></a>1.1 直接插入排序</h2><p>算法思想：</p><ol><li>逐个扫描，从后向前依次进行比较，</li><li>插入合适位置</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inserSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> arrSize)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//插入排序</span></span><br><span class="line">    <span class="keyword">int</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; arrSize; ++i) <span class="comment">//默认第一个元素有序，从第二个元素开始</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp = arr[i]; <span class="comment">//将待插入的关键字存储在temp中</span></span><br><span class="line">        j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; arr[j]) <span class="comment">//从待插入的关键字向前扫描，将大于temp的元素向后移一位</span></span><br><span class="line">        &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = temp; <span class="comment">//将待插入的关键字插入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-折半插入排序"><a href="#1-2-折半插入排序" class="headerlink" title="1.2 折半插入排序"></a>1.2 折半插入排序</h2><p>算法思想：</p><ol><li>引入上下标，非遍历，</li><li>每次访问上下标中间的数，进行前后比较，插入</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binaryInsertSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> arrSize)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//折半插入排序</span></span><br><span class="line">    <span class="keyword">int</span> i, low, high, mid;</span><br><span class="line">    low = <span class="number">0</span>, high = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; arrSize; ++i) <span class="comment">//默认第一个元素有序，从第二个元素开始</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (low + high) / <span class="number">2</span>;     <span class="comment">//mid向下取整</span></span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &gt; arr[i])      <span class="comment">//arr[mid]大于待插入元素时，说明要向低半区插入</span></span><br><span class="line">                high = mid - <span class="number">1</span>;         <span class="comment">//更新high</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; arr[i]) <span class="comment">//arr[mid]小于待插入元素时，说明要向高半区插入</span></span><br><span class="line">                low = mid + <span class="number">1</span>;          <span class="comment">//更新low</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//low &gt; high时，跳出循环，开始插入元素</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[i]; <span class="comment">//将待插入的关键字存储在temp中</span></span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= mid &amp;&amp; temp &lt; arr[j])<span class="comment">//从待插入的关键字向前扫描，将大于temp的元素向后移一位</span></span><br><span class="line">        &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = temp; <span class="comment">//将待插入的关键字插入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-希尔排序"><a href="#1-3-希尔排序" class="headerlink" title="1.3 希尔排序"></a>1.3 希尔排序</h2><p>算法思路：</p><ol><li>以固定增量将待排序列分成n组</li><li>进行组内排序；</li><li>选取更小的增量重复进行，直到增量为1</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> arrSize)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//希尔排序</span></span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; arrSize / <span class="number">3</span>)</span><br><span class="line">        h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = h; i &lt; arrSize; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &gt;= h &amp;&amp; (arr[j] &lt; arr[j - h]); j -= h)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j - h];</span><br><span class="line">                arr[j - h] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-交换类排序"><a href="#2-交换类排序" class="headerlink" title="2.交换类排序"></a>2.交换类排序</h1><h2 id="2-1-冒泡排序"><a href="#2-1-冒泡排序" class="headerlink" title="2.1 冒泡排序"></a>2.1 冒泡排序</h2><p>算法思路：</p><ol><li>将待排序列中的两个相邻元素进行比较，</li><li>每次都将较大(小)元素置前，以完成降(升)序排序</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> arrSize)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//冒泡排序</span></span><br><span class="line">    <span class="keyword">int</span> i, j, temp, flag;</span><br><span class="line">    <span class="keyword">for</span> (i = arrSize - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="number">0</span>; <span class="comment">//标记本趟是否发生交换</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j - <span class="number">1</span>] &gt; arr[j])</span><br><span class="line">            &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">                arr[j - <span class="number">1</span>] = temp;</span><br><span class="line">                flag = <span class="number">1</span>; <span class="comment">//发生交换，flag = 1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) <span class="comment">//如果没有发生交换，说明序列有序</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-快速排序"><a href="#2-2-快速排序" class="headerlink" title="2.2 快速排序"></a>2.2 快速排序</h2><p>算法思想：</p><ol><li>引入头尾指针，以第一个元素为“轴”；</li><li>尾指针向前扫描，遇到比轴小的数时，放在头指针处；</li><li>变换扫描方向，头指针向后扫描，遇到比轴大的数时，放在尾指针处；</li><li>重复此过程，直到头尾指针相遇，即完成一次排序；</li><li>递归对轴的左右两部分分别进行此过程即可</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSortHelper</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//对arr[low]到arr[high]进行排序</span></span><br><span class="line">    <span class="keyword">int</span> temp;              <span class="comment">//temp用于存储“轴”的值</span></span><br><span class="line">    <span class="keyword">int</span> i = low, j = high; <span class="comment">//i为头指针，j为尾指针</span></span><br><span class="line">    <span class="keyword">if</span> (low &lt; high)        <span class="comment">//低位小于高位时，开始交换</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp = arr[low];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">        &#123;<span class="comment">//将数组中小于temp的元素放在temp左边，大于temp的元素放在temp右边</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; i &amp;&amp; arr[j] &gt;= temp) <span class="comment">//从右向左扫描，找到一个小于temp的元素</span></span><br><span class="line">                --j;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[i] = arr[j]; <span class="comment">//将元素放在temp左边</span></span><br><span class="line">                ++i;             <span class="comment">//头指针右移</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt; temp) <span class="comment">//从左向右扫描，找到一个大于temp的元素</span></span><br><span class="line">                ++i;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[j] = arr[i]; <span class="comment">//将元素放在temp右边</span></span><br><span class="line">                --j;             <span class="comment">//尾指针右移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = temp;                     <span class="comment">//将temp放在最终位置</span></span><br><span class="line">        quickSortHelper(arr, low, i - <span class="number">1</span>);  <span class="comment">//递归排序temp左边</span></span><br><span class="line">        quickSortHelper(arr, i + <span class="number">1</span>, high); <span class="comment">//递归排序temp右边</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> arrSize)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//快速排序</span></span><br><span class="line">    quickSortHelper(arr, <span class="number">0</span>, arrSize - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-选择类排序"><a href="#3-选择类排序" class="headerlink" title="3.选择类排序"></a>3.选择类排序</h1><h2 id="3-1-简单选择排序"><a href="#3-1-简单选择排序" class="headerlink" title="3.1 简单选择排序"></a>3.1 简单选择排序</h2><p>算法思想：</p><ol><li>找出无序序列中的最小关键字；</li><li>与第一个关键字进行位置交换；</li><li>循环此过程以遍历整个序列</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> arrSize)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//简单选择排序</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arrSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        k = i;</span><br><span class="line">        <span class="comment">//从无序序列中挑出最小的关键字</span></span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; arrSize; ++j)</span><br><span class="line">            <span class="keyword">if</span> (arr[k] &gt; arr[j])</span><br><span class="line">                k = j;</span><br><span class="line">        <span class="comment">//将最小关键字与无序序列的第一个关键字交换</span></span><br><span class="line">        temp = arr[i];</span><br><span class="line">        arr[i] = arr[k];</span><br><span class="line">        arr[k] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-堆排序"><a href="#3-2-堆排序" class="headerlink" title="3.2 堆排序"></a>3.2 堆排序</h2><p>算法思想：</p><ol><li>建堆；<ol><li>大根堆：升序排序</li><li>小根堆：降序排序</li></ol></li><li>删除根节点；</li><li>重建堆</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> i, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//建堆</span></span><br><span class="line">    <span class="comment">//标记左右孩子、最大节点的序号</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> largest = i;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[largest])</span><br><span class="line">        largest = left;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[largest])</span><br><span class="line">        largest = right;</span><br><span class="line">    <span class="keyword">if</span> (largest != i)</span><br><span class="line">    &#123; <span class="comment">//父节点不是最大节点时进行调整</span></span><br><span class="line">        swap(arr, i, largest);</span><br><span class="line">        heapify(arr, largest, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> arrSize)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//堆排序</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = arrSize / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) <span class="comment">//建堆</span></span><br><span class="line">        heapify(arr, i, arrSize);</span><br><span class="line">    <span class="keyword">for</span> (i = arrSize - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(arr, <span class="number">0</span>, i);    <span class="comment">//最后一个节点与根节点交换</span></span><br><span class="line">        heapify(arr, <span class="number">0</span>, i); <span class="comment">//剩余节点重新建堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4. 归并排序"></a>4. 归并排序</h1><p>算法思想：</p><ol><li>将待排序列看作一元组;</li><li>两两归并，排序为二元组;</li><li>以此类推，直至全部有序</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high, <span class="keyword">int</span> *help)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//使arr[low]到arr[mid]与arr[mid]到arr[high]有序</span></span><br><span class="line">    <span class="keyword">int</span> i = low, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid || j &lt;= high) <span class="comment">//循环直到所有元素排序完毕</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &lt;= high &amp;&amp; (arr[i] &gt;= arr[j] || i &gt; mid))</span><br><span class="line">        &#123; <span class="comment">//m[i] &gt;= m[j]或者前半段已完全排序,而后半段未完全排序的情况</span></span><br><span class="line">            help[i - low + j - mid - <span class="number">1</span>] = arr[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i &lt;= mid || j &gt; high)</span><br><span class="line">        &#123; <span class="comment">//m[i] &lt; m[j]或后半段已完全排序而前半段未完全排序的情况</span></span><br><span class="line">            help[i - low + j - mid - <span class="number">1</span>] = arr[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = low; i &lt;= high; i++) <span class="comment">//将排序好的值赋值给原数组</span></span><br><span class="line">        arr[i] = help[i - low];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSortHelper</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> *help)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//递归对左右部分进行归并排序，这里体现了二路归并排序</span></span><br><span class="line">        mergeSortHelper(arr, low, mid, help);</span><br><span class="line">        mergeSortHelper(arr, mid + <span class="number">1</span>, high, help);</span><br><span class="line">        <span class="comment">//使arr数组的前后两部分有序</span></span><br><span class="line">        merge(arr, low, mid, high, help);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> arrSize)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//归并排序</span></span><br><span class="line">    <span class="comment">//辅助数组，提供额外空间</span></span><br><span class="line">    <span class="keyword">int</span> help[arrSize];</span><br><span class="line">    mergeSortHelper(arr, <span class="number">0</span>, arrSize - <span class="number">1</span>, help);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>Java上溯造型与动态绑定</title>
    <url>/2020/04/01/Java/Java%E4%B8%8A%E6%BA%AF%E9%80%A0%E5%9E%8B%E4%B8%8E%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<!-- build time:Mon Apr 06 2020 22:59:46 GMT+0800 (GMT+08:00) --><h2 id="1-上溯造型"><a href="#1-上溯造型" class="headerlink" title="1.上溯造型"></a>1.上溯造型</h2><h3 id="1-1-什么是上溯造型"><a href="#1-1-什么是上溯造型" class="headerlink" title="1.1 什么是上溯造型"></a>1.1 什么是上溯造型</h3><p>以代码为例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Instrument</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"play()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Instrument i)</span></span>&#123;</span><br><span class="line">        i.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">extends</span> <span class="title">Instrument</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Wind flute = <span class="keyword">new</span> Wind();</span><br><span class="line">        <span class="comment">//一个Wind对象也是一个Instrument对象</span></span><br><span class="line">        <span class="comment">//从Wind类型的句柄flute转换为Instrument类型，这就是造型上溯</span></span><br><span class="line">        Instrument.tune(flute);         <span class="comment">//Upcasting</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>上溯造型：将子类句柄转化为父类类型</strong></p><p>此时类的衍生关系可表示为：</p><p><img src="https://i.loli.net/2020/04/03/fCQaNA95tvJGmhz.png" alt="image.png" style="zoom:67%"></p><h3 id="1-2-为什么要使用上溯造型"><a href="#1-2-为什么要使用上溯造型" class="headerlink" title="1.2 为什么要使用上溯造型"></a>1.2 为什么要使用上溯造型</h3><h4 id="1-2-1-不使用上溯造型"><a href="#1-2-1-不使用上溯造型" class="headerlink" title="1.2.1 不使用上溯造型"></a>1.2.1 不使用上溯造型</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Note2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Note2</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; value = val; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Note2</span><br><span class="line">            middleC = <span class="keyword">new</span> Note2(<span class="number">0</span>),</span><br><span class="line">            cSharp = <span class="keyword">new</span> Note2(<span class="number">1</span>),</span><br><span class="line">            cFlat = <span class="keyword">new</span> Note2(<span class="number">2</span>);</span><br><span class="line">&#125; <span class="comment">// Etc.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Instrument2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note2 n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Instrument2.play()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wind2</span> <span class="keyword">extends</span> <span class="title">Instrument2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note2 n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Wind2.play()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stringed2</span> <span class="keyword">extends</span> <span class="title">Instrument2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note2 n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Stringed2.play()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brass2</span> <span class="keyword">extends</span> <span class="title">Instrument2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note2 n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Brass2.play()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Wind2 i)</span> </span>&#123;</span><br><span class="line">        i.play(Note2.middleC);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Stringed2 i)</span> </span>&#123;</span><br><span class="line">        i.play(Note2.middleC);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Brass2 i)</span> </span>&#123;</span><br><span class="line">        i.play(Note2.middleC);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Wind2 flute = <span class="keyword">new</span> Wind2();</span><br><span class="line">        Stringed2 violin = <span class="keyword">new</span> Stringed2();</span><br><span class="line">        Brass2 frenchHorn = <span class="keyword">new</span> Brass2();</span><br><span class="line">        tune(flute); <span class="comment">// No upcasting</span></span><br><span class="line">        tune(violin);</span><br><span class="line">        tune(frenchHorn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过观察，我们可以发现：不使用上溯造型时，我们需要为不同的子类定制接口，并重载父类方法，但他们的功能却大致相同，这使得我们的工作量巨大</p><h4 id="1-2-2-使用上溯造型"><a href="#1-2-2-使用上溯造型" class="headerlink" title="1.2.2 使用上溯造型"></a>1.2.2 使用上溯造型</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Note</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Note</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;value = val;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Note middleC = <span class="keyword">new</span> Note(<span class="number">0</span>),</span><br><span class="line">                        cSharp = <span class="keyword">new</span> Note(<span class="number">1</span>), cFlat = <span class="keyword">new</span> Note(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Instrucment</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Instrucment.play()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">extends</span> <span class="title">Instrucment</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Wind.play()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Instrucment i)</span></span>&#123;</span><br><span class="line">        i.play(Note.middleC);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Wind flute = <span class="keyword">new</span> Wind();</span><br><span class="line">        tune(flute);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用上溯造型，可以不管子类，而直接和父类交互，从而避免了大量重复代码，简少工作量，提高了代码的重用。</p><h3 id="1-3怎么上溯造型"><a href="#1-3怎么上溯造型" class="headerlink" title="1.3怎么上溯造型"></a>1.3怎么上溯造型</h3><p>正如定义所诉，不再赘述。</p><p><em>这里不禁有个疑问，父类是如何知道我们传入的是哪种子类对象，从而有不同的响应呢？接下来就引入动态绑定的概念：</em></p><p>（这里只是根据书中的解释粗浅的理解，挖个坑，以后再来填~~）</p><h2 id="2-动态绑定"><a href="#2-动态绑定" class="headerlink" title="2.动态绑定"></a>2.动态绑定</h2><p>绑定：将方法调用与方法主体连接在一起</p><ul><li>早期绑定：在程序运行以前执行绑定（C语言）</li><li>后期绑定（也叫运行期绑定、<strong>动态绑定</strong>）：提供<strong>某种机制</strong>，在运行期间判断对象的类型，调用适当的方法</li></ul><h3 id="2-1-什么是动态绑定"><a href="#2-1-什么是动态绑定" class="headerlink" title="2.1 什么是动态绑定"></a>2.1 什么是动态绑定</h3><blockquote><p>提供<strong>某种机制</strong>，在运行期间判断对象的类型，调用适当的方法</p></blockquote><h3 id="2-2-为什么使用动态绑定"><a href="#2-2-为什么使用动态绑定" class="headerlink" title="2.2 为什么使用动态绑定"></a>2.2 为什么使用动态绑定</h3><p>我想这里应该很清晰了，上溯造型只是为我们提供了一种简单而巧妙地方法，通过子类对象上溯父类类型，然而这并不是一个完整的过程，找到正确的父类类型后，还应该产生正确的相应，而动态绑定正是在此时发挥了作用</p><h3 id="2-3-怎么使用动态绑定"><a href="#2-3-怎么使用动态绑定" class="headerlink" title="2.3 怎么使用动态绑定"></a>2.3 怎么使用动态绑定</h3><p>动态绑定是由虚拟机代替我们实现的，在上溯造型并获得正确的响应后，动态绑定就体现在这一过程中，所以我们只需要理解其原理，弄清楚虚拟机是如何做到调用正确的方法即可。</p><p>（这个坑以后来填）</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>上溯造型</tag>
      </tags>
  </entry>
  <entry>
    <title>242.有效的字母异位词</title>
    <url>/2020/04/01/LeetCode/242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
    <content><![CDATA[<!-- build time:Thu Apr 02 2020 23:06:21 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定两个字符串 <em>s</em> 和 <em>t</em> ，编写一个函数来判断 <em>t</em> 是否是 <em>s</em> 的字母异位词。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;rat&quot;, t &#x3D; &quot;car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>说明:</strong><br>你可以假设字符串只包含小写字母。</p><p><strong>进阶:</strong><br>如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-Hash表"><a href="#1-Hash表" class="headerlink" title="1.Hash表"></a>1.Hash表</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><p>将两个字符串分别映射到两个Hash表中，然后对比两个Hash表即可</p><h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">char</span> *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr1[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span> arr2[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arr1[i] = <span class="number">0</span>;</span><br><span class="line">        arr2[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s); i++)</span><br><span class="line">        arr1[s[i] - <span class="string">'a'</span>]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(t); i++)</span><br><span class="line">        arr2[t[i] - <span class="string">'a'</span>]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (arr1[i] != arr2[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-排序"><a href="#2-排序" class="headerlink" title="2.排序"></a>2.排序</h3><h4 id="2-1-思路"><a href="#2-1-思路" class="headerlink" title="2.1 思路"></a>2.1 思路</h4><p>分别将两个字符串的字符进行内排序，然后逐位比较两个字符串</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hash-table</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>733.图像渲染</title>
    <url>/2020/04/01/LeetCode/733.%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<!-- build time:Thu Apr 02 2020 23:06:21 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。</p><p>给你一个坐标 <code>(sr, sc)</code> 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 <code>newColor</code>，让你重新上色这幅图像。</p><p>为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。</p><p>最后返回经过上色渲染后的图像。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">image &#x3D; [[1,1,1],[1,1,0],[1,0,1]]</span><br><span class="line">sr &#x3D; 1, sc &#x3D; 1, newColor &#x3D; 2</span><br><span class="line">输出: [[2,2,2],[2,2,0],[2,0,1]]</span><br><span class="line">解析: </span><br><span class="line">在图像的正中间，(坐标(sr,sc)&#x3D;(1,1)),</span><br><span class="line">在路径上所有符合条件的像素点的颜色都被更改成2。</span><br><span class="line">注意，右下角的像素没有更改为2，</span><br><span class="line">因为它不是在上下左右四个方向上与初始点相连的像素点。</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><code>image</code> 和 <code>image[0]</code> 的长度在范围 <code>[1, 50]</code> 内。</li><li>给出的初始点将满足 <code>0 &lt;= sr &lt; image.length</code> 和 <code>0 &lt;= sc &lt; image[0].length</code>。</li><li><code>image[i][j]</code> 和 <code>newColor</code> 表示的颜色值在范围 <code>[0, 65535]</code>内。</li></ul><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归、DFS"><a href="#1-递归、DFS" class="headerlink" title="1.递归、DFS"></a>1.递归、DFS</h3><p>题目理解：将<code>image[sr][sc]</code>的上下左右四个方向的相邻像素单位转换为新值，前提是：各方向的值与<code>image[sr][sc]</code>相等</p><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><ol><li>如果横纵坐标超出二维矩阵，终止递归</li><li>如果<code>image[sr][sc]</code>等于各方向的值，则令<code>image[sr][sc]</code>变为新颜色，然后递归执行这一过程</li></ol><h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an array of arrays of size *returnSize.</span></span><br><span class="line"><span class="comment"> * The sizes of the arrays are returned as *returnColumnSizes array.</span></span><br><span class="line"><span class="comment"> * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> **<span class="built_in">image</span>, <span class="keyword">int</span> imageSize, <span class="keyword">int</span> *imageColSize, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sr &lt; <span class="number">0</span> || sr &gt;= imageSize || sc &lt; <span class="number">0</span> || sc &gt;= imageColSize[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (val == <span class="built_in">image</span>[sr][sc])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">image</span>[sr][sc] = newColor;</span><br><span class="line">        dfs(val, <span class="built_in">image</span>, imageSize, imageColSize, sr, sc + <span class="number">1</span>, newColor);</span><br><span class="line">        dfs(val, <span class="built_in">image</span>, imageSize, imageColSize, sr, sc - <span class="number">1</span>, newColor);</span><br><span class="line">        dfs(val, <span class="built_in">image</span>, imageSize, imageColSize, sr + <span class="number">1</span>, sc, newColor);</span><br><span class="line">        dfs(val, <span class="built_in">image</span>, imageSize, imageColSize, sr - <span class="number">1</span>, sc, newColor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> **<span class="title">floodFill</span><span class="params">(<span class="keyword">int</span> **<span class="built_in">image</span>, <span class="keyword">int</span> imageSize, <span class="keyword">int</span> *imageColSize, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor, <span class="keyword">int</span> *returnSize, <span class="keyword">int</span> **returnColumnSizes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *returnSize = imageSize;</span><br><span class="line">    *returnColumnSizes = imageColSize;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">image</span>[sr][sc] != newColor)</span><br><span class="line">        dfs(<span class="built_in">image</span>[sr][sc], <span class="built_in">image</span>, imageSize, imageColSize, sr, sc, newColor);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">image</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>depth-first-search</tag>
      </tags>
  </entry>
  <entry>
    <title>Java对象是如何创建的？</title>
    <url>/2020/03/31/Java/Java%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%9A%84%EF%BC%9F/</url>
    <content><![CDATA[<!-- build time:Tue Mar 31 2020 17:02:36 GMT+0800 (GMT+08:00) --><h2 id="1-检查static关键字"><a href="#1-检查static关键字" class="headerlink" title="1.检查static关键字"></a>1.检查static关键字</h2><p>如果有static关键字修饰，即该对象为一个静态对象，那么其会被<strong>优先</strong>加载到虚拟机中执行；</p><h2 id="2-找到class"><a href="#2-找到class" class="headerlink" title="2.找到class"></a>2.找到class</h2><p>找到class后，会创建一个Class对象，其所有static模块都会执行，但是只在对象载入时执行一次</p><h2 id="3-分配内存"><a href="#3-分配内存" class="headerlink" title="3.分配内存"></a>3.分配内存</h2><p>此时，new关键字所修饰的类进程会在内存堆（Heap）中，为该类分配足够的内存空间</p><h2 id="4-初始化"><a href="#4-初始化" class="headerlink" title="4.初始化"></a>4.初始化</h2><p>这时，被分配的内存空间会被清零，并将不同的变量类型初始化为默认值（一般为0）</p><h2 id="5-执行构造器"><a href="#5-执行构造器" class="headerlink" title="5.执行构造器"></a>5.执行构造器</h2><p>最后执行构造器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//StaticInitialization.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bowl</span></span>&#123;</span><br><span class="line">    Bowl(<span class="keyword">int</span> maker)&#123;</span><br><span class="line">        System.out.println(<span class="string">"Bowl("</span>+maker+<span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> maker)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"f("</span>+maker+<span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Table</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Bowl b1 = <span class="keyword">new</span> Bowl(<span class="number">1</span>);</span><br><span class="line">    Table()&#123;</span><br><span class="line">        System.out.println(<span class="string">"Table"</span>);</span><br><span class="line">        b2.f(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> maker)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"f2("</span>+maker+<span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> Bowl b2 = <span class="keyword">new</span> Bowl(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cupboard</span></span>&#123;</span><br><span class="line">    Bowl b3 = <span class="keyword">new</span> Bowl(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">static</span> Bowl b4 = <span class="keyword">new</span> Bowl(<span class="number">4</span>);</span><br><span class="line">    Cupboard()&#123;</span><br><span class="line">        System.out.println(<span class="string">"Cupboard()"</span>);</span><br><span class="line">        b4.f(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">int</span> maker)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"f3("</span>+maker+<span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> Bowl b5 = <span class="keyword">new</span> Bowl(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Desk</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> desk;</span><br><span class="line">    Desk()&#123;</span><br><span class="line">        System.out.println(<span class="string">"Desk()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> Bowl b6 = <span class="keyword">new</span> Bowl(<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInitialization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Creating new Cupboard in main"</span>);</span><br><span class="line">        <span class="keyword">new</span> Cupboard();</span><br><span class="line">        <span class="comment">//t2，t3已经实现被实例化了</span></span><br><span class="line">        t2.f2(<span class="number">1</span>);</span><br><span class="line">        t3.f3(<span class="number">1</span>);</span><br><span class="line">        System.out.println(desk.desk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态对象被优先加载</span></span><br><span class="line">    <span class="keyword">static</span> Table t2 = <span class="keyword">new</span> Table();</span><br><span class="line">    <span class="keyword">static</span> Cupboard t3 = <span class="keyword">new</span> Cupboard();</span><br><span class="line">    <span class="keyword">static</span> Desk desk = <span class="keyword">new</span> Desk();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里解释一下：<strong>为什么主函数之外的代码先执行了？</strong></p><p>Java编译时会从main()所在的类开始编译，然后main()外的对象实例化都是静态的，所以，其会被优先加载到虚拟机中执行，执行完毕后，在进入主函数。</p><p>如果主函数变成这样呢：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInitialization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Creating new Cupboard in main"</span>);</span><br><span class="line">        <span class="keyword">new</span> Cupboard();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，main()函数外没有静态变量，所以直接进入主函数；</p><ol><li>输出：Creating new Cupboard in main</li><li>实例化一个Cupboard()对象：<ol><li>寻找名为Cupboard的class</li><li>先执行其中的static</li><li>再执行构造器</li></ol></li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo</title>
    <url>/2020/03/27/%E5%85%B6%E4%BB%96/Hexo/</url>
    <content><![CDATA[<!-- build time:Tue Apr 21 2020 21:45:05 GMT+0800 (GMT+08:00) --><h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><ol><li>安装Hexo脚手架：<code>npm install -g hexo-cli</code></li><li>在任意目录下初始化：<code>hexo init Blog</code></li></ol><h2 id="2-插件"><a href="#2-插件" class="headerlink" title="2.插件"></a>2.插件</h2><ul><li><p>hexagon</p><ul><li><p>hexo的包管理工具</p></li><li><p>安装：<code>npm install -g hexagon-cli</code></p></li><li><p>查看初始化后的hexo的所有插件和主题：<code>hexa -l</code></p></li></ul></li><li><p>hexo-auto-category</p><ul><li>自动解析文章目录，方便博文归类整理</li><li>安装：<code>npm install hexo-auto-category --save</code></li></ul></li><li><p>hexo-wordcount</p><ul><li>自动统计文章字数</li></ul></li><li><p>hexo-symbols-count-time</p><ul><li>自动统计阅读时长</li></ul></li><li>hexo-renderer-kramed<ul><li>Latex渲染引擎</li></ul></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>108.将有序数组转换为二叉搜索树</title>
    <url>/2020/03/21/LeetCode/108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<!-- build time:Mon Apr 06 2020 23:14:41 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定有序数组: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     &#x2F; \</span><br><span class="line">   -3   9</span><br><span class="line">   &#x2F;   &#x2F;</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><ol><li>类似于二分查找的过程，向下取整，构建二叉搜索树</li></ol><p><strong>注意：使用中序遍历构建的二叉搜索树形态不唯一</strong></p><h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct TreeNode *<span class="title">help</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">root</span> = (<span class="title">struct</span> <span class="title">TreeNode</span> *)<span class="title">calloc</span>(1, <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">TreeNode</span>));</span></span><br><span class="line">    <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;<span class="comment">//参考评论，防止溢出</span></span><br><span class="line">    root-&gt;val = nums[mid];</span><br><span class="line">    root-&gt;left = help(nums, l, mid - <span class="number">1</span>);</span><br><span class="line">    root-&gt;right = help(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">struct TreeNode *<span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> help(nums, <span class="number">0</span>, numsSize - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>depth-first-search</tag>
      </tags>
  </entry>
  <entry>
    <title>669.修剪二叉搜索树</title>
    <url>/2020/03/21/LeetCode/669.%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个二叉搜索树，同时给定最小边界<code>L</code> 和最大边界 <code>R</code>。通过修剪二叉搜索树，使得所有节点的值在<code>[L, R]</code>中 (R&gt;=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  0   2</span><br><span class="line"></span><br><span class="line">  L &#x3D; 1</span><br><span class="line">  R &#x3D; 2</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line">    1</span><br><span class="line">      \</span><br><span class="line">       2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  0   4</span><br><span class="line">   \</span><br><span class="line">    2</span><br><span class="line">   &#x2F;</span><br><span class="line">  1</span><br><span class="line"></span><br><span class="line">  L &#x3D; 1</span><br><span class="line">  R &#x3D; 3</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line">      3</span><br><span class="line">     &#x2F; </span><br><span class="line">   2   </span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><p>完全参考<a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/solution/xiu-jian-er-cha-sou-suo-shu-by-leetcode/" target="_blank" rel="noopener">官方题解</a>，这个方法太巧妙了，学习了！</p><blockquote><p><strong>思路</strong></p><p>令 trim(node) 作为该节点上的子树的理想答案。我们可以递归地构建该答案。</p><p><strong>算法</strong></p><p>当 node.val &gt; R，那么修剪后的二叉树必定出现在节点的左边。</p><p>类似地，当node.val &lt; L，那么修剪后的二叉树出现在节点的右边。否则，我们将会修剪树的两边。</p></blockquote><h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode *<span class="title">trimBST</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &lt; L)</span><br><span class="line">        <span class="keyword">return</span> trimBST(root-&gt;right, L, R);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &gt; R)</span><br><span class="line">        <span class="keyword">return</span> trimBST(root-&gt;left, L, R);</span><br><span class="line">    root-&gt;left = trimBST(root-&gt;left, L, R);</span><br><span class="line">    root-&gt;right = trimBST(root-&gt;right, L, R);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>938.二叉搜索树的范围和</title>
    <url>/2020/03/19/LeetCode/938.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定二叉搜索树的根结点 <code>root</code>，返回 <code>L</code> 和 <code>R</code>（含）之间的所有结点的值的和。</p><p>二叉搜索树保证具有唯一的值。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [10,5,15,3,7,null,18], L &#x3D; 7, R &#x3D; 15</span><br><span class="line">输出：32</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [10,5,15,3,7,13,18,1,null,6], L &#x3D; 6, R &#x3D; 10</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>树中的结点数量最多为 <code>10000</code> 个。</li><li>最终的答案保证小于 <code>2^31</code>。</li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><p>思路非常简单，递归判断左右子树，符合要求就将值并入sum，最后返回sum</p><h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rangeSumBST</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &gt;= L &amp;&amp; root-&gt;val &lt;= R)</span><br><span class="line">        sum += root-&gt;val;</span><br><span class="line">    <span class="keyword">int</span> l = rangeSumBST(root-&gt;left, L, R);</span><br><span class="line">    <span class="keyword">int</span> r = rangeSumBST(root-&gt;right, L, R);</span><br><span class="line">    sum = sum + l + r;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>965.单值二叉树</title>
    <url>/2020/03/19/LeetCode/965.%E5%8D%95%E5%80%BC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>如果二叉树每个节点都具有相同的值，那么该二叉树就是<em>单值</em>二叉树。</p><p>只有给定的树是单值二叉树时，才返回 <code>true</code>；否则返回 <code>false</code>。</p><p><strong>示例 1：</strong></p><p><img src="https://i.loli.net/2020/03/19/OpILqw2D4Gizg8b.png" alt="binarysearchtree_improved.png" style="zoom:33%"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,1,1,1,1,null,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://i.loli.net/2020/03/19/Kwfm71GPi9W6nMy.png" alt="screen-shot-2018-12-25-at-50050-pm.png" style="zoom:33%"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[2,2,2,5,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>给定树的节点数范围是 <code>[1, 100]</code>。</li><li>每个节点的值都是整数，范围为 <code>[0, 99]</code> 。</li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><ol><li>空树为单值二叉树</li><li>不是空树时，递归判断根节点的值与孩子节点是否相等</li><li>左右子树都相等时，返回true，否则返回false</li></ol><h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">help</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == val)</span><br><span class="line">        <span class="keyword">return</span> help(root-&gt;left, val) &amp;&amp; help(root-&gt;right, val);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isUnivalTree</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> single = root-&gt;val;</span><br><span class="line">    <span class="keyword">return</span> help(root-&gt;left, single) &amp;&amp; help(root-&gt;right, single);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>993.二叉树的堂兄弟节点</title>
    <url>/2020/03/19/LeetCode/993.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A0%82%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>在二叉树中，根节点位于深度 <code>0</code> 处，每个深度为 <code>k</code> 的节点的子节点位于深度 <code>k+1</code> 处。</p><p>如果二叉树的两个节点深度相同，但<strong>父节点不同</strong>，则它们是一对<em>堂兄弟节点</em>。</p><p>我们给出了具有唯一值的二叉树的根节点 <code>root</code>，以及树中两个不同节点的值 <code>x</code> 和 <code>y</code>。</p><p>只有与值 <code>x</code> 和 <code>y</code> 对应的节点是堂兄弟节点时，才返回 <code>true</code>。否则，返回 <code>false</code>。</p><p><strong>示例 1：</strong><br><img src="https://i.loli.net/2020/03/19/XJyPZTOWcQK4AB2.png" alt="1.png"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3,4], x &#x3D; 4, y &#x3D; 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong><br><img src="https://i.loli.net/2020/03/19/1chzTqvHgXKRwfM.png" alt="2.png"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3,null,4,null,5], x &#x3D; 5, y &#x3D; 4</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://i.loli.net/2020/03/19/ejY36O5HBMqkL8x.png" alt="3.png"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3,null,4], x &#x3D; 2, y &#x3D; 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>二叉树的节点数介于 <code>2</code> 到 <code>100</code> 之间。</li><li>每个节点的值都是唯一的、范围为 <code>1</code> 到 <code>100</code> 的整数。</li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><p>关键信息：堂兄弟节点的定义：<strong>深度相同，父节点不同</strong></p><ol><li>使用辅助函数，求x和y的深度及其父节点</li><li>由于辅助函数执行完毕后，会释放函数内部变量的内存空间，参考了评论中一位大神的题解，可以使用结构体存储深度和父节点</li><li>递归调用help()函数即可</li></ol><h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//深度相同，父节点不同</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> deepth;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">father</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"><span class="comment">//求深度和父节点</span></span><br><span class="line">help(struct TreeNode *root, <span class="keyword">int</span> val, <span class="keyword">int</span> deepth, struct TreeNode *father, struct Node *node)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == val)</span><br><span class="line">    &#123;</span><br><span class="line">        node-&gt;father = father;</span><br><span class="line">        node-&gt;deepth = deepth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        help(root-&gt;left, val, deepth + <span class="number">1</span>, root, node);</span><br><span class="line">        help(root-&gt;right, val, deepth + <span class="number">1</span>, root, node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isCousins</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">node1</span> = (<span class="title">struct</span> <span class="title">Node</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Node</span>));</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">node2</span> = (<span class="title">struct</span> <span class="title">Node</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Node</span>));</span></span><br><span class="line">    node1-&gt;deepth = <span class="number">0</span>;</span><br><span class="line">    node1-&gt;father = <span class="literal">NULL</span>;</span><br><span class="line">    node2-&gt;deepth = <span class="number">0</span>;</span><br><span class="line">    node2-&gt;father = <span class="literal">NULL</span>;</span><br><span class="line">    help(root, x, <span class="number">0</span>, <span class="literal">NULL</span>, node1);</span><br><span class="line">    help(root, y, <span class="number">0</span>, <span class="literal">NULL</span>, node2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, node1-&gt;deepth);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, node2-&gt;deepth);</span><br><span class="line">    <span class="keyword">return</span> node1-&gt;deepth == node2-&gt;deepth &amp;&amp; node1-&gt;father != node2-&gt;father;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>672.二叉树中第二小的节点</title>
    <url>/2020/03/18/LeetCode/672.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 <code>2</code> 或 <code>0</code>。如果一个节点有两个子节点的话，那么这个节点的值不大于它的子节点的值。</p><p>给出这样的一个二叉树，你需要输出所有节点中的<strong>第二小的值。</strong>如果第二小的值不存在的话，输出 -1 <strong>。</strong></p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    5   7</span><br><span class="line"></span><br><span class="line">输出: 5</span><br><span class="line">说明: 最小的值是 2 ，第二小的值是 5 。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"></span><br><span class="line">输出: -1</span><br><span class="line">说明: 最小的值是 2, 但是不存在第二小的值。</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><p>关键条件：根节点 &lt;= 孩子节点。由此可得根节点为最小的节点。</p><p>如果两个孩子节点都大于根节点，则不向下递归，返回较小的值；</p><p>否则：即存在根节点 == 孩子节点的情况</p><ul><li>如果左孩子等于根节点，则在此处的孩子节点不存在比不存在第二小的节点，那么继续向下递归，寻找此子树中比根节点大的值，并返回这个值，并与右孩子比较</li><li>如果右孩子等于根节点，同上</li><li>如果有一个孩子大于根节点，则返回这个值，等于根节点的子树继续递归，不存在则返回 -1</li></ul><h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">help</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> <span class="built_in">min</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &gt; <span class="built_in">min</span>)</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    <span class="keyword">int</span> l = help(root-&gt;left, <span class="built_in">min</span>);</span><br><span class="line">    <span class="keyword">int</span> r = help(root-&gt;right, <span class="built_in">min</span>);</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">return</span> l &gt; r ? r : l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findSecondMinimumValue</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> help(root, root-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>700.二叉搜索树中的搜索</title>
    <url>/2020/03/16/LeetCode/700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p><p>例如，</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定二叉搜索树:</span><br><span class="line"></span><br><span class="line">        4</span><br><span class="line">       &#x2F; \</span><br><span class="line">      2   7</span><br><span class="line">     &#x2F; \</span><br><span class="line">    1   3</span><br><span class="line"></span><br><span class="line">和值: 2</span><br></pre></td></tr></table></figure><p>你应该返回如下子树:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  2     </span><br><span class="line"> &#x2F; \   </span><br><span class="line">1   3</span><br></pre></td></tr></table></figure><p>在上述示例中，如果要找的值是 <code>5</code>，但因为没有节点值为 <code>5</code>，我们应该返回 <code>NULL</code>。</p><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-二叉搜索树的遍历"><a href="#1-二叉搜索树的遍历" class="headerlink" title="1.二叉搜索树的遍历"></a>1.二叉搜索树的遍历</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><ol><li>根节点的值大于val时，根节点指向左孩子；</li><li>根节点的值小于val时，根节点指向右孩子；</li><li>否则返回根节点</li></ol><h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode *<span class="title">searchBST</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; val)</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; val)</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>872.叶子相似的树</title>
    <url>/2020/03/16/LeetCode/872.%E5%8F%B6%E5%AD%90%E7%9B%B8%E4%BC%BC%E7%9A%84%E6%A0%91/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>请考虑一颗二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 <em>叶值序列</em> 。</p><p><img src="https://i.loli.net/2020/03/16/l6cBuoOSaj1Eg5L.png" alt="binarysearchtree_improved.png" style="zoom:50%"></p><p>举个例子，如上图所示，给定一颗叶值序列为 <code>(6, 7, 4, 9, 8)</code> 的树。</p><p>如果有两颗二叉树的叶值序列是相同，那么我们就认为它们是 <em>叶相似</em> 的。</p><p>如果给定的两个头结点分别为 <code>root1</code> 和 <code>root2</code> 的树是叶相似的，则返回 <code>true</code>；否则返回 <code>false</code> 。</p><p><strong>提示：</strong></p><ul><li>给定的两颗树可能会有 <code>1</code> 到 <code>100</code> 个结点。</li></ul><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><ol><li>如果root的左右子树都为空，就将此节点加入到数组中</li><li>递归调用上述过程</li><li>对比两个数组内容</li></ol><h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 100</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getLeaf</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *arr, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">        arr[(*returnSize)++] = root-&gt;val;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        getLeaf(root-&gt;left, arr, returnSize);</span><br><span class="line">        getLeaf(root-&gt;right, arr, returnSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">leafSimilar</span><span class="params">(struct TreeNode *root1, struct TreeNode *root2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr1[maxSize];</span><br><span class="line">    <span class="keyword">int</span> len1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> arr2[maxSize];</span><br><span class="line">    <span class="keyword">int</span> len2 = <span class="number">0</span>;</span><br><span class="line">    getLeaf(root1, arr1, &amp;len1);</span><br><span class="line">    getLeaf(root2, arr2, &amp;len2);</span><br><span class="line">    <span class="keyword">if</span> (len1 != len2)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++)</span><br><span class="line">        <span class="keyword">if</span> (arr1[i] != arr2[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>depth-first-search</tag>
      </tags>
  </entry>
  <entry>
    <title>897.递增顺序查找树</title>
    <url>/2020/03/16/LeetCode/897.%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个树，<strong>按中序遍历</strong>重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。</p><p><strong>示例 ：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[5,3,6,2,4,null,8,1,null,null,null,7,9]</span><br><span class="line"></span><br><span class="line">       5</span><br><span class="line">      &#x2F; \</span><br><span class="line">    3    6</span><br><span class="line">   &#x2F; \    \</span><br><span class="line">  2   4    8</span><br><span class="line"> &#x2F;        &#x2F; \ </span><br><span class="line">1        7   9</span><br><span class="line"></span><br><span class="line">输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]</span><br><span class="line"></span><br><span class="line"> 1</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">    \</span><br><span class="line">     3</span><br><span class="line">      \</span><br><span class="line">       4</span><br><span class="line">        \</span><br><span class="line">         5</span><br><span class="line">          \</span><br><span class="line">           6</span><br><span class="line">            \</span><br><span class="line">             7</span><br><span class="line">              \</span><br><span class="line">               8</span><br><span class="line">                \</span><br><span class="line">                 9</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>给定树中的结点数介于 1 和 100 之间。</li><li>每个结点都有一个从 0 到 1000 范围内的唯一整数值。</li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><p>参考了<a href="https://leetcode-cn.com/u/rebellious_robot/" target="_blank" rel="noopener">rebellious_robot</a>的题解</p><ol><li><strong>声明一个父节点指针，协助递归过程</strong></li><li>向左递归访问，如果孩子节点为空，则返回父节点</li><li>令孩子节点的左孩子为空</li><li>孩子节点的右孩子则为：递归访问<strong>父节点</strong>的右孩子</li></ol><p><strong>父节点的作用是为了递归遍历右子树的，如果没有这个父节点，那么在递归函数的一次完整的执行过程中，无法访问递归右子树。</strong></p><h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct TreeNode *<span class="title">help</span><span class="params">(struct TreeNode *child, struct TreeNode *father)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> father;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">cur</span> = <span class="title">help</span>(<span class="title">child</span>-&gt;<span class="title">left</span>, <span class="title">child</span>);</span></span><br><span class="line">    child-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    child-&gt;right = help(child-&gt;right, father);</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">struct TreeNode *<span class="title">increasingBST</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> help(root, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-迭代-构建新树"><a href="#2-迭代-构建新树" class="headerlink" title="2.迭代+构建新树"></a>2.迭代+构建新树</h3><h4 id="2-1-思路"><a href="#2-1-思路" class="headerlink" title="2.1 思路"></a>2.1 思路</h4><ol><li>中序遍历，遍历结果存储在数组中</li><li>借助数组，创建一颗新树</li></ol><h4 id="2-2-代码"><a href="#2-2-代码" class="headerlink" title="2.2 代码"></a>2.2 代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct TreeNode *<span class="title">increasingBST</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">stack</span>[100], *<span class="title">p</span> = <span class="title">root</span>;</span></span><br><span class="line">    <span class="keyword">int</span> stackTop = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> arrTop = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (stackTop != <span class="number">-1</span> || p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">stack</span>[++stackTop] = p;</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        p = <span class="built_in">stack</span>[stackTop--];</span><br><span class="line">        arr[++arrTop] = p-&gt;val;</span><br><span class="line">        p = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">res</span> = (<span class="title">struct</span> <span class="title">TreeNode</span> *)<span class="title">malloc</span>(1 * <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">TreeNode</span>));</span></span><br><span class="line">    res-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    res-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    res-&gt;val = arr[<span class="number">0</span>];</span><br><span class="line">    p = res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= arrTop; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">cur</span> = (<span class="title">struct</span> <span class="title">TreeNode</span> *)<span class="title">malloc</span>(1 * <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">TreeNode</span>));</span></span><br><span class="line">        cur-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        cur-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        cur-&gt;val = arr[i];</span><br><span class="line">        p-&gt;right = cur;</span><br><span class="line">        p = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>depth-first-search</tag>
      </tags>
  </entry>
  <entry>
    <title>501.二叉搜索树中的众数</title>
    <url>/2020/03/15/LeetCode/501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p><p>假定 BST 有如下定义：</p><ul><li>结点左子树中所含结点的值小于等于当前结点的值</li><li>结点右子树中所含结点的值大于等于当前结点的值</li><li>左子树和右子树都是二叉搜索树</li></ul><p>例如：<br>给定 BST <code>[1,null,2,2]</code>,</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> &#x2F;</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p><code>返回[2]</code>.</p><p><strong>提示</strong>：如果众数超过1个，不需考虑输出顺序</p><p><strong>进阶：</strong>你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-迭代-遍历"><a href="#1-迭代-遍历" class="headerlink" title="1.迭代+遍历"></a>1.迭代+遍历</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><ol><li>迭代法获得递增序列</li><li>for循环寻找递增序列中的众数</li></ol><h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 10000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">findMode</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> arr[maxSize];</span><br><span class="line">    <span class="keyword">int</span> arrTop = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">stack</span>[<span class="title">maxSize</span>], *<span class="title">p</span> = <span class="title">root</span>;</span></span><br><span class="line">    <span class="keyword">int</span> stackTop = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (stackTop != <span class="number">-1</span> || p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">stack</span>[++stackTop] = p;</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        p = <span class="built_in">stack</span>[stackTop--];</span><br><span class="line">        arr[++arrTop] = p-&gt;val;</span><br><span class="line">        p = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在有序数组中找众数</span></span><br><span class="line">    <span class="keyword">int</span> *res = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(maxSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> mode = arr[<span class="number">0</span>]; <span class="comment">//当前数字</span></span><br><span class="line">    <span class="keyword">int</span> mode_num = <span class="number">0</span>;  <span class="comment">//当前数字的数量</span></span><br><span class="line">    <span class="keyword">int</span> nums = <span class="number">0</span>;      <span class="comment">//众数的数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= arrTop; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == mode) <span class="comment">//如果等于当前数字，</span></span><br><span class="line">            mode_num++;     <span class="comment">//当前数字数量加一</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            mode_num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (mode_num &gt; nums) <span class="comment">//如果当前数字的数量&gt;众数的数量</span></span><br><span class="line">        &#123;</span><br><span class="line">            res[<span class="number">0</span>] = arr[i]; <span class="comment">//从头开始添加众数</span></span><br><span class="line">            *returnSize = <span class="number">1</span>;</span><br><span class="line">            nums = mode_num; <span class="comment">//更新众数的数量</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mode_num == nums)</span><br><span class="line">            res[(*returnSize)++] = arr[i];</span><br><span class="line">        mode = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>617.合并二叉树</title>
    <url>/2020/03/14/LeetCode/617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p><p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则<strong>不为</strong> NULL 的节点将直接作为新二叉树的节点。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">	Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         &#x2F; \                       &#x2F; \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       &#x2F;                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">输出: </span><br><span class="line">合并后的树:</span><br><span class="line">	     3</span><br><span class="line">	    &#x2F; \</span><br><span class="line">	   4   5</span><br><span class="line">	  &#x2F; \   \ </span><br><span class="line">	 5   4   7</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 合并必须从两个树的根节点开始。</p><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><p>当t1的左子树（右子树）与t2的左子树（右子树）都不为空时，递归地将t2树合并到t1树中</p><h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(struct TreeNode *t1, struct TreeNode *t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t1-&gt;val += t2-&gt;val;</span><br><span class="line">    <span class="keyword">if</span> (t1-&gt;left &amp;&amp; t2-&gt;left)</span><br><span class="line">        visit(t1-&gt;left, t2-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (!t1-&gt;left &amp;&amp; t2-&gt;left)</span><br><span class="line">        t1-&gt;left = t2-&gt;left;</span><br><span class="line">    <span class="keyword">if</span> (t1-&gt;right &amp;&amp; t2-&gt;right)</span><br><span class="line">        visit(t1-&gt;right, t2-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (!t1-&gt;right &amp;&amp; t2-&gt;right)</span><br><span class="line">        t1-&gt;right = t2-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">struct TreeNode *<span class="title">mergeTrees</span><span class="params">(struct TreeNode *t1, struct TreeNode *t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t1 == <span class="literal">NULL</span> &amp;&amp; t2 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1 != <span class="literal">NULL</span> &amp;&amp; t2 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    <span class="keyword">if</span> (t1 == <span class="literal">NULL</span> &amp;&amp; t2 != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> t2;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">p</span> = <span class="title">t1</span>;</span></span><br><span class="line">    visit(p, t2);</span><br><span class="line">    <span class="keyword">return</span> t1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>653.两数之和 IV - 输入 BST</title>
    <url>/2020/03/14/LeetCode/653.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%20IV%20-%20%E8%BE%93%E5%85%A5%20BST/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。</p><p><strong>案例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  3   6</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">2   4   7</span><br><span class="line"></span><br><span class="line">Target &#x3D; 9</span><br><span class="line"></span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure><p><strong>案例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  3   6</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">2   4   7</span><br><span class="line"></span><br><span class="line">Target &#x3D; 28</span><br><span class="line"></span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-中序遍历-for嵌套"><a href="#1-中序遍历-for嵌套" class="headerlink" title="1.中序遍历+for嵌套"></a>1.中序遍历+for嵌套</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><ol><li>使用中序遍历得到一个递增数组</li><li>遍历递增数组</li></ol><h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 10000</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findTarget</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> arr[maxSize];</span><br><span class="line">    <span class="keyword">int</span> arrTop = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">stack</span>[<span class="title">maxSize</span>], *<span class="title">p</span> = <span class="title">root</span>;</span></span><br><span class="line">    <span class="keyword">int</span> stackTop = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (stackTop != <span class="number">-1</span> || p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">stack</span>[++stackTop] = p;</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        p = <span class="built_in">stack</span>[stackTop--];</span><br><span class="line">        arr[++arrTop] = p-&gt;val;</span><br><span class="line">        p = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrTop; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= arrTop; j++)</span><br><span class="line">            <span class="keyword">if</span> (arr[i] + arr[j] == k)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>687.最长同值路径</title>
    <url>/2020/03/14/LeetCode/687.%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。</p><p><strong>注意</strong>：两个节点之间的路径长度由它们之间的边数表示。</p><p><strong>示例 1:</strong></p><p>输入:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   5</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">1   1   5</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p>输入:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   5</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">4   4   5</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 给定的二叉树不超过10000个结点。 树的高度不超过1000。</p><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><p>此题与<a href="https://www.wangtaocs.top/2020/03/12/543.二叉树的直径">543.二叉树的直径</a>和<a href="https://www.wangtaocs.top/2020/03/13/563.二叉树的坡度">563.二叉树的坡度</a>的思路非常相似</p><p>1.在递归过程中，左右子树中，与当前根节点值相等的节点数目的和的最大值</p><h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//左右子树中，与根节点值相等的节点数目的和的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">help</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> leftLen = help(root-&gt;left, num);</span><br><span class="line">    <span class="keyword">int</span> rightLen = help(root-&gt;right, num);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;val == root-&gt;val)<span class="comment">//向左遍历与根节点相等的子节点</span></span><br><span class="line">        l = <span class="number">1</span> + leftLen;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right != <span class="literal">NULL</span> &amp;&amp; root-&gt;right-&gt;val == root-&gt;val)<span class="comment">//向左遍历与根节点相等的子节点</span></span><br><span class="line">        r = <span class="number">1</span> + rightLen;</span><br><span class="line">    *num = *num &lt; (l + r) ? (l + r) : *num;</span><br><span class="line">    <span class="keyword">return</span> l &gt; r ? l : r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestUnivaluePath</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span> || (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    help(root, &amp;res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>538.把二叉搜索树转换为累加树</title>
    <url>/2020/03/13/LeetCode/538.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。</p><p><strong>例如：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 原始二叉搜索树:</span><br><span class="line">              5</span><br><span class="line">            &#x2F;   \</span><br><span class="line">           2     13</span><br><span class="line"></span><br><span class="line">输出: 转换为累加树:</span><br><span class="line">             18</span><br><span class="line">            &#x2F;   \</span><br><span class="line">          20     13</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>本题和 1038: <a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同</p><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><ol><li>二叉搜索树的中序遍历是递增数列，则<strong>逆</strong>中序遍历则是递减序列</li><li>声明一个累加值res = 0；</li><li>利用这一性质，对其进行逆中序遍历，开始使用累加值更新节点值</li><li>在遍历左子树前，要更新res的值</li></ol><h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorderReverse</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    inorderReverse(root-&gt;right, res);</span><br><span class="line">   	root-&gt;val += *res;<span class="comment">//更新root节点的值</span></span><br><span class="line">    *res = root-&gt;val;<span class="comment">//更新res的值</span></span><br><span class="line">    inorderReverse(root-&gt;left, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode *<span class="title">convertBST</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    inorderReverse(root, &amp;res);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便把1038题也做了 :)</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>563.二叉树的坡度</title>
    <url>/2020/03/13/LeetCode/563.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9D%A1%E5%BA%A6/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个二叉树，计算<strong>整个树</strong>的坡度。</p><p>一个树的<strong>节点的坡度</strong>定义即为，该节点左子树的结点之和和右子树结点之和的<strong>差的绝对值</strong>。空结点的的坡度是0。</p><p><strong>整个树</strong>的坡度就是其所有节点的坡度之和。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">         1</span><br><span class="line">       &#x2F;   \</span><br><span class="line">      2     3</span><br><span class="line">输出: 1</span><br><span class="line">解释: </span><br><span class="line">结点的坡度 2 : 0</span><br><span class="line">结点的坡度 3 : 0</span><br><span class="line">结点的坡度 1 : |2-3| &#x3D; 1</span><br><span class="line">树的坡度 : 0 + 0 + 1 &#x3D; 1</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>任何子树的结点的和不会超过32位整数的范围。</li><li>坡度的值不会超过32位整数的范围。</li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><p>此题与<a href="https://www.wangtaocs.top/2020/03/12/543.二叉树的直径">543.二叉树的直径</a>的思路非常相似</p><ol><li>使用递归，求得左右子树的节点之和，该节点的坡度即为左右子树的节点之和的差的绝对值，整棵树的坡度即为所有节点的坡度和</li></ol><p><strong>注意：</strong></p><ol><li>子树的节点和还包括根节点。</li><li>无孩子的结点的的坡度是0。</li></ol><h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumOfTree</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    <span class="keyword">int</span> l = sumOfTree(root-&gt;left, sum);</span><br><span class="line">    <span class="keyword">int</span> r = sumOfTree(root-&gt;right, sum);</span><br><span class="line">    *sum += <span class="built_in">abs</span>(l - r);</span><br><span class="line">    <span class="keyword">return</span> l + r + root-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findTilt</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span> || (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    sumOfTree(root, &amp;res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>572.另一个树的子树</title>
    <url>/2020/03/13/LeetCode/572.%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定两个非空二叉树 <strong>s</strong> 和 <strong>t</strong>，检验 <strong>s</strong> 中是否包含和 <strong>t</strong> 具有相同结构和节点值的子树。<strong>s</strong> 的一个子树包括 <strong>s</strong> 的一个节点和这个节点的所有子孙。<strong>s</strong> 也可以看做它自身的一棵子树。</p><p><strong>示例 1:</strong><br>给定的树 s:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   5</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure><p>给定的树 t：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  4 </span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure><p>返回 <strong>true</strong>，因为 t 与 s 的一个子树拥有相同的结构和节点值。</p><p><strong>示例 2:</strong><br>给定的树 s：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   5</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br><span class="line">   &#x2F;</span><br><span class="line">  0</span><br></pre></td></tr></table></figure><p>给定的树 t：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  4</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure><p>返回 <strong>false</strong>。</p><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><ol><li><p>什么叫子树？</p><p>答：树B是树A的子集。即A与B相等；或B是A的左子树或右子树的子树。</p></li></ol><h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(struct TreeNode *s, struct TreeNode *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span> &amp;&amp; t == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> (s &amp;&amp; t) &amp;&amp; s-&gt;val == t-&gt;val &amp;&amp; isSame(s-&gt;left, t-&gt;left) &amp;&amp; isSame(s-&gt;right, t-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(struct TreeNode *s, struct TreeNode *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span> &amp;&amp; t == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span> &amp;&amp; t != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSame(s, t) || isSubtree(s-&gt;left, t) || isSubtree(s-&gt;right, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>530.二叉搜索树的最小绝对差</title>
    <url>/2020/03/12/LeetCode/530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     3</span><br><span class="line">    &#x2F;</span><br><span class="line">   2</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中至少有 2 个节点。</li><li>本题与 783 <a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/</a> 相同</li></ul><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-中序遍历-数组遍历"><a href="#1-中序遍历-数组遍历" class="headerlink" title="1.中序遍历+数组遍历"></a>1.中序遍历+数组遍历</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><ol><li>使用中序遍历二叉搜索树，得到一个不严格的递增序列</li><li>遍历这个递增序列，找到最小差值</li></ol><h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 10000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[maxSize];</span><br><span class="line">    <span class="keyword">int</span> arrTop = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">stack</span>[<span class="title">maxSize</span>], *<span class="title">p</span> = <span class="title">root</span>;</span></span><br><span class="line">    <span class="keyword">int</span> stackTop = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (stackTop != <span class="number">-1</span> || p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">stack</span>[++stackTop] = p;</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        p = <span class="built_in">stack</span>[stackTop--];</span><br><span class="line">        arr[++arrTop] = p-&gt;val;</span><br><span class="line">        p = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = arr[<span class="number">1</span>] - arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= arrTop; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i] - arr[i - <span class="number">1</span>];</span><br><span class="line">        res = res &gt; temp ? temp : res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然和783题一样，那就顺便做了，嘿嘿嘿😄</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>543.二叉树的直径</title>
    <url>/2020/03/12/LeetCode/543.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。</p><p><strong>示例 :</strong><br>给定二叉树</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line"> &#x2F; \     </span><br><span class="line">4   5</span><br></pre></td></tr></table></figure><p>返回 <strong>3</strong>, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p><p><strong>注意：</strong>两结点之间的路径长度是以它们之间边的数目表示。</p><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><ol><li><p>使用递归，求得左右子树的最大深度，直径即为左右子树的最大深度之和，由此得到了第一版代码：</p><p>遇到测试用例：<strong>[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]</strong></p></li></ol><p><img src="https://i.loli.net/2020/03/12/Dex32TKBlkfazpQ.png" alt="Snipaste_2020-03-12_22-21-10.png"></p><ol><li>由此测试用例意识到，二叉树的直径是：在递归的过程中，左右子树的最大深度之和的<strong>最大值</strong>，由此得到第二版代码：</li></ol><h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4><p>第一版：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> l = maxDepth(root-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> r = maxDepth(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> (l &gt; r ? l : r) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> maxDepth(root-&gt;left) + maxDepth(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二版：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> l = maxDepth(root-&gt;left, res);</span><br><span class="line">    <span class="keyword">int</span> r = maxDepth(root-&gt;right, res);</span><br><span class="line">    *res = *res &lt; (l + r) ? (l + r) : *res;</span><br><span class="line">    <span class="keyword">return</span> (l &gt; r ? l : r) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span> || (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    maxDepth(root, &amp;res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>226.反转二叉树</title>
    <url>/2020/03/11/LeetCode/226.%E5%8F%8D%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>翻转一棵二叉树。</p><p><strong>示例：</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure><p><strong>备注:</strong><br>这个问题是受到 <a href="https://twitter.com/mxcl" target="_blank" rel="noopener">Max Howell </a>的 <a href="https://twitter.com/mxcl/status/608682016205344768" target="_blank" rel="noopener">原问题</a> 启发的 ：</p><blockquote><p>谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</p></blockquote><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><ol><li>声明一个辅助指针用于交换当前节点的左右孩子</li><li>递归反转左右孩子的孩子节点</li></ol><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode *<span class="title">invertTree</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">p</span>;</span></span><br><span class="line">    p = root-&gt;left;</span><br><span class="line">    root-&gt;left = root-&gt;right;</span><br><span class="line">    root-&gt;right = p;</span><br><span class="line">    invertTree(root-&gt;left);</span><br><span class="line">    invertTree(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>235.二叉搜索树的最近公共祖先</title>
    <url>/2020/03/11/LeetCode/235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin" target="_blank" rel="noopener">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p>例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]</p><p><img src="https://i.loli.net/2020/03/11/p6gGR9iUweEfkbL.png" alt="binarysearchtree_improved.png"></p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li></ul><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><p>利用<strong>二叉搜索树</strong>的性质</p><p>当p和q的值都小于根结点时，就去左树中找；</p><p>当p和q的值都大于根结点时，就去右树中找；</p><p>否则，返回根节点。</p><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct TreeNode *<span class="title">lowestCommonAncestor</span><span class="params">(struct TreeNode *root, struct TreeNode *p, struct TreeNode *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>404.左叶子之和</title>
    <url>/2020/03/11/LeetCode/404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>计算给定二叉树的所有左叶子之和。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><p>什么叫左叶子？</p><p>答：左孩子节点不为空且左孩子没有孩子节点。</p><p>递归判断左右子树，返回所有左叶子之和。</p><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//左叶子：</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">        res += root-&gt;left-&gt;val;</span><br><span class="line">    <span class="keyword">return</span> res + sumOfLeftLeaves(root-&gt;left) + sumOfLeftLeaves(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>437.路径总和 III</title>
    <url>/2020/03/11/LeetCode/437.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20III/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个二叉树，它的每个结点都存放着一个整数值。</p><p>找出路径和等于给定数值的路径总数。</p><p>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p>二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1], sum &#x3D; 8</span><br><span class="line"></span><br><span class="line">      10</span><br><span class="line">     &#x2F;  \</span><br><span class="line">    5   -3</span><br><span class="line">   &#x2F; \    \</span><br><span class="line">  3   2   11</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">3  -2   1</span><br><span class="line"></span><br><span class="line">返回 3。和等于 8 的路径有:</span><br><span class="line"></span><br><span class="line">1.  5 -&gt; 3</span><br><span class="line">2.  5 -&gt; 2 -&gt; 1</span><br><span class="line">3.  -3 -&gt; 11</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-双重递归"><a href="#1-双重递归" class="headerlink" title="1.双重递归"></a>1.双重递归</h3><blockquote><p>完全参考leetcode用户<a href="https://leetcode-cn.com/u/feng-huo-qian-qin-lu/" target="_blank" rel="noopener">烽火前秦路</a>的题解</p></blockquote><p>使用两层递归：</p><p>第一层：</p><ul><li>help()函数：遍历从顶点开始和为sum的路径数</li></ul><p>第二层：</p><ul><li>pathSum()函数：通过调用help()函数，遍历根节点，并递归遍历左右子树中所有和为sum的路径数</li></ul><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">help</span><span class="params">(struct TreeNode *p, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;val == sum)</span><br><span class="line">        res++;</span><br><span class="line">    res += help(p-&gt;left, sum - p-&gt;val);</span><br><span class="line">    res += help(p-&gt;right, sum - p-&gt;val);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = help(root, sum);</span><br><span class="line">    <span class="keyword">return</span> cnt + pathSum(root-&gt;left, sum) + pathSum(root-&gt;right, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>101.对称二叉树</title>
    <url>/2020/03/10/LeetCode/101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure><p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>如果你可以运用递归和迭代两种方法解决这个问题，会很加分。</p><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><p>什么是对称二叉树：</p><ol><li>根节点的左右孩子相等</li><li>左孩子的左子树 == 右孩子的右子树 &amp;&amp; 左孩子的右子树 == 右孩子的左子树</li><li>递归第二个条件</li></ol><h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">visit</span><span class="params">(struct TreeNode *nodel, struct TreeNode *noder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nodel == <span class="literal">NULL</span> &amp;&amp; noder == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (nodel == <span class="literal">NULL</span> || noder == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (nodel-&gt;val == noder-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> visit(nodel-&gt;left, noder-&gt;right) &amp;&amp; visit(nodel-&gt;right, noder-&gt;left);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> visit(root-&gt;left, root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>depth-first-search</tag>
        <tag>breadth-first-search</tag>
      </tags>
  </entry>
  <entry>
    <title>98.验证二叉搜索树</title>
    <url>/2020/03/10/LeetCode/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li><li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-中序遍历（非递归）"><a href="#1-中序遍历（非递归）" class="headerlink" title="1.中序遍历（非递归）"></a>1.中序遍历（非递归）</h3><ul><li>使用中序遍历二叉树</li><li>用一个变量记录最小值</li><li>当指针p所指的值大于最小值时，更新最小值，否则返回false；</li></ul><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 1000</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">stack</span>[<span class="title">maxSize</span>], *<span class="title">p</span> = <span class="title">root</span>;</span></span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//flag是为了处理 -2147483648</span></span><br><span class="line">    <span class="keyword">int</span> a = -__INT_MAX__ - <span class="number">1</span>, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (top != <span class="number">-1</span> || p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">stack</span>[++top] = p;</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        p = <span class="built_in">stack</span>[top--];</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val &gt; a || flag == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a = p-&gt;val;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        p = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>depth-first-search</tag>
      </tags>
  </entry>
  <entry>
    <title>96.不同的二叉搜索树</title>
    <url>/2020/03/09/LeetCode/96.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个整数 <em>n</em>，求以 1 … <em>n</em> 为节点组成的二叉搜索树有多少种？</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">给定 n &#x3D; 3, 一共有 5 种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-应用卡塔兰数"><a href="#1-应用卡塔兰数" class="headerlink" title="1. 应用卡塔兰数"></a>1. 应用<a href="https://baike.baidu.com/item/catalan/7605685?fr=aladdin" target="_blank" rel="noopener">卡塔兰数</a></h3><ul><li><p>卡特兰数的通项式：<script type="math/tex">A_{n}=\frac{1}{n+1} C_{2 n}^{n}=C_{2 n}^{n}-C_{2 n}^{n-1}</script></p></li><li><p>卡特兰数的递推式：<script type="math/tex">A_{n+1}=\sum_{i=0}^{n} a A_{i} A_{n-i}</script></p></li></ul><p>因为通项式中的数太大会造成，所以采用递推式进行计算</p><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        res = res * <span class="number">2</span> * (<span class="number">2</span> * i + <span class="number">1</span>) / (i + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>dynamic-programming</tag>
      </tags>
  </entry>
  <entry>
    <title>621.任务调度器</title>
    <url>/2020/03/08/LeetCode/621.%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。</p><p>然而，两个<strong>相同种类</strong>的任务之间必须有长度为 <strong>n</strong> 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p><p>你需要计算完成所有任务所需要的<strong>最短时间</strong>。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: tasks &#x3D; [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n &#x3D; 2</span><br><span class="line">输出: 8</span><br><span class="line">执行顺序: A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B.</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><ol><li>任务的总个数为 [1, 10000]。</li><li>n 的取值范围为 [0, 100]。</li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>设计：完全参考了<a href="https://leetcode-cn.com/problems/task-scheduler/solution/ren-wu-diao-du-qi-by-leetcode/" target="_blank" rel="noopener">官解的方法三</a></li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><p><del>我不是很理解，这里就把官解贴在这里吧</del>🙃</p><blockquote><p>在前两种方法中，我们了解到应当尽早安排出现次数较多的任务。我们假设 A 为出现次数最多的任务，假设其出现了 p 次，考虑到冷却时间，那么执行完所有任务的时间至少为 (p - 1) <em>(n + 1) + 1。我们把这个过程形象化地用图 1 表现出，可以发现，CPU 产生了 (p - 1) </em>n 个空闲时间，只有 p 个时间是在工作的。</p><p><img src="https://i.loli.net/2020/03/08/VHNaA2oPFLmXRIZ.png" alt="621_Task_Scheduler_new.png"></p><p>因此我们应当考虑把剩余的任务安排到这些空闲时间里，我们仍然按照这些任务的出现次序，从大到小进行安排，会有下面三种情况：</p><ul><li><p>某个任务和 A 出现的次数相同，例如图 2 中的任务 B。此时我们只能让 B 占据 p - 1 个空闲时间，而在非空闲时间里额外安排一个时间给 B 执行；</p></li><li><p>某个任务比 A 出现的次数少 1，例如图 2 中的任务 C。此时我们可以让 C 占据 p - 1 个空闲时间，就可以全部执行完；</p></li><li><p>某个任务比 A 出现的次数少 2 或更多，例如图 2 中的任务 D。此时我们可以按照列优先的顺序，将 D 填入空闲时间中。因为 D 出现的次数少于 p - 1，因此无论从哪个位置开始按照列优先的顺序放置，都可以保证相邻的两个 D 之间满足冷却时间的要求。</p></li></ul><p>在将所有的任务安排完成后，如果仍然有剩余的空闲时间，那么答案即为（任务的总数 + 剩余的空闲时间）；如果在安排某一个任务时，遇到了剩余的空闲时间不够的情况，那么答案一定就等于任务的总数。这是因为我们可以将空闲时间增加虚拟的一列，继续安排任务。如果不考虑这些虚拟的列，在原本空闲时间对应的那些列中的任务是可以按照要求顺序执行的，而增加了这些虚拟的列后，两个相邻的相同任务的间隔不可能减少，并且虚拟的列中的任务也满足冷却时间的要求，因此仍然顺序执行并跳过虚拟的列中剩余的“空闲时间”一定是可行的。</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">int</span> *)a - *(<span class="keyword">int</span> *)b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="keyword">char</span> *tasks, <span class="keyword">int</span> tasksSize, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">map</span>, <span class="number">0</span>, <span class="number">26</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasksSize; i++)</span><br><span class="line">        <span class="built_in">map</span>[tasks[i] - <span class="string">'A'</span>]++;</span><br><span class="line">    qsort(<span class="built_in">map</span>, <span class="number">26</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), cmp);</span><br><span class="line">    <span class="keyword">int</span> max_val = <span class="built_in">map</span>[<span class="number">25</span>] - <span class="number">1</span>, idle_slots = max_val * n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">24</span>; i &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">map</span>[i] &gt; <span class="number">0</span>; i--)</span><br><span class="line">        idle_slots -= <span class="built_in">min</span>(<span class="built_in">map</span>[i], max_val);</span><br><span class="line">    <span class="keyword">return</span> idle_slots &gt; <span class="number">0</span> ? idle_slots + tasksSize : tasksSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>design</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title>641.设计循环双端队列</title>
    <url>/2020/03/08/LeetCode/641.%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>设计实现双端队列。<br>你的实现需要支持以下操作：</p><ul><li>MyCircularDeque(k)：构造函数,双端队列的大小为k。</li><li>insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true。</li><li>insertLast()：将一个元素添加到双端队列尾部。如果操作成功返回 true。</li><li>deleteFront()：从双端队列头部删除一个元素。 如果操作成功返回 true。</li><li>deleteLast()：从双端队列尾部删除一个元素。如果操作成功返回 true。</li><li>getFront()：从双端队列头部获得一个元素。如果双端队列为空，返回 -1。</li><li>getRear()：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1。</li><li>isEmpty()：检查双端队列是否为空。</li><li>isFull()：检查双端队列是否满了。</li></ul><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyCircularDeque circularDeque &#x3D; new MycircularDeque(3); &#x2F;&#x2F; 设置容量大小为3</span><br><span class="line">circularDeque.insertLast(1);			        &#x2F;&#x2F; 返回 true</span><br><span class="line">circularDeque.insertLast(2);			        &#x2F;&#x2F; 返回 true</span><br><span class="line">circularDeque.insertFront(3);			        &#x2F;&#x2F; 返回 true</span><br><span class="line">circularDeque.insertFront(4);			        &#x2F;&#x2F; 已经满了，返回 false</span><br><span class="line">circularDeque.getRear();  				&#x2F;&#x2F; 返回 2</span><br><span class="line">circularDeque.isFull();				        &#x2F;&#x2F; 返回 true</span><br><span class="line">circularDeque.deleteLast();			        &#x2F;&#x2F; 返回 true</span><br><span class="line">circularDeque.insertFront(4);			        &#x2F;&#x2F; 返回 true</span><br><span class="line">circularDeque.getFront();				&#x2F;&#x2F; 返回 4</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>所有值的范围为 [1, 1000]</li><li>操作次数的范围为 [1, 1000]</li><li>请不要使用内置的双端队列库。</li></ul><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>队列</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol><li>注意循环队列要对队列长度取余</li><li>多申请一个空间用于判断队列是否已满</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125; MyCircularDeque;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. Set the size of the deque to be k. */</span></span><br><span class="line"></span><br><span class="line"><span class="function">MyCircularDeque *<span class="title">myCircularDequeCreate</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyCircularDeque *obj = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyCircularDeque) * (k + <span class="number">1</span>));</span><br><span class="line">    obj-&gt;data = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (k + <span class="number">1</span>));</span><br><span class="line">    obj-&gt;front = <span class="number">0</span>;</span><br><span class="line">    obj-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    obj-&gt;length = k + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数声明，才能调用</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCircularDequeIsFull</span><span class="params">(MyCircularDeque *obj)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCircularDequeIsEmpty</span><span class="params">(MyCircularDeque *obj)</span></span>;</span><br><span class="line"><span class="comment">/** Adds an item at the front of Deque. Return true if the operation is successful. */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCircularDequeInsertFront</span><span class="params">(MyCircularDeque *obj, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (myCircularDequeIsFull(obj))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = (obj-&gt;front + obj-&gt;length - <span class="number">1</span>) % obj-&gt;length;</span><br><span class="line">    obj-&gt;data[pos] = value;</span><br><span class="line">    obj-&gt;front = pos;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Adds an item at the rear of Deque. Return true if the operation is successful. */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCircularDequeInsertLast</span><span class="params">(MyCircularDeque *obj, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (myCircularDequeIsFull(obj))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    obj-&gt;data[obj-&gt;rear] = value;</span><br><span class="line">    obj-&gt;rear = (obj-&gt;rear + <span class="number">1</span>) % obj-&gt;length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Deletes an item from the front of Deque. Return true if the operation is successful. */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCircularDequeDeleteFront</span><span class="params">(MyCircularDeque *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (myCircularDequeIsEmpty(obj))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    obj-&gt;front = (obj-&gt;front + <span class="number">1</span>) % obj-&gt;length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Deletes an item from the rear of Deque. Return true if the operation is successful. */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCircularDequeDeleteLast</span><span class="params">(MyCircularDeque *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (myCircularDequeIsEmpty(obj))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    obj-&gt;rear = (obj-&gt;rear - <span class="number">1</span> + obj-&gt;length) % obj-&gt;length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get the front item from the deque. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myCircularDequeGetFront</span><span class="params">(MyCircularDeque *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (myCircularDequeIsEmpty(obj))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;data[obj-&gt;front];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get the last item from the deque. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myCircularDequeGetRear</span><span class="params">(MyCircularDeque *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (myCircularDequeIsEmpty(obj))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = (obj-&gt;rear + obj-&gt;length - <span class="number">1</span>) % obj-&gt;length;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;data[pos];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Checks whether the circular deque is empty or not. */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCircularDequeIsEmpty</span><span class="params">(MyCircularDeque *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;front == obj-&gt;rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Checks whether the circular deque is full or not. */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCircularDequeIsFull</span><span class="params">(MyCircularDeque *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;front == (obj-&gt;rear + <span class="number">1</span>) % obj-&gt;length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myCircularDequeFree</span><span class="params">(MyCircularDeque *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyCircularDeque struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyCircularDeque* obj = myCircularDequeCreate(k);</span></span><br><span class="line"><span class="comment"> * bool param_1 = myCircularDequeInsertFront(obj, value);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * bool param_2 = myCircularDequeInsertLast(obj, value);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * bool param_3 = myCircularDequeDeleteFront(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * bool param_4 = myCircularDequeDeleteLast(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_5 = myCircularDequeGetFront(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_6 = myCircularDequeGetRear(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * bool param_7 = myCircularDequeIsEmpty(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * bool param_8 = myCircularDequeIsFull(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * myCircularDequeFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>design</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title>933.最近的请求次数</title>
    <url>/2020/03/08/LeetCode/933.%E6%9C%80%E8%BF%91%E7%9A%84%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>写一个 <code>RecentCounter</code> 类来计算最近的请求。</p><p>它只有一个方法：<code>ping(int t)</code>，其中 <code>t</code> 代表以毫秒为单位的某个时间。</p><p>返回从 3000 毫秒前到现在的 <code>ping</code> 数。</p><p>任何处于 <code>[t - 3000, t]</code> 时间范围之内的 <code>ping</code> 都将会被计算在内，包括当前（指 <code>t</code> 时刻）的 <code>ping</code>。</p><p>保证每次对 <code>ping</code> 的调用都使用比之前更大的 <code>t</code> 值。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：inputs &#x3D; [&quot;RecentCounter&quot;,&quot;ping&quot;,&quot;ping&quot;,&quot;ping&quot;,&quot;ping&quot;], inputs &#x3D; [[],[1],[100],[3001],[3002]]</span><br><span class="line">输出：[null,1,2,3,3]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>每个测试用例最多调用 <code>10000</code> 次 <code>ping</code>。</li><li>每个测试用例会使用严格递增的 <code>t</code> 值来调用 <code>ping</code>。</li><li>每次调用 <code>ping</code> 都有 <code>1 &lt;= t &lt;= 10^9</code>。</li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>队列</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol><li>扫描数组，逐一进队</li><li>当队头元素 &lt; 队尾元素时，出队</li><li>返回当前队伍长度</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 100000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *<span class="built_in">queue</span>;</span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line"></span><br><span class="line">&#125; RecentCounter;</span><br><span class="line"></span><br><span class="line"><span class="function">RecentCounter *<span class="title">recentCounterCreate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RecentCounter *rt = (RecentCounter *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(RecentCounter));</span><br><span class="line">    rt-&gt;<span class="built_in">queue</span> = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(maxSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">memset</span>(rt-&gt;<span class="built_in">queue</span>, <span class="number">-1</span>, maxSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    rt-&gt;front = <span class="number">0</span>;</span><br><span class="line">    rt-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recentCounterPing</span><span class="params">(RecentCounter *obj, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj-&gt;rear = (obj-&gt;rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">    obj-&gt;<span class="built_in">queue</span>[obj-&gt;rear] = t;</span><br><span class="line">    <span class="keyword">while</span> (obj-&gt;<span class="built_in">queue</span>[obj-&gt;front + <span class="number">1</span>] &lt; t - <span class="number">3000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        obj-&gt;front = (obj-&gt;front + <span class="number">1</span>) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;rear - obj-&gt;front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recentCounterFree</span><span class="params">(RecentCounter *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(obj-&gt;<span class="built_in">queue</span>);</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RecentCounter struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RecentCounter* obj = recentCounterCreate();</span></span><br><span class="line"><span class="comment"> * int param_1 = recentCounterPing(obj, t);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * recentCounterFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title>1017.负二进制转换</title>
    <url>/2020/03/05/LeetCode/1017.%E8%B4%9F%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给出数字 <code>N</code>，返回由若干 <code>&quot;0&quot;</code> 和 <code>&quot;1&quot;</code>组成的字符串，该字符串为 <code>N</code> 的<strong>负二进制（<code>base -2</code>）</strong>表示。</p><p>除非字符串就是 <code>&quot;0&quot;</code>，否则返回的字符串中不能含有前导零。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：2</span><br><span class="line">输出：&quot;110&quot;</span><br><span class="line">解释：(-2) ^ 2 + (-2) ^ 1 &#x3D; 2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：&quot;111&quot;</span><br><span class="line">解释：(-2) ^ 2 + (-2) ^ 1 + (-2) ^ 0 &#x3D; 3</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：4</span><br><span class="line">输出：&quot;100&quot;</span><br><span class="line">解释：(-2) ^ 2 &#x3D; 4</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>0 &lt;= N &lt;= 10^9</code></li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>栈+二进制转化的变形</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><p>这道题是<strong>负二进制转换</strong></p><p>我们先回忆一下二进制转换：</p><ol><li>对给定的整数<strong>N</strong>进行短除，将余数压入栈中，</li><li>当最后除数为一时，停止短除，并将最后的一压入栈中，</li><li>最后将栈反转过来即可。</li></ol><p>参考这一过程，我们可以基本捋清楚负二进制转换的过程：</p><ol><li>对给定的整数<strong>N</strong>进行短除，将余数压入栈中，但是，我们会发现：余数可能为<strong>-1</strong>，所以我们对这个余数进行特殊处理，令其为一，此时的<code>N = (N - 1) / -2</code></li><li>二三步不变</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize __INT16_MAX__</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">baseNeg2</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span>[maxSize];</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (N != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mod = N % <span class="number">-2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mod &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mod = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">stack</span>[++top] = mod;</span><br><span class="line">            N = (N - <span class="number">1</span>) / <span class="number">-2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">stack</span>[++top] = mod;</span><br><span class="line">            N = N / <span class="number">-2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stack</span>[++top] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *res = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(maxSize * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (top != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res[i++] = <span class="built_in">stack</span>[top--] + <span class="string">'0'</span>;<span class="comment">//将数字转换为字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    res[i++] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>dynamic-programming</tag>
        <tag>stack</tag>
        <tag>ordered-map</tag>
      </tags>
  </entry>
  <entry>
    <title>739.每日温度</title>
    <url>/2020/03/05/LeetCode/739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>根据每日 <code>气温</code> 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 <code>0</code> 来代替。</p><p>例如，给定一个列表 <code>temperatures = [73, 74, 75, 71, 69, 72, 76, 73]</code>，你的输出应该是 <code>[1, 1, 4, 2, 1, 1, 0, 0]</code>。</p><p><strong>提示：</strong><code>气温</code> 列表长度的范围是 <code>[1, 30000]</code>。每个气温的值的均为华氏度，都是在 <code>[30, 100]</code> 范围内的整数。</p><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>暴力法：循环遍历，不再赘述</li><li>栈</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><p>这道题使用栈的解法：参考<a href="https://leetcode-cn.com/u/jalan/" target="_blank" rel="noopener">江不知</a>的评论</p><ol><li>声明一个<strong>存放索引</strong>的辅助栈</li><li>先将<code>T[0]</code>压入栈中</li><li>从<code>T[1]</code>开始遍历<ol><li>当辅助栈不为空时，辅助栈中的索引对应的元素小于待入栈元素时，令<code>res[栈顶索引] = i - 栈顶索引</code>，并出栈</li><li>否则，辅助栈中的索引对应的元素大于待入栈元素，入栈即可</li></ol></li><li>当辅助栈不为空时，说明：之后都不会升高，在该位置用 <code>0</code> 来代替。</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">dailyTemperatures</span><span class="params">(<span class="keyword">int</span> *T, <span class="keyword">int</span> TSize, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *res = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(TSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span>[TSize];</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>[++top] = i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; TSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (top != <span class="number">-1</span> &amp;&amp; T[<span class="built_in">stack</span>[top]] &lt; T[i])</span><br><span class="line">        &#123;</span><br><span class="line">            res[<span class="built_in">stack</span>[top]] = i - <span class="built_in">stack</span>[top];</span><br><span class="line">            top--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">stack</span>[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (top != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res[<span class="built_in">stack</span>[top]] = <span class="number">0</span>;</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = TSize;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个解法就很巧妙了，时空复杂度为O(n)，比暴力法要好一点，然而我只想到了暴力法……</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>stack</tag>
        <tag>hash-table</tag>
      </tags>
  </entry>
  <entry>
    <title>456.132模式</title>
    <url>/2020/03/04/LeetCode/456.132%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个整数序列：a1, a2, …, an，一个132模式的子序列 a<strong>i</strong>, a<strong>j</strong>, a<strong>k</strong> 被定义为：当 <strong>i</strong> &lt; <strong>j</strong> &lt; <strong>k</strong> 时，a<strong>i</strong> &lt; a<strong>k</strong> &lt; a<strong>j</strong>。设计一个算法，当给定有 n 个数字的序列时，验证这个序列中是否含有132模式的子序列。</p><p><strong>注意：</strong>n 的值小于15000。</p><p><strong>示例1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">输出: False</span><br><span class="line"></span><br><span class="line">解释: 序列中不存在132模式的子序列。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3, 1, 4, 2]</span><br><span class="line"></span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">解释: 序列中有 1 个132模式的子序列： [1, 4, 2].</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [-1, 3, 2, 0]</span><br><span class="line"></span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">解释: 序列中有 3 个132模式的的子序列: [-1, 3, 2], [-1, 3, 0] 和 [-1, 2, 0].</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>栈的应用</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><p>参考<a href="https://leetcode-cn.com/problems/132-pattern/solution/132mo-shi-by-leetcode-2/" target="_blank" rel="noopener">官解</a></p><ol><li>为了便于分析，我们约定：<ul><li>“1”：小</li><li>“3”：大</li><li>“2”：中</li></ul></li><li>首先考虑<code>小 &lt; 大</code>的情况，我们可以维护一个前缀最小值的数组<code>min[]</code>，这样，<code>小 &lt; 大</code>便是最优解</li><li>其次考虑<code>大 &gt; 中</code>的情况，我们需要申请一个栈，从后向前遍历数组，<ol><li>当<code>nums[j] &gt; min[j]</code>时，将<code>nums[j]</code>进栈</li><li>如果栈不为空，并且<code>nums[j] &gt; stack[top]</code>时，我们就找到了我们需要的<code>中</code>，返回<code>true</code>；</li><li>如果栈不为空，但是<code>min[j] &gt;= stack[top]</code>时，我们就需要一直出栈，直到找到我们所需要的<code>中</code></li></ol></li><li>如果遍历完整个数组，都没有找到，则返回<code>false</code></li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find132pattern</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize &lt; <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//min[]</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">min</span>[numsSize];</span><br><span class="line">    <span class="built_in">min</span>[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; numsSize; i++)</span><br><span class="line">        <span class="built_in">min</span>[i] = <span class="built_in">min</span>[i - <span class="number">1</span>] &lt; nums[i] ? <span class="built_in">min</span>[i - <span class="number">1</span>] : nums[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span>[numsSize];</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = numsSize - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &gt; <span class="built_in">min</span>[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (top != <span class="number">-1</span> &amp;&amp; <span class="built_in">min</span>[j] &gt;= <span class="built_in">stack</span>[top])</span><br><span class="line">                top--;</span><br><span class="line">            <span class="keyword">if</span> (top != <span class="number">-1</span> &amp;&amp; nums[j] &gt; <span class="built_in">stack</span>[top])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">stack</span>[++top] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>503.下一个更大元素 II</title>
    <url>/2020/03/04/LeetCode/503.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%20II/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,1]</span><br><span class="line">输出: [2,-1,2]</span><br><span class="line">解释: 第一个 1 的下一个更大的数是 2；</span><br><span class="line">数字 2 找不到下一个更大的数； </span><br><span class="line">第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 输入数组的长度不会超过 10000。</p><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>for循环遍历</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><p>和其第一题一样，我还是没有使用stack</p><ol><li>构造一个可以：不管从什么位置开始，都可以遍历整个数组的for循环</li><li>使用循环嵌套遍历整个数组</li><li>能找到下一个更大的数，则赋值；否则，令其值为 -1</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">nextGreaterElements</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> *res = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(numsSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = (i + <span class="number">1</span>) % numsSize; j != i; j = (j + <span class="number">1</span>) % numsSize)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                res[(*returnSize)++] = nums[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res[i] != nums[j])</span><br><span class="line">            res[(*returnSize)++] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>331.验证二叉树的前序序列化</title>
    <url>/2020/03/03/LeetCode/331.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 <code>#</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     _9_</span><br><span class="line">    &#x2F;   \</span><br><span class="line">   3     2</span><br><span class="line">  &#x2F; \   &#x2F; \</span><br><span class="line"> 4   1  #  6</span><br><span class="line">&#x2F; \ &#x2F; \   &#x2F; \</span><br><span class="line"># # # #   # #</span><br></pre></td></tr></table></figure><p>例如，上面的二叉树可以被序列化为字符串 <code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code>，其中 <code>#</code> 代表一个空节点。</p><p>给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。</p><p>每个以逗号分隔的字符或为一个整数或为一个表示 <code>null</code> 指针的 <code>&#39;#&#39;</code> 。</p><p>你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 <code>&quot;1,,3&quot;</code> 。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;1,#&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;9,#,#,1&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>栈、字符串切割</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol><li>将字符串以<code>,</code>切割</li><li>将子字符串逐一进栈</li><li>当栈顶元素与次栈顶元素都为<code>#</code>时，连出三次栈，并将<code>#</code>压入栈中</li><li>在遍历字符串的过程中，如果栈恰好为空，且<strong>子字符串为空</strong>时，说明符合要求，返回true；</li><li>在遍历字符串的过程中，如果栈恰好为空，且<strong>子字符串不为空</strong>时，说明不符合要求，返回false；</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 1024</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *data[maxSize];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125; <span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidSerialization</span><span class="params">(<span class="keyword">char</span> *preorder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preorder[<span class="number">0</span>] == <span class="string">'#'</span> &amp;&amp; preorder[<span class="number">1</span>] == <span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (preorder[<span class="number">0</span>] == <span class="string">'#'</span> &amp;&amp; preorder[<span class="number">1</span>] != <span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">stack</span> *st = (<span class="built_in">stack</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">stack</span>));</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; maxSize; i++)</span><br><span class="line">        st-&gt;data[i] = <span class="literal">NULL</span>;</span><br><span class="line">    st-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//切割字符串</span></span><br><span class="line">    <span class="keyword">char</span> *str = preorder;</span><br><span class="line">    <span class="keyword">char</span> delim[<span class="number">2</span>] = <span class="string">","</span>;</span><br><span class="line">    <span class="keyword">char</span> *token = <span class="literal">NULL</span>;</span><br><span class="line">    token = strtok(str, delim);</span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="keyword">char</span> ship[<span class="number">2</span>] = <span class="string">"#"</span>;</span><br><span class="line">    <span class="keyword">while</span> (token != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        st-&gt;data[++st-&gt;top] = token;</span><br><span class="line">        token = strtok(<span class="literal">NULL</span>, delim);</span><br><span class="line">        <span class="keyword">while</span> (st-&gt;data[st-&gt;top][<span class="number">0</span>] == <span class="string">'#'</span> &amp;&amp; st-&gt;data[st-&gt;top - <span class="number">1</span>][<span class="number">0</span>] == <span class="string">'#'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            st-&gt;data[st-&gt;top--] = <span class="literal">NULL</span>;</span><br><span class="line">            st-&gt;data[st-&gt;top--] = <span class="literal">NULL</span>;</span><br><span class="line">            st-&gt;data[st-&gt;top--] = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span> (st-&gt;top == <span class="number">-1</span> &amp;&amp; token != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (st-&gt;top == <span class="number">-1</span> &amp;&amp; token == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            st-&gt;data[++st-&gt;top] = ship;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>144.二叉树的前序遍历</title>
    <url>/2020/03/02/LeetCode/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个二叉树，返回它的 <em>前序</em> 遍历。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [1,2,3]</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>递归</li><li>迭代</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><p>这里主要说一下迭代法：</p><ol><li>先序遍历的顺序：根节点 -&gt; 左孩子 -&gt; 右孩子</li><li>首先需要声明一个辅助栈，</li><li>先访问根节点，并将其val存到数组中</li><li>接下来该访问左孩子，由于栈是<strong>FILO</strong>，所以遍历时要先让右孩子入栈，才能让左孩子先出栈</li><li>循环这个过程，直至遍历全部节点</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><ol><li><p>递归</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *arr, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[(*returnSize)++] = root-&gt;val;</span><br><span class="line">        visit(root-&gt;left, arr, returnSize);</span><br><span class="line">        visit(root-&gt;right, arr, returnSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">preorderTraversal</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">1000</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    visit(root, arr, returnSize);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>迭代</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 1000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">preorderTraversal</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(maxSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">stack</span>[<span class="title">maxSize</span>], *<span class="title">p</span> = <span class="title">root</span>;</span></span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">stack</span>[++top] = p;</span><br><span class="line">    <span class="keyword">while</span> (top != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = <span class="built_in">stack</span>[top--];</span><br><span class="line">        arr[(*returnSize)++] = p-&gt;val;</span><br><span class="line">        <span class="comment">//stack is FILO,so the preOrder push the rchild into the stack first</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">stack</span>[++top] = p-&gt;right;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">stack</span>[++top] = p-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>145.二叉树的后序遍历</title>
    <url>/2020/03/02/LeetCode/145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个二叉树，返回它的 <em>后序</em> 遍历。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [3,2,1]</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>递归</li><li>迭代</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><p>这里主要说一下迭代法：</p><ol><li>先序遍历的顺序：左孩子 -&gt; 右孩子 -&gt; 根节点；</li><li>我们可以与先序遍历对比一下：<ul><li>先序遍历的顺序：根节点 -&gt; 左孩子 -&gt; 右孩子</li><li>先序遍历的顺序：左孩子 -&gt; 右孩子 -&gt; 根节点</li></ul></li><li>我们可以发现：<strong>后序遍历是先序遍历的逆序序列</strong>，利用这一性质，我们进行后续遍历操作</li><li>这里我们需要两个辅助栈</li><li>首先，我们按照先序遍历的方式遍历整颗二叉树，并将遍历结果存入栈1中；</li><li>然后，再将栈1中的结果全部出栈，并存入数组中即可。</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><ol><li><p>递归</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *arr, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root)</span><br><span class="line">    &#123;</span><br><span class="line">        visit(root-&gt;left, arr, returnSize);</span><br><span class="line">        arr[(*returnSize)++] = root-&gt;val;</span><br><span class="line">        visit(root-&gt;right, arr, returnSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">inorderTraversal</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">1000</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    visit(root, arr, returnSize);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>迭代</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 1000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">postorderTraversal</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(maxSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">Stack1</span>[<span class="title">maxSize</span>];</span></span><br><span class="line">    <span class="keyword">int</span> top1 = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">Stack2</span>[<span class="title">maxSize</span>];</span></span><br><span class="line">    <span class="keyword">int</span> top2 = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">p</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    Stack1[++top1] = root;</span><br><span class="line">    <span class="keyword">while</span> (top1 != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = Stack1[top1--];</span><br><span class="line">        Stack2[++top2] = p;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            Stack1[++top1] = p-&gt;left;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            Stack1[++top1] = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//the stack2 push is the postOrderNonRecursion</span></span><br><span class="line">    <span class="keyword">while</span> (top2 != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = Stack2[top2--];</span><br><span class="line">        arr[(*returnSize)++] = p-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>150.逆波兰表达式求值</title>
    <url>/2020/03/02/LeetCode/150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>根据<a href="https://baike.baidu.com/item/逆波兰式/128437" target="_blank" rel="noopener">逆波兰表示法</a>，求表达式的值。</p><p>有效的运算符包括 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p><strong>说明：</strong></p><ul><li>整数除法只保留整数部分。</li><li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]</span><br><span class="line">输出: 9</span><br><span class="line">解释: ((2 + 1) * 3) &#x3D; 9</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;&#x2F;&quot;, &quot;+&quot;]</span><br><span class="line">输出: 6</span><br><span class="line">解释: (4 + (13 &#x2F; 5)) &#x3D; 6</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;&#x2F;&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]</span><br><span class="line">输出: 22</span><br><span class="line">解释: </span><br><span class="line">  ((10 * (6 &#x2F; ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">&#x3D; ((10 * (6 &#x2F; (12 * -11))) + 17) + 5</span><br><span class="line">&#x3D; ((10 * (6 &#x2F; -132)) + 17) + 5</span><br><span class="line">&#x3D; ((10 * 0) + 17) + 5</span><br><span class="line">&#x3D; (0 + 17) + 5</span><br><span class="line">&#x3D; 17 + 5</span><br><span class="line">&#x3D; 22</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>栈的简单应用</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol><li>注意将字符串负数转化为整数类型时，注意特殊处理</li><li>遇到操作符时，连出两次栈，并将计算结果入栈</li><li>否则，遇到字符串数字，转化为整数类型后，入栈</li><li>最后栈顶元素即为结果</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125; <span class="built_in">stack</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stoi</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">'-'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="built_in">strlen</span>(str); i++)</span><br><span class="line">            res = res * <span class="number">10</span> + (str[i] - <span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> - res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); i++)</span><br><span class="line">        res = res * <span class="number">10</span> + (str[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="keyword">char</span> **tokens, <span class="keyword">int</span> tokensSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span> *st = (<span class="built_in">stack</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">stack</span>));</span><br><span class="line">    st-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(tokensSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    st-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tokensSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tokens[i][<span class="number">0</span>] == <span class="string">'+'</span> &amp;&amp; tokens[i][<span class="number">1</span>] == <span class="string">'\0'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            b = st-&gt;data[st-&gt;top--];</span><br><span class="line">            a = st-&gt;data[st-&gt;top--];</span><br><span class="line">            st-&gt;data[++st-&gt;top] = a + b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tokens[i][<span class="number">0</span>] == <span class="string">'-'</span> &amp;&amp; tokens[i][<span class="number">1</span>] == <span class="string">'\0'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            b = st-&gt;data[st-&gt;top--];</span><br><span class="line">            a = st-&gt;data[st-&gt;top--];</span><br><span class="line">            st-&gt;data[++st-&gt;top] = a - b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tokens[i][<span class="number">0</span>] == <span class="string">'*'</span> &amp;&amp; tokens[i][<span class="number">1</span>] == <span class="string">'\0'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            b = st-&gt;data[st-&gt;top--];</span><br><span class="line">            a = st-&gt;data[st-&gt;top--];</span><br><span class="line">            st-&gt;data[++st-&gt;top] = a * b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tokens[i][<span class="number">0</span>] == <span class="string">'/'</span> &amp;&amp; tokens[i][<span class="number">1</span>] == <span class="string">'\0'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            b = st-&gt;data[st-&gt;top--];</span><br><span class="line">            a = st-&gt;data[st-&gt;top--];</span><br><span class="line">            st-&gt;data[++st-&gt;top] = a / b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            st-&gt;data[++st-&gt;top] = stoi(tokens[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st-&gt;data[st-&gt;top];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码有点复杂了，将就着看😜</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>173.二叉搜索树迭代器</title>
    <url>/2020/03/02/LeetCode/173.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。</p><p>调用 <code>next()</code> 将返回二叉搜索树中的下一个最小的数。</p><p><strong>示例：</strong></p><p><img src="https://i.loli.net/2020/03/02/Zj1g8fKkXOe4PLD.png" alt="bst-tree.png"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BSTIterator iterator &#x3D; new BSTIterator(root);</span><br><span class="line">iterator.next();    &#x2F;&#x2F; 返回 3</span><br><span class="line">iterator.next();    &#x2F;&#x2F; 返回 7</span><br><span class="line">iterator.hasNext(); &#x2F;&#x2F; 返回 true</span><br><span class="line">iterator.next();    &#x2F;&#x2F; 返回 9</span><br><span class="line">iterator.hasNext(); &#x2F;&#x2F; 返回 true</span><br><span class="line">iterator.next();    &#x2F;&#x2F; 返回 15</span><br><span class="line">iterator.hasNext(); &#x2F;&#x2F; 返回 true</span><br><span class="line">iterator.next();    &#x2F;&#x2F; 返回 20</span><br><span class="line">iterator.hasNext(); &#x2F;&#x2F; 返回 false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>next()</code> 和 <code>hasNext()</code> 操作的时间复杂度是 O(1)，并使用 O(<em>h</em>) 内存，其中 <em>h</em> 是树的高度。</li><li>你可以假设 <code>next()</code> 调用总是有效的，也就是说，当调用 <code>next()</code> 时，BST 中至少存在一个下一个最小的数。</li></ul><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>二叉搜索树的遍历问题、二叉树的中序遍历</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol><li>将给定的二叉搜索树进行中序遍历，可以得到一个升序数组</li><li>遍历数组即可。</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize __INT16_MAX__</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">&#125; BSTIterator;</span><br><span class="line"></span><br><span class="line"><span class="function">BSTIterator *<span class="title">bSTIteratorCreate</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    BSTIterator *bsti = (BSTIterator *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTIterator));</span><br><span class="line">    bsti-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(maxSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    bsti-&gt;top = <span class="number">0</span>;</span><br><span class="line">    bsti-&gt;index = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">p</span> = <span class="title">root</span>, *<span class="title">stack</span>[<span class="title">maxSize</span>];</span></span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (top != <span class="number">-1</span> || p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">stack</span>[++top] = p;</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        p = <span class="built_in">stack</span>[top--];</span><br><span class="line">        bsti-&gt;data[bsti-&gt;top++] = p-&gt;val;</span><br><span class="line">        p = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bsti;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** @return the next smallest number */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bSTIteratorNext</span><span class="params">(BSTIterator *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;data[obj-&gt;index++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** @return whether we have a next smallest number */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bSTIteratorHasNext</span><span class="params">(BSTIterator *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;index &lt; obj-&gt;top)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bSTIteratorFree</span><span class="params">(BSTIterator *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BSTIterator struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * BSTIterator* obj = bSTIteratorCreate(root);</span></span><br><span class="line"><span class="comment"> * int param_1 = bSTIteratorNext(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * bool param_2 = bSTIteratorHasNext(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * bSTIteratorFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>stack</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title>94.二叉树的中序遍历</title>
    <url>/2020/03/02/LeetCode/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个二叉树，返回它的<em>中序</em> 遍历。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">输出: [1,3,2]</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>递归</li><li>迭代</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><p>这里主要说一下迭代法：</p><ol><li>中序遍历的顺序：左孩子 -&gt; 根节点 -&gt; 右孩子</li><li>首先需要声明一个辅助栈，</li><li>先访问左孩子，由于这是一个类似递归的过程，所以要一直沿着左孩子的方向一直向左下遍历，并将节点压入栈中；</li><li>找到整颗二叉树中最左下的孩子后，将其val存到数组中</li><li>接下来该访问根节点，继续出栈，即可得到根节点</li><li>然后在访问根节点的右孩子</li><li>循环这个过程，直至遍历全部节点</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><ol><li><p>递归</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *arr, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root)</span><br><span class="line">    &#123;</span><br><span class="line">        visit(root-&gt;left, arr, returnSize);</span><br><span class="line">        arr[(*returnSize)++] = root-&gt;val;</span><br><span class="line">        visit(root-&gt;right, arr, returnSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">inorderTraversal</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">1000</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    visit(root, arr, returnSize);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>迭代</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 1000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">inorderTraversal</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(maxSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">stack</span>[<span class="title">maxSize</span>], *<span class="title">p</span> = <span class="title">root</span>;</span></span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//the Stack may be empty in the process,</span></span><br><span class="line">    <span class="comment">//so the condition that p != NULL can keep the loop continue</span></span><br><span class="line">    <span class="keyword">while</span> (top != <span class="number">-1</span> || p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">stack</span>[++top] = p;</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        p = <span class="built_in">stack</span>[top--];</span><br><span class="line">        arr[(*returnSize)++] = p-&gt;val;</span><br><span class="line">        p = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言递归的那点事</title>
    <url>/2020/03/01/C/C%E8%AF%AD%E8%A8%80%E9%80%92%E5%BD%92%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 18:14:06 GMT+0800 (GMT+08:00) --><h1 id="浅析递归"><a href="#浅析递归" class="headerlink" title="浅析递归"></a>浅析递归</h1><p>​ 递归是一种绝大多数语言都支持的编程方式。但是我本人并不建议使用。</p><h2 id="1-是什么？"><a href="#1-是什么？" class="headerlink" title="1.是什么？"></a>1.是什么？</h2><h3 id="1-1-释义"><a href="#1-1-释义" class="headerlink" title="1.1 释义"></a>1.1 释义</h3><p>​ 允许函数循环调用自己的过程</p><h3 id="1-2-原理"><a href="#1-2-原理" class="headerlink" title="1.2 原理"></a>1.2 原理</h3><ol><li>每级函数调用都有自己的变量</li><li>每次函数调用都会返回一次</li><li>递归函数中位于递归调用之前的语句顺序执行</li><li>递归函数中位于递归调用之后的语句逆序执行</li><li>每级递归都有自己的变量，但并不会拷贝函数代码</li><li><strong>递归函数必须有让递归调用停止的语句，否则将无限递归</strong></li></ol><h2 id="2-为什么？"><a href="#2-为什么？" class="headerlink" title="2.为什么？"></a>2.为什么？</h2><h3 id="2-1-优点"><a href="#2-1-优点" class="headerlink" title="2.1 优点"></a>2.1 优点</h3><p>​ 递归的代码简洁优雅。繁杂的执行过程交由操作系统辅助解决。</p><h3 id="2-2-缺点"><a href="#2-2-缺点" class="headerlink" title="2.2 缺点"></a>2.2 缺点</h3><p>​ 相较于其优点，缺点更加显而易见，由于函数每次递归调用自己时，操作系统都要为其保留函数的运行现场（俗称系统栈），这种系统级的开销会浪费较多的资源，因而代码的效率并不高。而且还不方便人们的阅读，难以理解。</p><h2 id="3-怎么做？"><a href="#3-怎么做？" class="headerlink" title="3.怎么做？"></a>3.怎么做？</h2><p>Talk is cheap,show you the code.</p><h3 id="3-1-普通递归"><a href="#3-1-普通递归" class="headerlink" title="3.1 普通递归"></a>3.1 普通递归</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    ——《C Primer Plus》p595</span></span><br><span class="line"><span class="comment">    函数执行过程：</span></span><br><span class="line"><span class="comment">    1.主函数调用up_and_down(), 并传递参数 1 ;</span></span><br><span class="line"><span class="comment">    2.开始执行up_and_down(), 接受参数 1 ;</span></span><br><span class="line"><span class="comment">    3.(#1)输出参数 n == 1 , 以及参数 n == 1 的地址</span></span><br><span class="line"><span class="comment">    4.进行if判断, n == 1 &lt; 4, 再次调用up_and_down(), 并传递参数 2,与此同时，保留函数第一次执行的运行现场;</span></span><br><span class="line"><span class="comment">    5.进行第一次递归:</span></span><br><span class="line"><span class="comment">        1.(#1)输出参数 n == 2 , 以及参数 n == 2 的地址</span></span><br><span class="line"><span class="comment">        2.进行if判断, n == 2 &lt; 4, 再次调用up_and_down(), 并传递参数 3,与此同时，保留函数第二次执行的运行现场;</span></span><br><span class="line"><span class="comment">        3.进行第二次递归:</span></span><br><span class="line"><span class="comment">            1.(#1)输出参数 n == 3 , 以及参数 n == 3 的地址</span></span><br><span class="line"><span class="comment">            2.进行if判断, n == 3 &lt; 4, 再次调用up_and_down(), 并传递参数 4,与此同时，保留函数第三次执行的运行现场;</span></span><br><span class="line"><span class="comment">            3.进行第三次递归:</span></span><br><span class="line"><span class="comment">                1.(#1)输出参数 n == 4 , 以及参数 n == 4 的地址</span></span><br><span class="line"><span class="comment">                2.进行if判断, n == 4 &lt; 4, 不满足if条件，不执行if内的语句</span></span><br><span class="line"><span class="comment">                3.(#2)输出参数 n == 4 , 以及参数 n == 4 的地址</span></span><br><span class="line"><span class="comment">            4.回归第三次的执行现场</span></span><br><span class="line"><span class="comment">            5.(#2)输出参数 n == 3 , 以及参数 n == 3 的地址</span></span><br><span class="line"><span class="comment">        4.回归第二次的执行现场</span></span><br><span class="line"><span class="comment">        5.(#2)输出参数 n == 2 , 以及参数 n == 2 的地址</span></span><br><span class="line"><span class="comment">    4.回归第一次的执行现场</span></span><br><span class="line"><span class="comment">    5.(#2)输出参数 n == 1 , 以及参数 n == 1 的地址</span></span><br><span class="line"><span class="comment">    6.up_and_down()执行完毕, 回归main()</span></span><br><span class="line"><span class="comment">    7.return 0.</span></span><br><span class="line"><span class="comment">    8.main()执行完毕</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up_and_down</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    up_and_down(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up_and_down</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Level %d: n location %p\n"</span>, n, &amp;n); <span class="comment">//#1</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">4</span>)</span><br><span class="line">        up_and_down(n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"LEVEL %d: n location %p\n"</span>, n, &amp;n); <span class="comment">//#2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-尾递归"><a href="#3-2-尾递归" class="headerlink" title="3.2 尾递归"></a>3.2 尾递归</h3><p>递归调用在主函数的return语句之前。尾递归形式简单，相当于循环。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">rfact</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This program calculates factorials.\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Enter a value in the range 0-12 (q to quit):\n"</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No negative numbers, please.\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; <span class="number">12</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Keep input under 13.\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"recursion: %d factorial = %ld\n"</span>, num, fact(num));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"recursion: %d factorial = %ld\n"</span>, num, rfact(num));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Enter a value in the range 0-12 (q to quit):\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Bye.\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> ans;</span><br><span class="line">    <span class="keyword">for</span> (ans = <span class="number">1</span>; n &gt; <span class="number">1</span>; n--)</span><br><span class="line">    &#123;</span><br><span class="line">        ans *= n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">rfact</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> ans;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">        ans = n * rfact(n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>71.简化路径</title>
    <url>/2020/03/01/LeetCode/71.%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>以 Unix 风格给出一个文件的<strong>绝对路径</strong>，你需要简化它。或者换句话说，将其转换为规范路径。</p><p>在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：<a href="https://blog.csdn.net/u011327334/article/details/50355600" target="_blank" rel="noopener">Linux / Unix中的绝对路径 vs 相对路径</a></p><p>请注意，返回的规范路径必须始终以斜杠 <code>/</code> 开头，并且两个目录名之间必须只有一个斜杠 <code>/</code>。最后一个目录名（如果存在）<strong>不能</strong>以 <code>/</code> 结尾。此外，规范路径必须是表示绝对路径的<strong>最短</strong>字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;&#x2F;home&#x2F;&quot;</span><br><span class="line">输出：&quot;&#x2F;home&quot;</span><br><span class="line">解释：注意，最后一个目录名后面没有斜杠。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;&#x2F;..&#x2F;&quot;</span><br><span class="line">输出：&quot;&#x2F;&quot;</span><br><span class="line">解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;&#x2F;home&#x2F;&#x2F;foo&#x2F;&quot;</span><br><span class="line">输出：&quot;&#x2F;home&#x2F;foo&quot;</span><br><span class="line">解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;&#x2F;a&#x2F;.&#x2F;b&#x2F;..&#x2F;..&#x2F;c&#x2F;&quot;</span><br><span class="line">输出：&quot;&#x2F;c&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;&#x2F;a&#x2F;..&#x2F;..&#x2F;b&#x2F;..&#x2F;c&#x2F;&#x2F;.&#x2F;&#x2F;&quot;</span><br><span class="line">输出：&quot;&#x2F;c&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 6：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;&#x2F;a&#x2F;&#x2F;b&#x2F;&#x2F;&#x2F;&#x2F;c&#x2F;d&#x2F;&#x2F;.&#x2F;.&#x2F;&#x2F;..&quot;</span><br><span class="line">输出：&quot;&#x2F;a&#x2F;b&#x2F;c&quot;</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>字符串遍历、栈的应用</li><li>字符串切割、栈的应用</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><p>法一：</p><ol><li>逐个遍历字符串</li><li>遇到<code>.</code>不变</li><li>遇到<code>..</code>出栈</li><li>遇到<code>/</code>或其他字符时进栈</li></ol><p>​ 这是我第一次想出来的算法，后来遇到了这个测试用例：<code>&quot;/...&quot;</code>,其期望答案居然还是：<code>&quot;/...&quot;</code>。靠，我太难了！😥看了题解之后，发现C语言也有字符串切割的函数，就在<code>string.h</code>这个库里，我心一横，换方法了！</p><p>法二：</p><ol><li>使用<code>strtok()</code>函数，将字符串进行切割</li><li>因为每次切割返回的都是指针，所以我声明了一个指针数组</li><li>将切割出的子字符串的指针压入指针数组中</li><li>然后遍历指针数组</li><li>组合出最终的字符串</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>法一：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">simplifyPath</span><span class="params">(<span class="keyword">char</span> *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(path);</span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">stack</span> = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">stack</span>[++top] = <span class="string">'/'</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (path[i] == <span class="string">'.'</span> &amp;&amp; path[i + <span class="number">1</span>] == <span class="string">'.'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                top = top == <span class="number">0</span> ? <span class="number">0</span> : top - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (<span class="built_in">stack</span>[top] != <span class="string">'/'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (path[i] == <span class="string">'.'</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (path[i] == <span class="string">'/'</span> &amp;&amp; <span class="built_in">stack</span>[top] == <span class="string">'/'</span>)<span class="comment">//防止连续的'/'</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">stack</span>[++top] = path[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span>[top] == <span class="string">'/'</span> &amp;&amp; top &gt; <span class="number">0</span>)</span><br><span class="line">        top--;</span><br><span class="line">    <span class="built_in">stack</span>[++top] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, <span class="built_in">stack</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>法二：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.按照 / 切割字符串</span></span><br><span class="line"><span class="comment">2.遇到 . continue</span></span><br><span class="line"><span class="comment">3.遇到 .. 出栈</span></span><br><span class="line"><span class="comment">4.遇到 字母 进栈，并且进一个 /</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 1024</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *data[maxSize];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125; <span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">simplifyPath</span><span class="params">(<span class="keyword">char</span> *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span> *st = (<span class="built_in">stack</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">stack</span>));</span><br><span class="line">    <span class="comment">//初始化指针数组，这点很重要</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">for</span> (u = <span class="number">0</span>; u &lt; maxSize; u++)</span><br><span class="line">        st-&gt;data[u] = <span class="literal">NULL</span>;</span><br><span class="line">    st-&gt;top = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *str = path;</span><br><span class="line">    <span class="keyword">char</span> delim[<span class="number">2</span>] = <span class="string">"/"</span>;</span><br><span class="line">    <span class="keyword">char</span> *token = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//切割字符串</span></span><br><span class="line">    token = strtok(str, delim);</span><br><span class="line">    st-&gt;data[++st-&gt;top] = delim;</span><br><span class="line">    <span class="comment">// . 无操作</span></span><br><span class="line">    <span class="comment">// .. 连出两次栈</span></span><br><span class="line">    <span class="keyword">while</span> (token != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (token[<span class="number">0</span>] == <span class="string">'.'</span> &amp;&amp; token[<span class="number">1</span>] == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (token[<span class="number">0</span>] == <span class="string">'.'</span> &amp;&amp; token[<span class="number">1</span>] == <span class="string">'.'</span> &amp;&amp; token[<span class="number">2</span>] == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">if</span> (st-&gt;top &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                st-&gt;data[st-&gt;top--] = <span class="literal">NULL</span>;</span><br><span class="line">                st-&gt;data[st-&gt;top--] = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                st-&gt;top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            st-&gt;data[++st-&gt;top] = token;</span><br><span class="line">            st-&gt;data[++st-&gt;top] = delim;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到下一个子字符串的指针</span></span><br><span class="line">        token = strtok(<span class="literal">NULL</span>, delim);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历指针数组所对应的字符串，将其组合成想要的字符串</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">char</span> *res = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(maxSize * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; st-&gt;data[i] != <span class="literal">NULL</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="built_in">strlen</span>(st-&gt;data[i]); j++)</span><br><span class="line">            res[++k] = st-&gt;data[i][j];</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>)</span><br><span class="line">        res[++k] = <span class="string">'\0'</span>;</span><br><span class="line">    res[k] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码写的稀烂，枯了😥</p><h2 id="三、PS"><a href="#三、PS" class="headerlink" title="三、PS"></a>三、PS</h2><p>使用了新的库函数：<code>strtok()</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strtok</span><span class="params">(<span class="keyword">char</span> *__restrict__ _Str, <span class="keyword">const</span> <span class="keyword">char</span> *__restrict__ _Delim)</span></span></span><br></pre></td></tr></table></figure><ul><li>char *<strong>restrict</strong> _Str: 待切割的字符串</li><li>const char *<strong>restrict</strong> _Delim：包含分隔符的 C 字符串</li></ul><p>使用<code>strtok()</code>：</p><blockquote><p>菜鸟教程</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">char</span> str[<span class="number">80</span>] = <span class="string">"This is - www.runoob.com - website"</span>;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> s[<span class="number">2</span>] = <span class="string">"-"</span>;</span><br><span class="line">   <span class="keyword">char</span> *token;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 获取第一个子字符串 */</span></span><br><span class="line">   token = strtok(str, s);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 继续获取其他的子字符串 */</span></span><br><span class="line">   <span class="keyword">while</span>( token != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">      <span class="built_in">printf</span>( <span class="string">"%s\n"</span>, token );</span><br><span class="line">    </span><br><span class="line">      token = strtok(<span class="literal">NULL</span>, s);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>stack</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>496.下一个更大元素 I</title>
    <url>/2020/02/27/LeetCode/496.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%20I/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定两个<strong>没有重复元素</strong>的数组 <code>nums1</code> 和 <code>nums2</code> ，其中<code>nums1</code> 是 <code>nums2</code> 的子集。找到 <code>nums1</code> 中每个元素在 <code>nums2</code> 中的下一个比其大的值。</p><p><code>nums1</code> 中数字 <strong>x</strong> 的下一个更大元素是指 <strong>x</strong> 在 <code>nums2</code> 中对应位置的右边的第一个比 <strong>x</strong> 大的元素。如果不存在，对应位置输出-1。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2].</span><br><span class="line">输出: [-1,3,-1]</span><br><span class="line">解释:</span><br><span class="line">    对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。</span><br><span class="line">    对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。</span><br><span class="line">    对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums1 &#x3D; [2,4], nums2 &#x3D; [1,2,3,4].</span><br><span class="line">输出: [3,-1]</span><br><span class="line">解释:</span><br><span class="line">    对于num1中的数字2，第二个数组中的下一个较大数字是3。</span><br><span class="line">    对于num1中的数字4，第二个数组中没有下一个更大的数字，因此输出 -1。</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li><code>nums1</code>和<code>nums2</code>中所有元素是唯一的。</li><li><code>nums1</code>和<code>nums2</code> 的数组大小都不超过1000。</li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>官解：单调栈</li><li>个人解：for循环遍历</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><p>C语言没有栈和hashmap，所以我使用了for循环遍历</p><ol><li>在<code>nums2</code>中，找到<code>nums1</code>中的元素<code>nums2[j]</code></li><li>在<code>nums2</code>中找到<code>nums2[j]</code>后边更大的数</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">nextGreaterElement</span><span class="params">(<span class="keyword">int</span> *nums1, <span class="keyword">int</span> nums1Size, <span class="keyword">int</span> *nums2, <span class="keyword">int</span> nums2Size, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *returnSize = nums1Size;</span><br><span class="line">    <span class="keyword">if</span> (nums1Size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> *res = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(nums1Size * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nums1Size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; nums2Size; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] == nums2[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (; j &lt; nums2Size; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums2[j] &gt; nums1[i])</span><br><span class="line">                    &#123;</span><br><span class="line">                        res[i] = nums2[j];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        res[i] = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>628.棒球比赛</title>
    <url>/2020/02/27/LeetCode/628.%E6%A3%92%E7%90%83%E6%AF%94%E8%B5%9B/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>你现在是棒球比赛记录员。<br>给定一个字符串列表，每个字符串可以是以下四种类型之一：</p><ol><li><code>整数</code>（一轮的得分）：直接表示您在本轮中获得的积分数。</li><li><code>&quot;+&quot;</code>（一轮的得分）：表示本轮获得的得分是前两轮<code>有效</code> 回合得分的总和。</li><li><code>&quot;D&quot;</code>（一轮的得分）：表示本轮获得的得分是前一轮<code>有效</code> 回合得分的两倍。</li><li><code>&quot;C&quot;</code>（一个操作，这不是一个回合的分数）：表示您获得的最后一个<code>有效</code> 回合的分数是无效的，应该被移除。</li></ol><p>每一轮的操作都是永久性的，可能会对前一轮和后一轮产生影响。<br>你需要返回你在所有回合中得分的总和。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [&quot;5&quot;,&quot;2&quot;,&quot;C&quot;,&quot;D&quot;,&quot;+&quot;]</span><br><span class="line">输出: 30</span><br><span class="line">解释: </span><br><span class="line">第1轮：你可以得到5分。总和是：5。</span><br><span class="line">第2轮：你可以得到2分。总和是：7。</span><br><span class="line">操作1：第2轮的数据无效。总和是：5。</span><br><span class="line">第3轮：你可以得到10分（第2轮的数据已被删除）。总数是：15。</span><br><span class="line">第4轮：你可以得到5 + 10 &#x3D; 15分。总数是：30。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [&quot;5&quot;,&quot;-2&quot;,&quot;4&quot;,&quot;C&quot;,&quot;D&quot;,&quot;9&quot;,&quot;+&quot;,&quot;+&quot;]</span><br><span class="line">输出: 27</span><br><span class="line">解释: </span><br><span class="line">第1轮：你可以得到5分。总和是：5。</span><br><span class="line">第2轮：你可以得到-2分。总数是：3。</span><br><span class="line">第3轮：你可以得到4分。总和是：7。</span><br><span class="line">操作1：第3轮的数据无效。总数是：3。</span><br><span class="line">第4轮：你可以得到-4分（第三轮的数据已被删除）。总和是：-1。</span><br><span class="line">第5轮：你可以得到9分。总数是：8。</span><br><span class="line">第6轮：你可以得到-4 + 9 &#x3D; 5分。总数是13。</span><br><span class="line">第7轮：你可以得到9 + 5 &#x3D; 14分。总数是27。</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>输入列表的大小将介于1和1000之间。</li><li>列表中的每个整数都将介于-30000和30000之间。</li></ul><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>栈</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol><li>遇到<strong>C</strong>：出栈</li><li>遇到<strong>D</strong>：栈顶元素*2，入栈</li><li>遇到<strong>+</strong>：栈顶两个元素求和，入栈</li><li>遇到数字：入栈</li><li>求栈中所有元素的和</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calPoints</span><span class="params">(<span class="keyword">char</span> **ops, <span class="keyword">int</span> opsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span>[<span class="number">1000</span>], top = <span class="number">-1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; opsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (ops[i][<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'C'</span>:</span><br><span class="line">            top--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">            <span class="built_in">stack</span>[++top] = <span class="built_in">stack</span>[top] * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">            <span class="built_in">stack</span>[++top] = <span class="built_in">stack</span>[top] + <span class="built_in">stack</span>[top - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">stack</span>[++top] = atoi(ops[i]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= top; i++)</span><br><span class="line">        res += <span class="built_in">stack</span>[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、PS"><a href="#三、PS" class="headerlink" title="三、PS"></a>三、PS</h2><ol><li>int atoi(<strong>const char *_Str</strong>)：将String转化为int</li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>844.比较含退格的字符串</title>
    <url>/2020/02/27/LeetCode/844.%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定 <code>S</code> 和 <code>T</code> 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 <code>#</code> 代表退格字符。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：S &#x3D; &quot;ab#c&quot;, T &#x3D; &quot;ad#c&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “ac”。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：S &#x3D; &quot;ab##&quot;, T &#x3D; &quot;c#d#&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “”。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：S &#x3D; &quot;a##c&quot;, T &#x3D; &quot;#a#c&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “c”。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：S &#x3D; &quot;a#c&quot;, T &#x3D; &quot;b&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：S 会变成 “c”，但 T 仍然是 “b”。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= S.length &lt;= 200</code></li><li><code>1 &lt;= T.length &lt;= 200</code></li><li><code>S</code> 和 <code>T</code> 只含有小写字母以及字符 <code>&#39;#&#39;</code>。</li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>栈</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol><li>分别将<code>S</code>和<code>T</code>入栈，遇到<code>#</code>出栈</li><li>比较两个栈内元素</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">backspaceCompare</span><span class="params">(<span class="keyword">char</span> *S, <span class="keyword">char</span> *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">char</span> stack1[<span class="number">200</span>];<span class="keyword">int</span> top1 = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> stack2[<span class="number">200</span>];<span class="keyword">int</span> top2 = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(S); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (S[i] == <span class="string">'#'</span>)</span><br><span class="line">            top1 = top1 == <span class="number">-1</span> ? <span class="number">-1</span> : top1 - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            stack1[++top1] = S[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(T); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (T[i] == <span class="string">'#'</span>)</span><br><span class="line">            top2 = top2 == <span class="number">-1</span> ? <span class="number">-1</span> : top2 - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            stack2[++top2] = T[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (top1 != top2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt;= top1, j &lt;= top2; i++, j++)</span><br><span class="line">        <span class="keyword">if</span> (stack1[i] != stack2[j])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>142.环形链表 II</title>
    <url>/2020/02/26/LeetCode/142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%20II/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p><p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。</p><p><strong>说明：</strong>不允许修改给定的链表。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">输出：tail connects to node index 1</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/26/ag8O41YDvkWQ3oz.png" alt="circularlinkedlist.png"></p><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2], pos &#x3D; 0</span><br><span class="line">输出：tail connects to node index 0</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/26/s1YK7UGb3pVNQw5.png" alt="circularlinkedlist_test2.png"></p><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1], pos &#x3D; -1</span><br><span class="line">输出：no cycle</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/26/unGX9L7f6Ura31d.png" alt="circularlinkedlist_test3.png"></p><p><strong>进阶：</strong><br>你是否可以不用额外空间解决此题？</p><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>双指针</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol><li><p>使用快慢双指针确认链表是否有环</p></li><li><p>如果有环，找到入环节点。</p><p>我有一点搞不太明白的就是，如果有环，那么最终慢指针停下的位置与入环节点的距离==头节点与入环节点的距离。利用这一性质，可以找到入环节点。</p></li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode *<span class="title">detectCycle</span><span class="params">(struct ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">fast</span> = <span class="title">head</span>, *<span class="title">slow</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">int</span> hasCycle = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast)</span><br><span class="line">        &#123;</span><br><span class="line">            hasCycle = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasCycle)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (head != slow)</span><br><span class="line">        &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>155.最小栈</title>
    <url>/2020/02/26/LeetCode/155.%E6%9C%80%E5%B0%8F%E6%A0%88/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p><ul><li>push(x) — 将元素 x 推入栈中。</li><li>pop() — 删除栈顶的元素。</li><li>top() — 获取栈顶元素。</li><li>getMin() — 检索栈中的最小元素。</li></ul><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>用数组实现栈</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol><li>这道题没什么的，很简单</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">10000</span>];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125; MinStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** initialize your data structure here. */</span></span><br><span class="line"></span><br><span class="line"><span class="function">MinStack *<span class="title">minStackCreate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MinStack *st = (MinStack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MinStack));</span><br><span class="line">    st-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> st;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minStackPush</span><span class="params">(MinStack *obj, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj-&gt;top++;</span><br><span class="line">    obj-&gt;data[obj-&gt;top] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minStackPop</span><span class="params">(MinStack *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj-&gt;top--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minStackTop</span><span class="params">(MinStack *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;top != <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> obj-&gt;data[obj-&gt;top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minStackGetMin</span><span class="params">(MinStack *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = obj-&gt;top;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">min</span> = obj-&gt;data[i];</span><br><span class="line">    <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">min</span> = <span class="built_in">min</span> &lt; obj-&gt;data[i] ? <span class="built_in">min</span> : obj-&gt;data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minStackFree</span><span class="params">(MinStack *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = minStackCreate();</span></span><br><span class="line"><span class="comment"> * minStackPush(obj, x);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * minStackPop(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_3 = minStackTop(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_4 = minStackGetMin(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * minStackFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>stack</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title>225.用队列实现栈</title>
    <url>/2020/02/26/LeetCode/225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>使用队列实现栈的下列操作：</p><ul><li>push(x) — 元素 x 入栈</li><li>pop() — 移除栈顶元素</li><li>top() — 获取栈顶元素</li><li>empty() — 返回栈是否为空</li></ul><p><strong>注意:</strong></p><ul><li>你只能使用队列的基本操作— 也就是 <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code>, 和 <code>is empty</code> 这些操作是合法的。</li><li>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li><li>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</li></ul><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol><li>没啥可说的</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">&#125; MyStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"></span><br><span class="line"><span class="function">MyStack *<span class="title">myStackCreate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyStack *st = (MyStack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyStack));</span><br><span class="line">    st-&gt;front = <span class="number">0</span>;</span><br><span class="line">    st-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> st;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Push element x onto stack. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myStackPush</span><span class="params">(MyStack *obj, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj-&gt;rear++;</span><br><span class="line">    obj-&gt;data[obj-&gt;rear] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myStackPop</span><span class="params">(MyStack *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = obj-&gt;data[obj-&gt;rear];</span><br><span class="line">    obj-&gt;rear--;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get the top element. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myStackTop</span><span class="params">(MyStack *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;data[obj-&gt;rear];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myStackEmpty</span><span class="params">(MyStack *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;front == obj-&gt;rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myStackFree</span><span class="params">(MyStack *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack* obj = myStackCreate();</span></span><br><span class="line"><span class="comment"> * myStackPush(obj, x);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_2 = myStackPop(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_3 = myStackTop(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * bool param_4 = myStackEmpty(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * myStackFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>stack</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title>232.用栈实现队列</title>
    <url>/2020/02/26/LeetCode/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>使用栈实现队列的下列操作：</p><ul><li>push(x) — 将一个元素放入队列的尾部。</li><li>pop() — 从队列首部移除元素。</li><li>peek() — 返回队列首部的元素。</li><li>empty() — 返回队列是否为空。</li></ul><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyQueue queue &#x3D; new MyQueue();</span><br><span class="line"></span><br><span class="line">queue.push(1);</span><br><span class="line">queue.push(2);  </span><br><span class="line">queue.peek();  &#x2F;&#x2F; 返回 1</span><br><span class="line">queue.pop();   &#x2F;&#x2F; 返回 1</span><br><span class="line">queue.empty(); &#x2F;&#x2F; 返回 false</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>你只能使用标准的栈操作 — 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li><li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</li></ul><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>辅助栈</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol><li>增加一个辅助栈st2</li><li>每次入栈时，先将st2中的元素压入st1，再将待入栈元素压入st2，最后将st1中的元素全部压入st2</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data1[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> top1;</span><br><span class="line">    <span class="keyword">int</span> data2[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> top2;</span><br><span class="line">&#125; MyQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"></span><br><span class="line"><span class="function">MyQueue *<span class="title">myQueueCreate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyQueue *que = (MyQueue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyQueue));</span><br><span class="line">    que-&gt;top1 = <span class="number">-1</span>;</span><br><span class="line">    que-&gt;top2 = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> que;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myQueuePush</span><span class="params">(MyQueue *obj, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (obj-&gt;top2 != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        obj-&gt;data1[++obj-&gt;top1] = obj-&gt;data2[obj-&gt;top2--];</span><br><span class="line">    &#125;</span><br><span class="line">    obj-&gt;data2[++obj-&gt;top2] = x;</span><br><span class="line">    <span class="keyword">while</span> (obj-&gt;top1 != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        obj-&gt;data2[++obj-&gt;top2] = obj-&gt;data1[obj-&gt;top1--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myQueuePop</span><span class="params">(MyQueue *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = obj-&gt;data2[obj-&gt;top2];</span><br><span class="line">    obj-&gt;top2--;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get the front element. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myQueuePeek</span><span class="params">(MyQueue *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;data2[obj-&gt;top2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myQueueEmpty</span><span class="params">(MyQueue *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;top2 == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myQueueFree</span><span class="params">(MyQueue *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue* obj = myQueueCreate();</span></span><br><span class="line"><span class="comment"> * myQueuePush(obj, x);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_2 = myQueuePop(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_3 = myQueuePeek(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * bool param_4 = myQueueEmpty(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * myQueueFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>stack</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title>143.重排链表</title>
    <url>/2020/02/20/LeetCode/143.%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个单链表 <em>L</em>：<em>L</em>0→<em>L</em>1→…→<em>L**n</em>-1→<em>L</em>n ，<br>将其重新排列后变为： <em>L</em>0→<em>L**n</em>→<em>L</em>1→<em>L**n</em>-1→<em>L</em>2→<em>L**n</em>-2→…</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ol><li>双指针+翻转链表</li><li>使用栈</li></ol><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><p>我使用的是法一：</p><ol><li>使用快慢双指针找到链表中点</li><li>将后半段链表翻转</li><li>拼接两个链表</li></ol><p>简述一下法二：</p><ol><li>先将所有节点进栈</li><li>边遍历，边出栈（出后半段就够了）</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(struct ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next || !head-&gt;next-&gt;next)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//找到中点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">fast</span> = <span class="title">head</span>, *<span class="title">slow</span> = <span class="title">head</span>, *<span class="title">right</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    right = slow-&gt;next;</span><br><span class="line">    slow-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//翻转后半部分</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span> = <span class="title">right</span>, *<span class="title">q</span>, *<span class="title">r</span>;</span></span><br><span class="line">    r = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        q-&gt;next = r;</span><br><span class="line">        r = q;</span><br><span class="line">    &#125;</span><br><span class="line">    right = q;</span><br><span class="line">    <span class="comment">//遍历并连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">l1</span> = <span class="title">head</span>, *<span class="title">l2</span> = <span class="title">right</span>, *<span class="title">l1next</span> = <span class="title">head</span>-&gt;<span class="title">next</span>, *<span class="title">l2next</span> = <span class="title">right</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (l2)</span><br><span class="line">    &#123;</span><br><span class="line">        l2-&gt;next = l1next;</span><br><span class="line">        l1-&gt;next = l2;</span><br><span class="line">        l1 = l1next;</span><br><span class="line">        l1next = l1next-&gt;next;</span><br><span class="line">        l2 = l2next;</span><br><span class="line">        <span class="keyword">if</span> (l2next)</span><br><span class="line">            l2next = l2next-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真是有史以来写的又臭又长的代码！</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>328.奇偶链表</title>
    <url>/2020/02/20/LeetCode/328.%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p><p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL </span><br><span class="line">输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>应当保持奇数节点和偶数节点的相对顺序。</li><li>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</li></ul><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>双指针</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol><li>使用奇偶双指针按序遍历，分别将奇序号节点和偶序号节点连接起来</li><li>将偶序号节点头拼接在奇序号节点后</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode *<span class="title">oddEvenList</span><span class="params">(struct ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">odd</span> = <span class="title">head</span>, *<span class="title">even</span> = <span class="title">head</span>-&gt;<span class="title">next</span>, *<span class="title">headOfEven</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (odd-&gt;next &amp;&amp; even-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        odd-&gt;next = even-&gt;next;</span><br><span class="line">        odd = odd-&gt;next;</span><br><span class="line">        even-&gt;next = odd-&gt;next;</span><br><span class="line">        even = even-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    odd-&gt;next = headOfEven;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这应该是我自己写出的最优美的代码了！</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>445.两数相加 II</title>
    <url>/2020/02/20/LeetCode/445.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%20II/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定两个<strong>非空</strong>链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储单个数字。将这两数相加会返回一个新的链表。</p><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><p><strong>进阶:</strong></p><p>如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出: 7 -&gt; 8 -&gt; 0 -&gt; 7</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>反转链表+逐位相加</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><p>这道题我本来还没思路，结果进阶说：不能翻转怎么办？</p><p>还能怎么办，我不进阶了，哈哈哈哈哈哈，快乐就完事了！😂</p><p>（直接把第2题和第206题的代码粘过来了）</p><p>直接：反转、反转，相加，反转</p><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode *<span class="title">reverseList</span><span class="params">(struct ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span>, *<span class="title">q</span>, *<span class="title">r</span>;</span></span><br><span class="line">    p = head;</span><br><span class="line">    r = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        q-&gt;next = r;</span><br><span class="line">        r = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode *<span class="title">addTwo</span><span class="params">(struct ListNode *l1, struct ListNode *l2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">l3</span> = (<span class="title">struct</span> <span class="title">ListNode</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    l3-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span> = <span class="title">l1</span>, *<span class="title">q</span> = <span class="title">l2</span>, *<span class="title">r</span> = <span class="title">l3</span>;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> || q != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a = p != <span class="literal">NULL</span> ? p-&gt;val : <span class="number">0</span>;</span><br><span class="line">        b = q != <span class="literal">NULL</span> ? q-&gt;val : <span class="number">0</span>;</span><br><span class="line">        c = (a + b + flag) % <span class="number">10</span>;</span><br><span class="line">        flag = (a + b + flag) / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        r-&gt;next = (struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">        r-&gt;val = c;</span><br><span class="line">        r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="literal">NULL</span>)</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">    &#123;</span><br><span class="line">        r-&gt;next = (struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">        r-&gt;val = <span class="number">1</span>;</span><br><span class="line">        r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l3-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">struct ListNode *<span class="title">addTwoNumbers</span><span class="params">(struct ListNode *l1, struct ListNode *l2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l1 = reverseList(l1);</span><br><span class="line">    l2 = reverseList(l2);</span><br><span class="line">    <span class="keyword">return</span> reverseList(addTwo(l1, l2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我太机智了，这是我AC最快的一次，哈哈哈哈哈哈哈！</p><p>先埋下这个坑，日后再来填！😝</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>61.旋转链表</title>
    <url>/2020/02/19/LeetCode/61.%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个链表，旋转链表，将链表每个节点向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k &#x3D; 2</span><br><span class="line">输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL</span><br><span class="line">向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 0-&gt;1-&gt;2-&gt;NULL, k &#x3D; 4</span><br><span class="line">输出: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class="line">向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL</span><br><span class="line">向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL</span><br><span class="line">向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>快慢双指针</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li><p>首先遍历链表，得到其长度，对<code>K</code>取余</p><p>然后使用快慢指针，先让快指针走<code>K</code>步，在让快慢指针一起走</p><p>然后将慢指针后边的链表放在链表头前边即可</p></li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode *<span class="title">rotateRight</span><span class="params">(struct ListNode *head, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span> = <span class="title">head</span>, *<span class="title">q</span>;</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        len++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    k = k % len;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">slow</span> = <span class="title">head</span>, *<span class="title">fast</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    q = slow-&gt;next;</span><br><span class="line">    slow-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    fast-&gt;next = head;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>82.删除排序链表中的重复元素 II</title>
    <url>/2020/02/19/LeetCode/82.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%20II/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 <em>没有重复出现</em> 的数字。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</span><br><span class="line">输出: 1-&gt;2-&gt;5</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;1-&gt;1-&gt;2-&gt;3</span><br><span class="line">输出: 2-&gt;3</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>迭代法</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li><p>1.使用哨兵节点放置在头节点之前；</p><p>2.使用头指针开始遍历链表，用while循环找到不相同的值时，就删除值相同的节点</p><p>3.令pre指向head</p><p>4.循环迭代</p></li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode *<span class="title">deleteDuplicates</span><span class="params">(struct ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">prev</span> = (<span class="title">struct</span> <span class="title">ListNode</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    prev-&gt;next = head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">pre</span> = <span class="title">prev</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span> &amp;&amp; head-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = head-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;val == head-&gt;next-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (head-&gt;val == temp)</span><br><span class="line">            &#123;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">                <span class="keyword">if</span> (!head)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre-&gt;next = head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>86.分隔链表</title>
    <url>/2020/02/19/LeetCode/86.%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个链表和一个特定值 <em>x</em>，对链表进行分隔，使得所有小于 <em>x</em> 的节点都在大于或等于 <em>x</em> 的节点之前。</p><p>你应当保留两个分区中每个节点的初始相对位置。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: head &#x3D; 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x &#x3D; 3</span><br><span class="line">输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。</span><br><span class="line"></span><br><span class="line">你应当保留两个分区中每个节点的初始相对位置。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: head &#x3D; 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x &#x3D; 3</span><br><span class="line">输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>迭代</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol><li>用head指针遍历链表，并申请两个节点；</li><li>比<code>x</code>大的节点接在smaller后边；比<code>x</code>小的节点接在bigger后边；</li><li>吧bigger接在smaller后边。</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode *<span class="title">partition</span><span class="params">(struct ListNode *head, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">smaller</span> = (<span class="title">struct</span> <span class="title">ListNode</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">bigger</span> = (<span class="title">struct</span> <span class="title">ListNode</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span> = <span class="title">smaller</span>, *<span class="title">q</span> = <span class="title">bigger</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;val &lt; x)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next = head;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            q-&gt;next = head;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;next = bigger-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> smaller-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>92.反转链表 II</title>
    <url>/2020/02/19/LeetCode/92.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%20II/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>反转从位置 <em>m</em> 到 <em>n</em> 的链表。请使用一趟扫描完成反转。</p><p><strong>说明:</strong><br>1 ≤ <em>m</em> ≤ <em>n</em> ≤ 链表长度。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m &#x3D; 2, n &#x3D; 4</span><br><span class="line">输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>使用额外数组</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol><li>使用额外的数组将m~n的值存储起来</li><li>再将m~n的节点按照help数组的逆序覆盖</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode *<span class="title">reverseBetween</span><span class="params">(struct ListNode *head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == n)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">int</span> len = n - m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, a = m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> *help = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span> = <span class="title">head</span>, *<span class="title">q</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (a)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        a--;</span><br><span class="line">    &#125;</span><br><span class="line">    q = p;</span><br><span class="line">    <span class="keyword">while</span> (m &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        help[i++] = p-&gt;val;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        m++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        q-&gt;val = help[i];</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>24.两两交换链表中的节点</title>
    <url>/2020/02/18/LeetCode/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>迭代法</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode *<span class="title">swapPairs</span><span class="params">(struct ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">prev</span> = (<span class="title">struct</span> <span class="title">ListNode</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    prev-&gt;next = head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">pre</span> = <span class="title">prev</span>, *<span class="title">p</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (head &amp;&amp; head-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        pre-&gt;next = p;</span><br><span class="line">        head-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = head;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (!head)<span class="comment">//预防空指针</span></span><br><span class="line">            p = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>19.删除链表的倒数第N个节点</title>
    <url>/2020/02/17/LeetCode/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个链表，删除链表的倒数第 <em>n</em> 个节点，并且返回链表的头结点。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n &#x3D; 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>给定的 <em>n</em> 保证是有效的。</p><p><strong>进阶：</strong></p><p>你能尝试使用一趟扫描实现吗？</p><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>双指针</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li>先让快指针跑n步；如果快指针为空，则说明删除头节点，然后快慢指针一起跑到末尾；</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode *<span class="title">removeNthFromEnd</span><span class="params">(struct ListNode *head, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">fast</span> = <span class="title">head</span>, *<span class="title">slow</span> = <span class="title">head</span>, *<span class="title">q</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    q = slow-&gt;next;</span><br><span class="line">    slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>21.合并两个有序链表</title>
    <url>/2020/02/17/LeetCode/21.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>迭代法</li><li>递归法</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li><p>我使用的是迭代法（参考官解）</p><p>首先，定义一个假头节点，便于将两个链表连接起来，并定义一个哨兵指针指向这个假头节点，方便我们返回最后得到的链表；</p><p>然后，开始遍历链表一和链表二，当链表一和链表二都不为空时，pre指针总是指向val较小的节点；</p><p>然后，pre指针始终指向所求的有序链表的最后一个节点；</p><p>最后，将链表一和链表二中仍然不为空的链表接在最后</p></li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode *<span class="title">mergeTwoLists</span><span class="params">(struct ListNode *l1, struct ListNode *l2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">pre</span> = (<span class="title">struct</span> <span class="title">ListNode</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    pre-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">prev</span> = <span class="title">pre</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = pre-&gt;next;<span class="comment">//pre指针始终指向所求的有序链表的最后一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    pre-&gt;next = l1 == <span class="literal">NULL</span> ? l2 : l1;</span><br><span class="line">    <span class="keyword">return</span> prev-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、PS"><a href="#三、PS" class="headerlink" title="三、PS"></a>三、PS</h2><p>递归法不是很理解，详细请参考👉<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode/" target="_blank" rel="noopener">官方答案</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>234.回文链表</title>
    <url>/2020/02/17/LeetCode/234.%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>请判断一个链表是否为回文链表。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>进阶：</strong><br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>遍历+双指针</li><li>快慢指针+翻转链表</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li><p>我使用的是第一种算法，首先，遍历整个链表，将所有元素存到数组中，然后使用头尾指针判断数组即可。</p><p>但是这种算法不是最优的，时空复杂度均为O(n)</p></li></ul><ul><li>第二种算法，首先使用快慢指针找到链表的中点（做过），再将后半段链表翻转，并与前半段链表比较即可。</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(struct ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        len++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        data[m++] = p-&gt;val;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (data[i] == data[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>237.删除链表中的节点</title>
    <url>/2020/02/17/LeetCode/237.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。</p><p>现有一个链表 — head = [4,5,1,9]，它可以表示为:</p><p><img src="https://i.loli.net/2020/02/17/v62DZVMGCynFS4J.png" alt="237_example.png"></p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: head &#x3D; [4,5,1,9], node &#x3D; 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: head &#x3D; [4,5,1,9], node &#x3D; 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>链表至少包含两个节点。</li><li>链表中所有节点的值都是唯一的。</li><li>给定的节点为非末尾节点并且一定是链表中的一个有效节点。</li><li>不要从你的函数中返回任何结果。</li></ul><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>节点赋值（C）</li><li>节点替换（java）</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><p>一开始我以为题出错了，没给链表咋删节点啊，看了讨论之后。嗯……还是自己太年轻了</p><ul><li>节点赋值：直接将<code>*（node-&gt;next）</code>赋值给<code>*node</code>，从而将原本的<code>*node</code>节点覆盖</li><li>节点替换：首先将node下一个节点的值赋值给node，再将node的下一个节点替换为node的下下个节点</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><ul><li><p>C（这绝对是我写过最短的题解🤣）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br></pre></td></tr></table></figure><ul><li>Definition for singly-linked list.</li><li>struct ListNode {</li><li>int val;</li><li>struct ListNode *next;</li><li><p>};<br><em>/<br>void deleteNode(struct ListNode </em>node)<br>{<br><em>node = </em>(node-&gt;next);<br>}</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li></ul></li><li><p>java</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        node.val = node.next.val;</span><br><span class="line">        node.next = node.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、PS"><a href="#三、PS" class="headerlink" title="三、PS"></a>三、PS</h2><p>​ 我尝试过用java的方法，用C实现，但是我发现如果node是倒数第二个节点时，就会堆栈溢出，这肯定是<code>node.next = node.next.next;</code>这句代码出了问题。我觉得可能是官方给的数据最后一个节点的next没有置为<strong>NULL</strong>，导致指针在最后一个节点时，找不到他的下一个节点；而当我们自己写代码时，我认为始终令最后的一个节点的next置为<strong>NULL</strong>，这样才不会总是报错，这是一个良好的习惯。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>876.链表的中间结点</title>
    <url>/2020/02/17/LeetCode/876.%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个带有头结点 <code>head</code> 的非空单链表，返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,4,5]</span><br><span class="line">输出：此列表中的结点 3 (序列化形式：[3,4,5])</span><br><span class="line">返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。</span><br><span class="line">注意，我们返回了一个 ListNode 类型的对象 ans，这样：</span><br><span class="line">ans.val &#x3D; 3, ans.next.val &#x3D; 4, ans.next.next.val &#x3D; 5, 以及 ans.next.next.next &#x3D; NULL.</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,4,5,6]</span><br><span class="line">输出：此列表中的结点 4 (序列化形式：[4,5,6])</span><br><span class="line">由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>给定链表的结点数介于 <code>1</code> 和 <code>100</code> 之间。</li></ul><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>双指针</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li>快慢双指针，快指针每次走两步，慢指针每次走一步</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode *<span class="title">middleNode</span><span class="params">(struct ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">slow</span> = <span class="title">head</span>, *<span class="title">fast</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>908.最小差值 I</title>
    <url>/2020/02/17/LeetCode/908.%E6%9C%80%E5%B0%8F%E5%B7%AE%E5%80%BC%20I/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个整数数组 <code>A</code>，对于每个整数 <code>A[i]</code>，我们可以选择任意 <code>x</code> 满足 <code>-K &lt;= x &lt;= K</code>，并将 <code>x</code> 加到 <code>A[i]</code> 中。</p><p>在此过程之后，我们得到一些数组 <code>B</code>。</p><p>返回 <code>B</code> 的最大值和 <code>B</code> 的最小值之间可能存在的最小差值。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [1], K &#x3D; 0</span><br><span class="line">输出：0</span><br><span class="line">解释：B &#x3D; [1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [0,10], K &#x3D; 2</span><br><span class="line">输出：6</span><br><span class="line">解释：B &#x3D; [2,8]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [1,3,6], K &#x3D; 3</span><br><span class="line">输出：0</span><br><span class="line">解释：B &#x3D; [3,3,3] 或 B &#x3D; [4,4,4]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= A.length &lt;= 10000</code></li><li><code>0 &lt;= A[i] &lt;= 10000</code></li><li><code>0 &lt;= K &lt;= 10000</code></li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>遍历数组</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li>找出数组中的最大值和最小值，所求的数应该是<code>(max - min) &gt; 2 * K ? max - min - 2 * K : 0;</code></li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">smallestRangeI</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> ASize, <span class="keyword">int</span> K)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">min</span> = A[<span class="number">0</span>], <span class="built_in">max</span> = A[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ASize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">min</span> = A[i] &gt; <span class="built_in">min</span> ? <span class="built_in">min</span> : A[i];</span><br><span class="line">        <span class="built_in">max</span> = A[i] &lt; <span class="built_in">max</span> ? <span class="built_in">max</span> : A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">max</span> - <span class="built_in">min</span>) &gt; <span class="number">2</span> * K ? <span class="built_in">max</span> - <span class="built_in">min</span> - <span class="number">2</span> * K : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、PS"><a href="#三、PS" class="headerlink" title="三、PS"></a>三、PS</h2><p>这里再多说两句：</p><p>首先，这道题描述的不是很清楚。</p><p>转述：给定一个整数<code>K</code>，使数组中的数加上<code>[-K, K]</code>的数后的差值最小。</p><p>后来我就想，这其实就是一道<strong>线性规划</strong>的题嘛。</p><p>比如说题目中的测试用例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [0,10], K &#x3D; 2</span><br><span class="line">输出：6</span><br><span class="line">解释：B &#x3D; [2,8]</span><br></pre></td></tr></table></figure><p>就是让散列点都向y=2靠近：</p><p><img src="https://i.loli.net/2020/02/17/H69UhgAYsLxq1WV.png" alt="3DC81E16CD0CEB3016C92FF18EC45BBE.png"></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>2.两数相加</title>
    <url>/2020/02/16/LeetCode/2.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给出两个 <strong>非空</strong> 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 <strong>一位</strong> 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 &#x3D; 807</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li>定义两个指针，分别指向两个链表</li><li>每访问一个节点，申请一个新节点存放该位应该存放的值，并记录进位<code>flag</code></li><li>循环结束后，如果仍有进位，则在申请一个新节点用来存放进位</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode *<span class="title">addTwoNumbers</span><span class="params">(struct ListNode *l1, struct ListNode *l2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">l3</span> = (<span class="title">struct</span> <span class="title">ListNode</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    l3-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span> = <span class="title">l1</span>, *<span class="title">q</span> = <span class="title">l2</span>, *<span class="title">r</span> = <span class="title">l3</span>;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> || q != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a = p != <span class="literal">NULL</span> ? p-&gt;val : <span class="number">0</span>;</span><br><span class="line">        b = q != <span class="literal">NULL</span> ? q-&gt;val : <span class="number">0</span>;</span><br><span class="line">        c = (a + b + flag) % <span class="number">10</span>;</span><br><span class="line">        flag = (a + b + flag) / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        r-&gt;next = (struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">        r-&gt;val = c;</span><br><span class="line">        r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="literal">NULL</span>)</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">    &#123;</span><br><span class="line">        r-&gt;next = (struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">        r-&gt;val = <span class="number">1</span>;</span><br><span class="line">        r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l3-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>1009.十进制整数的反码</title>
    <url>/2020/02/16/LeetCode/1009.%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B4%E6%95%B0%E7%9A%84%E5%8F%8D%E7%A0%81/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>每个非负整数 <code>N</code> 都有其二进制表示。例如， <code>5</code> 可以被表示为二进制 <code>&quot;101&quot;</code>，<code>11</code> 可以用二进制 <code>&quot;1011&quot;</code> 表示，依此类推。注意，除 <code>N = 0</code> 外，任何二进制表示中都不含前导零。</p><p>二进制的反码表示是将每个 <code>1</code> 改为 <code>0</code> 且每个 <code>0</code> 变为 <code>1</code>。例如，二进制数 <code>&quot;101&quot;</code> 的二进制反码为 <code>&quot;010&quot;</code>。</p><p>给定十进制数 <code>N</code>，返回其二进制表示的反码所对应的十进制整数。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：5</span><br><span class="line">输出：2</span><br><span class="line">解释：5 的二进制表示为 &quot;101&quot;，其二进制反码为 &quot;010&quot;，也就是十进制中的 2 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：7</span><br><span class="line">输出：0</span><br><span class="line">解释：7 的二进制表示为 &quot;111&quot;，其二进制反码为 &quot;000&quot;，也就是十进制中的 0 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：10</span><br><span class="line">输出：5</span><br><span class="line">解释：10 的二进制表示为 &quot;1010&quot;，其二进制反码为 &quot;0101&quot;，也就是十进制中的 5 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>0 &lt;= N &lt; 10^9</code></li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>位运算</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol><li><p>5 = “101”, 10 = “1010”</p></li><li><p>将”101”逐位取反：”101” ^ “111” = “010”</p><p>将”1010”逐位取反：”1010” ^ “1111” = “0101”</p></li><li><p>返回取反后的数字</p><p>主要就是怎么找这个：每一位都是1的数</p><p>使用while循环，当num&lt;N时，将num左移一位再加一</p></li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitwiseComplement</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//找每一位都是1的数</span></span><br><span class="line">    <span class="keyword">while</span> (num &lt; N)</span><br><span class="line">    &#123;</span><br><span class="line">        num = (num &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取反</span></span><br><span class="line">    <span class="keyword">return</span> N ^ num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、PS"><a href="#三、PS" class="headerlink" title="三、PS"></a>三、PS</h2><p>完全参考leetcode大佬：<a href="https://leetcode-cn.com/u/suspectx/" target="_blank" rel="noopener">suspectX</a>的答案</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>bit-manipu</tag>
      </tags>
  </entry>
  <entry>
    <title>1013.将数组分成和相等的三个部分</title>
    <url>/2020/02/16/LeetCode/1013.%E5%B0%86%E6%95%B0%E7%BB%84%E5%88%86%E6%88%90%E5%92%8C%E7%9B%B8%E7%AD%89%E7%9A%84%E4%B8%89%E4%B8%AA%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个整数数组 <code>A</code>，只有我们可以将其划分为三个和相等的非空部分时才返回 <code>true</code>，否则返回 <code>false</code>。</p><p>形式上，如果我们可以找出索引 <code>i+1 &lt; j</code> 且满足 <code>(A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... + A[A.length - 1])</code> 就可以将数组三等分。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出：[0,2,1,-6,6,-7,9,1,2,0,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：0 + 2 + 1 &#x3D; -6 + 6 - 7 + 9 + 1 &#x3D; 2 + 0 + 1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[0,2,1,-6,6,7,9,-1,2,0,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,3,6,5,-2,2,5,1,-9,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：3 + 3 &#x3D; 6 &#x3D; 5 - 2 + 2 + 5 + 1 - 9 + 4</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>3 &lt;= A.length &lt;= 50000</code></li><li><code>-10000 &lt;= A[i] &lt;= 10000</code></li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>双指针</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li>双指针向数组中间遍历，如果头尾指针遍历的累加都等于整个数组和的1/3，则判断头尾指针之间元素的累加是否等于数组的1/3即可</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">summ</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; a &lt;= b; a++)</span><br><span class="line">        sum += A[a];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canThreePartsEqualSum</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> ASize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ASize; i++)</span><br><span class="line">        sum += A[i];</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">3</span> != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> oneThird = sum / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>, n = ASize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> qian = <span class="number">0</span>, hou = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (m &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (qian != oneThird)</span><br><span class="line">        &#123;</span><br><span class="line">            qian += A[m];</span><br><span class="line">            m++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (hou != oneThird)</span><br><span class="line">        &#123;</span><br><span class="line">            hou += A[n];</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (summ(A, m, n) == oneThird)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>1137.第 N 个泰波那契数</title>
    <url>/2020/02/16/LeetCode/1137.%E7%AC%AC%20N%20%E4%B8%AA%E6%B3%B0%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>泰波那契序列 Tn 定义如下：</p><p>T0 = 0, T1 = 1, T2 = 1, 且在 n &gt;= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2</p><p>给你整数 <code>n</code>，请返回第 n 个泰波那契数 Tn 的值。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 4</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">T_3 &#x3D; 0 + 1 + 1 &#x3D; 2</span><br><span class="line">T_4 &#x3D; 1 + 1 + 2 &#x3D; 4</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 25</span><br><span class="line">输出：1389537</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 37</code></li><li>答案保证是一个 32 位整数，即 <code>answer &lt;= 2^31 - 1</code>。</li></ul><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>递归</li><li>使用中间变量的递归（栈的思想）</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li>使用中间变量保存之前的值，进行递归（引申：二叉树的前中后序优先遍历，使用栈保存待递归的元素）</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tribonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>, c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = a + b + c;</span><br><span class="line">        a = b;</span><br><span class="line">        b = c;</span><br><span class="line">        c = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">    <span class="comment">//直接递归会超时</span></span><br><span class="line">    <span class="comment">//return tribonacci(n - 1) + tribonacci(n - 2) + tribonacci(n - 3);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>852.山脉数组的峰顶索引</title>
    <url>/2020/02/15/LeetCode/852.%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E7%9A%84%E5%B3%B0%E9%A1%B6%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>我们把符合下列属性的数组 <code>A</code> 称作山脉：</p><ul><li><code>A.length &gt;= 3</code></li><li>存在 <code>0 &lt; i &lt; A.length - 1</code> 使得<code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code></li></ul><p>给定一个确定为山脉的数组，返回任何满足 <code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code> 的 <code>i</code> 的值。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[0,1,0]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[0,2,1,0]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>3 &lt;= A.length &lt;= 10000</code></li><li>0 &lt;= A[i] &lt;= 10^6</li><li>A 是如上定义的山脉</li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>遍历</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li>遍历数组，遇到比前一个元素小的时候停下，返回前边元素的索引</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> ASize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; ASize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] &gt; A[i - <span class="number">1</span>])</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>905.按奇偶排序数组</title>
    <url>/2020/02/15/LeetCode/905.%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个非负整数数组 <code>A</code>，返回一个数组，在该数组中， <code>A</code> 的所有偶数元素之后跟着所有奇数元素。</p><p>你可以返回满足此条件的任何数组作为答案。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,1,2,4]</span><br><span class="line">输出：[2,4,3,1]</span><br><span class="line">输出 [4,2,3,1]，[2,4,1,3] 和 [4,2,1,3] 也会被接受。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= A.length &lt;= 5000</code></li><li><code>0 &lt;= A[i] &lt;= 5000</code></li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>双指针</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li>声明头尾指针向数组中间遍历，<code>i</code>指针指向偶数，<code>j</code>指针指向奇数；当不符合上述情况时，则交换<code>i</code>和<code>j</code>指针所指向的元素。</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">sortArrayByParity</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> ASize, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = ASize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A[j] % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp = A[i];</span><br><span class="line">            A[i] = A[j];</span><br><span class="line">            A[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = ASize;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>dynamic-programming</tag>
      </tags>
  </entry>
  <entry>
    <title>941.有效的山脉数组</title>
    <url>/2020/02/15/LeetCode/941.%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个整数数组 <code>A</code>，如果它是有效的山脉数组就返回 <code>true</code>，否则返回 <code>false</code>。</p><p>让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组：</p><ul><li><p><code>A.length &gt;= 3</code></p></li><li><p>在 <code>0 &lt; i &lt; A.length - 1</code>条件下，存在<code>i</code>使得：</p><ul><li><code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i]</code></li><li><code>A[i] &gt; A[i+1] &gt; ... &gt; A[B.length - 1]</code></li></ul></li></ul><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[2,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,5,5]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[0,3,2,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>0 &lt;= A.length &lt;= 10000</code></li><li><code>0 &lt;= A[i] &lt;= 10000</code></li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>双指针</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li>找到<strong>山峰（最大值）</strong>，使用双指针从数组两端向<strong>山峰</strong>遍历</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validMountainArray</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> ASize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ASize &lt; <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>, indexOfMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (m = <span class="number">0</span>; m &lt; ASize; m++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[m] &gt; <span class="built_in">max</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">max</span> = A[m];</span><br><span class="line">            indexOfMax = m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//排除山峰在头尾的情况</span></span><br><span class="line">    <span class="keyword">if</span> (indexOfMax == <span class="number">0</span> || indexOfMax == ASize - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = ASize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; indexOfMax || j &gt; indexOfMax)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i + <span class="number">1</span>] &gt; A[i] &amp;&amp; i &lt; indexOfMax)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A[j - <span class="number">1</span>] &gt; A[j] &amp;&amp; j &gt; indexOfMax)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、PS"><a href="#三、PS" class="headerlink" title="三、PS"></a>三、PS</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = indexOfMax, j = indexOfMax;</span><br><span class="line"><span class="keyword">while</span> (i &gt; <span class="number">0</span> || j &lt; A.length - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (A[i - <span class="number">1</span>] &lt; A[i] &amp;&amp; i &gt; <span class="number">0</span>)</span><br><span class="line">        i--;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (A[j + <span class="number">1</span>] &lt; A[j] &amp;&amp; j &lt; A.length - <span class="number">1</span>)</span><br><span class="line">        j++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的思想是从中间的<strong>山峰</strong>向两端遍历，一直遇到了莫名其妙的内存溢出问题，后来改用了双指针从两端向<strong>山峰</strong>遍历</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>605.种花问题</title>
    <url>/2020/02/14/LeetCode/605.%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p><p>给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 <strong>n</strong> 。能否在不打破种植规则的情况下种入 <strong>n</strong> 朵花？能则返回True，不能则返回False。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: flowerbed &#x3D; [1,0,0,0,1], n &#x3D; 1</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: flowerbed &#x3D; [1,0,0,0,1], n &#x3D; 2</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>数组内已种好的花不会违反种植规则。</li><li>输入的数组长度范围为 [1, 20000]。</li><li><strong>n</strong> 是非负整数，且不会超过输入数组的大小。</li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li>在数组首尾添加零（去除边界的影响），每三个0可以种一朵花</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="keyword">int</span> *flowerbed, <span class="keyword">int</span> flowerbedSize, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//在首尾添加零</span></span><br><span class="line">    <span class="keyword">int</span> *help = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>((flowerbedSize + <span class="number">2</span>) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    help[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    help[flowerbedSize + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= flowerbedSize; i++)</span><br><span class="line">        help[i] = flowerbed[i - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//每三个零种一朵花</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= flowerbedSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (help[i - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; help[i] == <span class="number">0</span> &amp;&amp; help[i + <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            help[i] = <span class="number">1</span>;<span class="comment">//种花</span></span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>628.三个数的最大乘积</title>
    <url>/2020/02/14/LeetCode/628.%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: 24</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>给定的整型数组长度范围是[3,104]，数组中所有的元素范围是[-1000, 1000]。</li><li>输入的数组中任意三个数的乘积不会超出32位有符号整数的范围。</li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>排序、选数</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol><li>对数组进行升序排序</li><li><p>最大乘积：</p><ol><li>全是正数：选三个最大的</li><li>全是负数：还选三个最大的</li><li>有正有负：<ul><li>[-4, 0, 2, 3] : 选三个最大的</li><li>[-4, -3, 1, 2] : 选两个负的一个正的</li></ul></li></ol></li><li><p>所以最大乘积只有两种情况：</p><ul><li>第一个负数的绝对值比较小倒着选三个数</li><li>正着选两个数，倒着选一个数</li></ul></li><li><p>选两个数中的较大数</p></li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//升序</span></span><br><span class="line">    <span class="keyword">return</span> (*(<span class="keyword">int</span> *)a - *(<span class="keyword">int</span> *)b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximumProduct</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>] * nums[<span class="number">1</span>] * nums[<span class="number">2</span>];</span><br><span class="line">    qsort(nums, numsSize, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), compare1);</span><br><span class="line">    <span class="keyword">int</span> max1 = nums[numsSize - <span class="number">1</span>] * nums[numsSize - <span class="number">2</span>] * nums[numsSize - <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span> max2 = nums[<span class="number">0</span>] * nums[<span class="number">1</span>] * nums[numsSize - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> max1 &gt; max2 ? max1 : max2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>674.最长连续递增序列</title>
    <url>/2020/02/14/LeetCode/674.%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个未经排序的整数数组，找到最长且<strong>连续</strong>的的递增序列。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,4,7]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 最长连续递增序列是 [1,3,5], 长度为3。</span><br><span class="line">尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,2,2,2,2]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 最长连续递增序列是 [2], 长度为1。</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>数组长度不会超过10000。</p><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>简单遍历</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li>for循环遍历整个数组，用中间变量temp记录每次的连续长度，用res与temp比较作为最大值</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">1</span>, res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            temp++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            res = res &gt; temp ? res : temp;</span><br><span class="line">            temp = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res = res &gt; temp ? res : temp;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>717.1比特与2比特字符</title>
    <url>/2020/02/14/LeetCode/717.1%E6%AF%94%E7%89%B9%E4%B8%8E2%E6%AF%94%E7%89%B9%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>有两种特殊字符。第一种字符可以用一比特<code>0</code>来表示。第二种字符可以用两比特(<code>10</code> 或 <code>11</code>)来表示。</p><p>现给一个由若干比特组成的字符串。问最后一个字符是否必定为一个一比特字符。给定的字符串总是由0结束。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">bits &#x3D; [1, 0, 0]</span><br><span class="line">输出: True</span><br><span class="line">解释: </span><br><span class="line">唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是一比特字符。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">bits &#x3D; [1, 1, 1, 0]</span><br><span class="line">输出: False</span><br><span class="line">解释: </span><br><span class="line">唯一的编码方式是两比特字符和两比特字符。所以最后一个字符不是一比特字符。</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><code>1 &lt;= len(bits) &lt;= 1000</code>.</li><li><code>bits[i]</code> 总是<code>0</code> 或 <code>1</code>.</li></ul><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>模拟栈</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li>把数组想象成一个栈底在数组尾部的栈，从头开始出栈，遇到以下两种情况出栈：<ul><li>1后边是1或0，出栈</li><li>单独一个0，出栈</li></ul></li><li>如果栈底还剩一个元素，那么返回true，否则返回false。</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isOneBitCharacter</span><span class="params">(<span class="keyword">int</span> *bits, <span class="keyword">int</span> bitsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bitsSize == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; bitsSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (bits[i] == <span class="number">1</span> &amp;&amp; (bits[i + <span class="number">1</span>] == <span class="number">1</span> || bits[i + <span class="number">1</span>] == <span class="number">0</span>))</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (bits[i] == <span class="number">0</span> &amp;&amp; i != bitsSize - <span class="number">1</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span> (i == bitsSize - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>724.寻找数组的中心索引</title>
    <url>/2020/02/14/LeetCode/724.%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个整数类型的数组 <code>nums</code>，请编写一个能够返回数组<strong>“中心索引”</strong>的方法。</p><p>我们是这样定义数组<strong>中心索引</strong>的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。</p><p>如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">nums &#x3D; [1, 7, 3, 6, 5, 6]</span><br><span class="line">输出: 3</span><br><span class="line">解释: </span><br><span class="line">索引3 (nums[3] &#x3D; 6) 的左侧数之和(1 + 7 + 3 &#x3D; 11)，与右侧数之和(5 + 6 &#x3D; 11)相等。</span><br><span class="line">同时, 3 也是第一个符合要求的中心索引。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">nums &#x3D; [1, 2, 3]</span><br><span class="line">输出: -1</span><br><span class="line">解释: </span><br><span class="line">数组中不存在满足此条件的中心索引。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li><code>nums</code> 的长度范围为 <code>[0, 10000]</code>。</li><li>任何一个 <code>nums[i]</code> 将会是一个范围在 <code>[-1000, 1000]</code>的整数。</li></ul><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>前缀和（参考官解）</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li><code>leftSum == sum - leftSum - nums[i]</code>时，就找到了最左边的中心索引</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, leftSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftSum == sum - nums[i] - leftSum)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        leftSum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>747.至少是其他数字两倍的最大数</title>
    <url>/2020/02/14/LeetCode/747.%E8%87%B3%E5%B0%91%E6%98%AF%E5%85%B6%E4%BB%96%E6%95%B0%E5%AD%97%E4%B8%A4%E5%80%8D%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>在一个给定的数组<code>nums</code>中，总是存在一个最大元素 。</p><p>查找数组中的最大元素是否至少是数组中每个其他数字的两倍。</p><p>如果是，则返回最大元素的索引，否则返回-1。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [3, 6, 1, 0]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 6是最大的整数, 对于数组中的其他整数,</span><br><span class="line">6大于数组中其他元素的两倍。6的索引是1, 所以我们返回1.</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1, 2, 3, 4]</span><br><span class="line">输出: -1</span><br><span class="line">解释: 4没有超过3的两倍大, 所以我们返回 -1.</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ol><li><code>nums</code> 的长度范围在<code>[1, 50]</code>.</li><li>每个 <code>nums[i]</code> 的整数范围在 <code>[0, 100]</code>.</li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>数组遍历</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li>找到最大值，并记录其索引，如果<code>2 * nums[i] &gt; max</code>，返回-1；否则，返回最大值的索引</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dominantIndex</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = nums[<span class="number">0</span>], maxIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="built_in">max</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">max</span> = nums[i];</span><br><span class="line">            maxIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == maxIndex)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * nums[i] &gt; <span class="built_in">max</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>dynamic-programming</tag>
      </tags>
  </entry>
  <entry>
    <title>561.数组拆分</title>
    <url>/2020/02/13/LeetCode/561.%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86%E2%85%A0/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定长度为 <strong>2n</strong> 的数组, 你的任务是将这些数分成 <strong>n</strong> 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,4,3,2]</span><br><span class="line"></span><br><span class="line">输出: 4</span><br><span class="line">解释: n 等于 2, 最大总和为 4 &#x3D; min(1, 2) + min(3, 4).</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ol><li><strong>n</strong> 是正整数,范围在 [1, 10000].</li><li>数组中的元素范围在 [-10000, 10000].</li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><ol><li><p>算法描述</p><ul><li>排序+最小值累加</li></ul></li><li><p>个人分析</p><ul><li>首先将给定数组排序，然后每两位选择较小值进行累加</li></ul></li><li><p>代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//升序</span></span><br><span class="line">    <span class="keyword">return</span> (*(<span class="keyword">int</span> *)a - *(<span class="keyword">int</span> *)b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sizeOfElem = <span class="keyword">sizeof</span>(nums[<span class="number">0</span>]);</span><br><span class="line">    qsort(nums, numsSize, sizeOfElem, compare1);</span><br><span class="line">    <span class="keyword">int</span> i, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i += <span class="number">2</span>)</span><br><span class="line">        res += <span class="built_in">min</span>(nums[i], nums[i + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>581.最短无序连续子数组</title>
    <url>/2020/02/13/LeetCode/581.%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个整数数组，你需要寻找一个<strong>连续的子数组</strong>，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p><p>你找到的子数组应是<strong>最短</strong>的，请输出它的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2, 6, 4, 8, 10, 9, 15]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。</span><br></pre></td></tr></table></figure><p><strong>说明 :</strong></p><ol><li>输入的数组长度范围在 [1, 10,000]。</li><li>输入的数组可能包含<strong>重复</strong>元素 ，所以<strong>升序</strong>的意思是<strong>&lt;=。</strong></li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>排序+逐位异或+双指针扫描</li><li>双指针</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li>首先利用快速排序数组进行升序排序，然后与原数组逐位异或，位置没变的元素就会变成0，然后利用头尾指针扫描，每遇到0，就将数组长度减一，头尾指针都遇到不为零的数时，停止扫描</li><li>总结时发现，只利用双指针就行了，头尾指针向中间扫描时，头指针扫描的数应该是越来越大的，而尾指针扫描的数应该是越来越小的，当头指针的后一个数比当前位置的数小时，头指针就应该停下了，尾指针亦然；当头尾指针相遇，则表明这是一个完全有序的数组，所以返回0.</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">compare1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//升序</span></span><br><span class="line">    <span class="keyword">return</span> (*(<span class="keyword">int</span> *)a - *(<span class="keyword">int</span> *)b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> *help = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(numsSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">        help[i] = nums[i];</span><br><span class="line">    qsort(nums, numsSize, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), compare1);</span><br><span class="line">    <span class="comment">//逐位异或</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">        nums[i] ^= help[i];</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>, n = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = numsSize;</span><br><span class="line">    <span class="comment">//双指针</span></span><br><span class="line">    <span class="keyword">while</span> ((nums[m] == <span class="number">0</span> || nums[n] == <span class="number">0</span>) &amp;&amp; m &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[m] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res--;</span><br><span class="line">            m++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[n] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res--;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) <span class="comment">//如果队列有序，res=-1，那么应该返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>448.找到所有数组中消失的数字</title>
    <url>/2020/02/12/LeetCode/448.%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p><strong>Tags：</strong></p><p>给定一个范围在 1 ≤ a[i] ≤ <em>n</em> ( <em>n</em> = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p><p>找到所有在 [1, <em>n</em>] 范围之间没有出现在数组中的数字。</p><p>您能在不使用额外空间且时间复杂度为<em>O(n)</em>的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>类似标记数组</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li><p>将数组中的元素对应的数组值置为负数，然后遍历数组中大于零的元素，其索引就是消失的数字</p><p>例如：</p><ul><li>输入：[ 4, 3, 2, 7, 8, 2, 3, 1]</li><li>输出：[-4,-3,-2,-7,<code>8</code>,<code>2</code>,-3,-1]</li></ul></li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *res = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(numsSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">        nums[<span class="built_in">abs</span>(nums[i]) - <span class="number">1</span>] = -<span class="built_in">abs</span>(nums[<span class="built_in">abs</span>(nums[i]) - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">            res[j++] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = j;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>414.第三大的数</title>
    <url>/2020/02/11/LeetCode/414.%E7%AC%AC%E4%B8%89%E5%A4%A7%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3, 2, 1]</span><br><span class="line"></span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">解释: 第三大的数是 1.</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1, 2]</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释: 第三大的数不存在, 所以返回最大的数 2 .</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2, 2, 3, 1]</span><br><span class="line"></span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">解释: 注意，要求返回第三大的数，是指第三大且唯一出现的数。</span><br><span class="line">存在两个值为2的数，它们都排第二。</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>窗口滑动</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li>初始化一个长度为三的滑动窗口，用三个变量实现。遍历数组时，使用数组中的元素更新窗口中的值，使用<code>flag</code>标记窗口中元素的更新次数，如果flag&gt;=3，则说明窗口中的元素被全部更新，即返回窗口中的最小值；否则，falg只更新了1次或2次，即第三大的数不存在, 所以返回最大的数。</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">thirdMax</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>] &gt;= nums[<span class="number">1</span>] ? nums[<span class="number">0</span>] : nums[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i, flag = <span class="number">0</span>, intmin = <span class="number">1</span>;<span class="comment">//intmin是为了排除掉数组中的INT_MIN</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">min</span> = -__INT_MAX__ - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = -__INT_MAX__ - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = -__INT_MAX__ - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == -__INT_MAX__ - <span class="number">1</span> &amp;&amp; intmin)</span><br><span class="line">        &#123;</span><br><span class="line">            flag++;</span><br><span class="line">            intmin = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="built_in">max</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag++;</span><br><span class="line">            <span class="built_in">min</span> = mid;</span><br><span class="line">            mid = <span class="built_in">max</span>;</span><br><span class="line">            <span class="built_in">max</span> = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; mid &amp;&amp; nums[i] &lt; <span class="built_in">max</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag++;</span><br><span class="line">            <span class="built_in">min</span> = mid;</span><br><span class="line">            mid = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; <span class="built_in">min</span> &amp;&amp; nums[i] &lt; mid)</span><br><span class="line">        &#123;</span><br><span class="line">            flag++;</span><br><span class="line">            <span class="built_in">min</span> = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag &gt;= <span class="number">3</span> ? <span class="built_in">min</span> : <span class="built_in">max</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>287.寻找重复数</title>
    <url>/2020/02/10/LeetCode/287.%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个包含 <em>n</em> + 1 个整数的数组 <em>nums</em>，其数字都在 1 到 <em>n</em> 之间（包括 1 和 <em>n</em>），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,4,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,1,3,4,2]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ol><li><strong>不能</strong>更改原数组（假设数组是只读的）。</li><li>只能使用额外的 <em>O</em>(1) 的空间。</li><li>时间复杂度小于 <em>O</em>(<em>n</em>2) 。</li><li>数组中只有一个重复的数字，但它可能不止重复出现一次。</li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>快指针&amp;慢指针</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li><p>将此题抽象成环型链表问题（见141题、142题）</p><p>那么如何在数组中模拟快慢指针呢？</p><p>看了题解：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fast = nums[nums[fast]];</span><br><span class="line">slow = nums[slow];</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slow &#x3D; 0;fast &#x3D; 0;</span><br><span class="line">nums[] &#x3D; [3,1,3,4,2]</span><br><span class="line">nums[slow] &#x3D; [3,4,2,3]</span><br><span class="line">nums[nums[fast]] &#x3D; [4,3,2,4]</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) <span class="comment">//一定有相同元素，所以死循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        fast = nums[nums[fast]]; <span class="comment">//快指针</span></span><br><span class="line">        slow = nums[slow];       <span class="comment">//慢指针</span></span><br><span class="line">        <span class="keyword">if</span> (slow == fast)        <span class="comment">//快慢指针相遇，开始寻找成环入口，即为重复的数</span></span><br><span class="line">        &#123;</span><br><span class="line">            fast = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">/*寻找环的入口</span></span><br><span class="line"><span class="comment">                nums[slow] == nums[fast]时，快慢指针指向的元素相等，即为所求元素</span></span><br><span class="line"><span class="comment">                快慢指针指向的元素不等时，则继续寻找*/</span></span><br><span class="line">            <span class="keyword">while</span> (nums[slow] != nums[fast])</span><br><span class="line">            &#123;</span><br><span class="line">                fast = nums[fast];</span><br><span class="line">                slow = nums[slow];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> nums[slow];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、PS"><a href="#三、PS" class="headerlink" title="三、PS"></a>三、PS</h2><p>这是一道中等难度的题目，我还不是很理解。完全参考了作者<a href="https://leetcode-cn.com/u/seu_fidget/" target="_blank" rel="noopener">SEU.FidGet</a>的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        快慢指针思想, fast 和 slow 是指针, nums[slow] 表示取指针对应的元素</span></span><br><span class="line"><span class="comment">        注意 nums 数组中的数字都是在 1 到 n 之间的(在数组中进行游走不会越界),</span></span><br><span class="line"><span class="comment">        因为有重复数字的出现, 所以这个游走必然是成环的, 环的入口就是重复的元素, </span></span><br><span class="line"><span class="comment">        即按照寻找链表环入口的思路来做</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">0</span>, slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            <span class="keyword">if</span>(slow == fast) &#123;</span><br><span class="line">                fast = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(nums[slow] != nums[fast]) &#123;</span><br><span class="line">                    fast = nums[fast];</span><br><span class="line">                    slow = nums[slow];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> nums[slow];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>two-pointers</tag>
        <tag>binary-search</tag>
      </tags>
  </entry>
  <entry>
    <title>268.缺失数字</title>
    <url>/2020/02/09/LeetCode/268.%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个包含 <code>0, 1, 2, ..., n</code> 中 <em>n</em> 个数的序列，找出 0 .. <em>n</em> 中没有出现在序列中的那个数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,0,1]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [9,6,4,2,3,5,7,0,1]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure><p><strong>说明:</strong><br>你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现?</p><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>标记数组</li><li>异或</li><li>求和做差</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li>标记数组：申请一个<strong>n+1</strong>长度的标记数组，用这个数组记录，最后遍历标记数组即可</li><li>异或：按for循环中的i异或（大佬的方法）</li><li>求和做差：先利用数学法求出前n项和，再减去数组中的元素，剩下的差就是答案</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>((numsSize + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[nums[i]] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i] != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>bit-manipu</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>283.移动零</title>
    <url>/2020/02/09/LeetCode/283.%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><p><strong>说明</strong>:</p><ol><li>必须在原数组上操作，不能拷贝额外的数组。</li><li>尽量减少操作次数。</li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>双指针法</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li>指针<code>i</code>用于寻找零，指针<code>j</code>用于寻找指针<code>i</code>后边不为零的数，并令<code>nums[i]=nums[j]</code>，然后再令<code>nums[j]=0</code>，遍历整个数组。</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; numsSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; numsSize)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    nums[i] = nums[j];</span><br><span class="line">                    nums[j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>189.旋转数组</title>
    <url>/2020/02/08/LeetCode/189.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个数组，将数组中的元素向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,5,6,7] 和 k &#x3D; 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [-1,-100,3,99] 和 k &#x3D; 2</span><br><span class="line">输出: [3,99,-1,-100]</span><br><span class="line">解释: </span><br><span class="line">向右旋转 1 步: [99,-1,-100,3]</span><br><span class="line">向右旋转 2 步: [3,99,-1,-100]</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</li><li>要求使用空间复杂度为 O(1) 的 <strong>原地</strong> 算法。</li></ul><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>暴力法：两个for循环嵌套，每次将数组中的元素向后移动一位</li><li>三次翻转数组</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li>暴力法挺好理解就是超时</li><li>三次翻转：<ul><li>第一次：将整个数组翻转</li><li>第二次：将[0,k-1]的数组翻转</li><li>第三次：将[k,n-1]的数组翻转</li></ul></li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        temp = nums[low];</span><br><span class="line">        nums[low] = nums[high];</span><br><span class="line">        nums[high] = temp;</span><br><span class="line">        low++;</span><br><span class="line">        high--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    k = k % numsSize;</span><br><span class="line">    reverse(nums, <span class="number">0</span>, numsSize - <span class="number">1</span>);</span><br><span class="line">    reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">    reverse(nums, k, numsSize - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、PS："><a href="#三、PS：" class="headerlink" title="三、PS："></a>三、PS：</h2><p>暴力法的超时代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//超时了</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (numsSize &lt; <span class="number">2</span>)</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       <span class="keyword">int</span> minK = k % numsSize;</span><br><span class="line">       <span class="keyword">int</span> i, temp, j;</span><br><span class="line">       <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; minK; j++)</span><br><span class="line">       &#123;</span><br><span class="line">           temp = nums[numsSize - <span class="number">1</span>];</span><br><span class="line">           <span class="keyword">for</span> (i = numsSize - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">           &#123;</span><br><span class="line">               nums[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">           &#125;</span><br><span class="line">           nums[<span class="number">0</span>] = temp;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>217.存在重复元素</title>
    <url>/2020/02/08/LeetCode/217.%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个整数数组，判断是否存在重复元素。</p><p>如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,1,1,3,3,4,3,2,4,2]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1. 算法描述"></a>1. 算法描述</h3><ul><li>暴力法：两个for循环嵌套遍历</li><li>使用qsort()排序，再逐位检查</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2. 个人分析"></a>2. 个人分析</h3><ul><li>暴力法超时</li><li>qsort()最坏复杂度：O(nlogn)</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*(<span class="keyword">int</span> *)a - *(<span class="keyword">int</span> *)b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> sizeOfElem = <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    qsort(nums, numsSize, sizeOfElem, compare);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、PS："><a href="#三、PS：" class="headerlink" title="三、PS："></a>三、PS：</h2><ul><li><p>暴力法超时</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; numsSize; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>qsort()快速排序：</p><p><code>void qsort(void *_Base, size_t _NumOfElements, size_t _SizeOfElements, int (*_PtFuncCompare)(const void *, const void *))</code></p><ul><li>_Base：待排序的数组</li><li>_NumOfElements：数组中元素的个数</li><li>_SizeOfElements：数组中元素的大小</li><li>(<em>_PtFuncCompare)(const void </em>, const void *))：比较指针</li></ul></li><li><p>qsort()函数实例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="comment">//升序</span></span><br><span class="line">    <span class="keyword">return</span> (*(<span class="keyword">int</span> *)a - *(<span class="keyword">int</span> *)b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="comment">//降序</span></span><br><span class="line">    <span class="keyword">return</span> (*(<span class="keyword">int</span> *)b - *(<span class="keyword">int</span> *)a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> numsOfArray = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> sizeOfElem = <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">    qsort(<span class="built_in">array</span>, numsOfArray, sizeOfElem, compare1);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsOfArray; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, <span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>hash-table</tag>
      </tags>
  </entry>
  <entry>
    <title>219.存在重复元素Ⅱ</title>
    <url>/2020/02/08/LeetCode/219.%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E2%85%A1/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个整数数组和一个整数 <em>k</em>，判断数组中是否存在两个不同的索引 <em>i</em> 和 <em>j</em>，使得 <strong>nums [i] = nums [j]</strong>，并且 <em>i</em> 和 <em>j</em> 的差的绝对值最大为 <em>k</em>。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,3,1], k &#x3D; 3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,0,1,1], k &#x3D; 1</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,3,1,2,3], k &#x3D; 2</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>暴力：for()循环嵌套+if (nums[i] == nums[j] &amp;&amp; j - i &lt;= k)判断</li><li>屈辱😭：面向测试用例编程</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li>暴力：又是妥妥的超时！！！</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">35000</span>) <span class="comment">//留下了屈辱的眼泪</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; numsSize; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[j] &amp;&amp; j - i &lt;= k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、PS"><a href="#三、PS" class="headerlink" title="三、PS"></a>三、PS</h2><p>超时代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; numsSize; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[j] &amp;&amp; j - i &lt;= k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>hash-table</tag>
      </tags>
  </entry>
  <entry>
    <title>204.计数质数</title>
    <url>/2020/02/07/LeetCode/204.%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0/</url>
    <content><![CDATA[<!-- build time:Fri Mar 27 2020 19:38:39 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>统计所有小于非负整数 n 的质数的数量。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: 10</span><br><span class="line">输出: 4</span><br><span class="line">解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><blockquote><p><a href="https://baike.baidu.com/item/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC%E7%AD%9B%E6%B3%95/374984?fr=aladdin#1" target="_blank" rel="noopener">埃拉托斯特尼筛法</a></p><p>​ 埃拉托斯特尼筛法，简称埃氏筛或爱氏筛，是一种由希腊数学家埃拉托斯特尼所提出的一种简单检定素数的算法。要得到自然数n以内的全部素数，必须把不大于根号n的所有素数的倍数剔除，剩下的就是素数。</p></blockquote><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><p>​ 声明一个长度为n的数组，索引<code>i</code>作为待判断的数，索引中的值<code>isPrime[i]</code>作为该索引是否为素数的flag，使用for循环开始逐一判断数组索引<code>i</code>是否为素数，如果是素数，则将其n以内的所有倍数过滤，再判断下一个索引<code>i</code>。</p><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//爱式筛法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *isPrime = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    <span class="built_in">memset</span>(isPrime, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);<span class="comment">//初始化isPrime为0</span></span><br><span class="line">    <span class="keyword">int</span> i, j, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">for</span> (j = i + i; j &lt; n; j += i)</span><br><span class="line">            &#123; <span class="comment">//筛去i的倍数</span></span><br><span class="line">                isPrime[j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、PS"><a href="#三、PS" class="headerlink" title="三、PS:"></a>三、PS:</h2><p><code>void *memset(void *_Dst, int _Val, size_t _Size)</code></p><ul><li><p>memset()函数为初始化一块连续的内存空间，<strong>按照字节赋值</strong></p></li><li><p>_Dst：指针变量（起始位置）</p></li><li>_Val：初始化的值（一般为-1或0）</li><li>_Size：内存长度</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>math</tag>
        <tag>hash-table</tag>
      </tags>
  </entry>
</search>
