<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>剑指 Offer 30. 包含min函数的栈</title>
    <url>/20220115c833387c/</url>
    <content><![CDATA[<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.min();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.min();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ol>
<li>各函数的调用总次数不超过 20000 次</li>
</ol>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>使用一个<code>minSt</code>辅助栈来存放较小的值</p>
<p>每次入栈时,如果要入栈的数<strong>小于等于</strong>辅助栈顶的数,就把待入栈的数也压入辅助栈中,辅助栈就用来返回当前的最小值.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minSt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        minSt = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">        <span class="keyword">if</span>(minSt.empty() || x &lt;= minSt.peek())&#123; </span><br><span class="line">            <span class="comment">// 需要加 ‘=’, 否则“0-1-0”这样的序列中, 辅助栈minSt中只会有1个‘0’,</span></span><br><span class="line">            <span class="comment">// 这样当stack中出栈时, minSt中可能就没元素了</span></span><br><span class="line">            minSt.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if(stack.pop() == minSt.peek())&#123; // == 比的是地址,应该用equals</span></span><br><span class="line">        <span class="keyword">if</span>(stack.pop().equals(minSt.peek()))&#123;</span><br><span class="line">            minSt.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minSt.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.min();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 09. 用两个栈实现队列</title>
    <url>/202201156fda8efa/</url>
    <content><![CDATA[<p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
<p>示例 1：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure><br>提示：</p>
<ul>
<li><code>1 &lt;= values &lt;= 10000</code></li>
<li><code>最多会对 appendTail、deleteHead 进行 10000 次调用</code></li>
</ul>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ol>
<li>直接往<strong>stack1</strong>里压栈,出栈的时候从<strong>stack2</strong>里出;</li>
<li><strong>stack2</strong>里出没了,再把<strong>stack1</strong>里的放到<strong>stack2</strong>里,再接着出</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack1;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        stack1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stack2.isEmpty() ? -<span class="number">1</span> : stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj.appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>实习面试经历</title>
    <url>/2022011264cfabb6/</url>
    <content><![CDATA[<h1 id="北京航天x院xxx所"><a href="#北京航天x院xxx所" class="headerlink" title="北京航天x院xxx所"></a>北京航天x院xxx所</h1><p>一面(全都是场景题):</p>
<ol>
<li>专家抽取问题. 专家有以下属性: 名字、单位、专业. 每个专家会有3个专业.有两种抽取条件:1.按单位抽取 2.按专业抽取. 问题是: 一共有4000个专家, 抽五个, 需满足以下条件:<ul>
<li>2个专家来自A单位, 2个专家来自B单位;</li>
<li>2个专家是 x 专业, 2个专家是 y 专业, 1个专家是 z 专业</li>
</ul>
</li>
<li>数据库问题. 一个文件有标题、持有人、持有时间. 每次将文件进行流转, 持有人都会变化, 给定一个文件id, 找到该文件的当下持有人.</li>
</ol>
<h1 id="北京-iReadyIT"><a href="#北京-iReadyIT" class="headerlink" title="北京 iReadyIT"></a>北京 iReadyIT</h1><p>一面·技术面(基本都是Java基础题)<br>忘了记录了</p>
<h1 id="北京熠智科技有限公司"><a href="#北京熠智科技有限公司" class="headerlink" title="北京熠智科技有限公司"></a>北京熠智科技有限公司</h1><p>一面·技术面</p>
<p>java基础(忘了记录了)</p>
<p>手撕二分查找</p>
<ul>
<li>递归</li>
<li>循环</li>
</ul>
<p>哪种更好, 时间复杂度? 空间复杂度?</p>
<p>二面·技术面</p>
<ol>
<li>自我介绍, 介绍一下你的项目经历、比赛经历</li>
<li>多线程有了解吗</li>
<li>Java的JVM内存模型</li>
<li>垃圾回收算法</li>
<li>Java与其他开发语言的对比</li>
<li>Java什么时候会导致内存泄漏问题</li>
<li>设计模式了解吗? 有用到过设计模式吗</li>
<li>排序算法中O(n^2)的排序算法有哪些? 稳定性? 插入排序和冒泡排序, 在实际场景中相对来说哪个效率更高?</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>MyBatis的简单使用</title>
    <url>/202110024658a061/</url>
    <content><![CDATA[<h1 id="传统JDBC"><a href="#传统JDBC" class="headerlink" title="传统JDBC"></a>传统JDBC</h1><p>在JSP/Servlet时代,进行数据持久化的方式采用JDBC,这是一种比较原生的数据库连接方式,我深深记得,在本科的Android课程设计中,还使用JDBC来连接数据库,JDBC使用起来还算方便,引入jar包后,立马就可以编写代码了,但它也有很多<strong>缺点</strong>:</p>
<ol>
<li>大量的模版代码</li>
<li>MySQL语句<strong>硬编码</strong>,直接写在了Java代码中(需要更改SQL语句时,整个项目都得重新编译打包)</li>
<li>每次操作数据库,都要建立连接,操作数据,然后断开连接,开销很大</li>
</ol>
<h2 id="JDBC-Template"><a href="#JDBC-Template" class="headerlink" title="JDBC Template"></a>JDBC Template</h2><p>解决了大量的模版代码问题,将模版代码进行了封装,使得后期维护代码更加方便了,但因为还是基于JDBC,所以仍然没有解决SQL语句硬编码和性能的问题.</p>
<h1 id="MyBatis时代"><a href="#MyBatis时代" class="headerlink" title="MyBatis时代"></a>MyBatis时代</h1><p>MyBatis采用XML或注解的方式进行显式配置,XML可以解决JDBC的SQL语句硬编码的问题. 并且MyBatis支持生命时数据缓存,可以将数据库中获得的数据存储在高速缓存中,当下次再进行查询时,就可以直接从缓存中获取,这样也在一定程度上优化了JDBC的性能问题.MyBatis已经成为Web开发中ORM的经典.</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>通过接口调用相应的方法,不需要实现接口,也不需要在实现类中使用SqlSession间接调用.动态代理的方式被广泛使用,因此我主要记录一下这个方式,在此之后还诞生了更为方便的MyBatis Generator,但掌握了较为基础的动态代理方式,学习MyBatis Generator也自然不在话下.</p>
<p>以下记录动态代理的使用:</p>
<h3 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h3><p>使用Spring Initializr构建一个Spring Boot项目,并添加以下依赖:<br><a href="https://imgtu.com/i/4xT6BT"><img src="https://z3.ax1x.com/2021/10/06/4xT6BT.png" alt="4xT6BT.png" style="zoom:50%;" /></a></p>
<p>添加以下文件夹:<br><a href="https://imgtu.com/i/4x7TRs"><img src="https://z3.ax1x.com/2021/10/06/4x7TRs.png" alt="4x7TRs.png" style="zoom:50%;" /></a></p>
<p>运行以下SQL语句以测试:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET NAMES utf8mb4;</span><br><span class="line">SET FOREIGN_KEY_CHECKS &#x3D; 0;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Table structure for country</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP TABLE IF EXISTS &#96;country&#96;;</span><br><span class="line">CREATE TABLE &#96;country&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;countryname&#96; varchar(255) DEFAULT NULL,</span><br><span class="line">  &#96;countrycode&#96; varchar(255) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;6 DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Records of country</span><br><span class="line">-- ----------------------------</span><br><span class="line">BEGIN;</span><br><span class="line">INSERT INTO &#96;country&#96; VALUES (1, &#39;中国&#39;, &#39;CN&#39;);</span><br><span class="line">INSERT INTO &#96;country&#96; VALUES (2, &#39;美国&#39;, &#39;US&#39;);</span><br><span class="line">INSERT INTO &#96;country&#96; VALUES (3, &#39;俄罗斯&#39;, &#39;RU&#39;);</span><br><span class="line">INSERT INTO &#96;country&#96; VALUES (4, &#39;英国&#39;, &#39;GB&#39;);</span><br><span class="line">INSERT INTO &#96;country&#96; VALUES (5, &#39;法国&#39;, &#39;FR&#39;);</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">SET FOREIGN_KEY_CHECKS &#x3D; 1;</span><br></pre></td></tr></table></figure>
<p>编辑<strong>application.yml</strong>配置文件:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="comment"># 标注待解析的mapper的xml文件位置</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br><span class="line">  <span class="comment"># 标注实体类位置</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.example.country.entity</span></span><br></pre></td></tr></table></figure>
<h3 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h3><p>实体类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.country.entity;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Country</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String countryname;</span><br><span class="line">    <span class="keyword">private</span> String countrycode;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCountryname</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> countryname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCountryname</span><span class="params">(String countryname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.countryname = countryname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCountrycode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> countrycode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCountrycode</span><span class="params">(String countrycode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.countrycode = countrycode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Country&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, countryname=&#x27;&quot;</span> + countryname + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, countrycode=&#x27;&quot;</span> + countrycode + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Dao层:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.country.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.country.entity.Country;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CountryMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;Country&gt; <span class="title">getCountryList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dao层对应的XML文件(放在resources/mapper文件夹中)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.country.dao.CountryMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--查询全部信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getCountryList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;country&quot;</span>&gt;</span></span><br><span class="line">        select * from country</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以发现select语句的id属性值与Mapper接口中的方法名是一致的,它们就是靠这种方式将接口方法与XML中的SQL语句关联到一起的;resultType属性值指定的是查询结果的返回值类型,这里返回的是一个List,属性值country表明这个List中的元素都为country <strong>bean</strong></p>
<p>Service接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.country.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.country.entity.Country;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CountryService</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;Country&gt; <span class="title">getCountryList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Service接口实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.country.service.impl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.country.dao.CountryMapper;</span><br><span class="line"><span class="keyword">import</span> com.example.country.entity.Country;</span><br><span class="line"><span class="keyword">import</span> com.example.country.service.CountryService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountryServiceImpl</span> <span class="keyword">implements</span> <span class="title">CountryService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CountryMapper countryMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Country&gt; <span class="title">getCountryList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> countryMapper.getCountryList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Controller:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.country.controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.country.entity.Country;</span><br><span class="line"><span class="keyword">import</span> com.example.country.service.CountryService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(path = &quot;/country&quot;,produces = &quot;application/json&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountryController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> CountryService countryService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/getCountryList&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Country&gt; <span class="title">getCountryList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> countryService.getCountryList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以在浏览器中访问到该资源了:</p>
<p><a href="https://imgtu.com/i/4xO48e"><img src="https://z3.ax1x.com/2021/10/06/4xO48e.png" alt="4xO48e.png" style="zoom: 33%;" /></a></p>
<h2 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h2><p>注解方式的使用更为简单,只需要在Dao的接口方法中添加相应的注解,就免去了配置XML的麻烦,但我并不推荐,因为这种方式也把SQL语句硬编码在了代码中,比较适合个人开发.以下为示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.country.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.country.entity.Country;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CountryMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from country&quot;)</span></span><br><span class="line">    <span class="function">List&lt;Country&gt; <span class="title">getCountryList</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加注解后就不需要Mapper.xml文件了,不得不说确实方便.</p>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
  </entry>
  <entry>
    <title>x86:预备知识</title>
    <url>/20210802511919c/</url>
    <content><![CDATA[<p>x86汇编语言，作为学习操作系统前导知识，有必要学习一下。有幸在B站认识了<a href="https://space.bilibili.com/31272861?spm_id_from=333.788.b_765f7570696e666f.2">up主李老师</a>，引我走上学习操作系统内核之路。看了《x86汇编语言》这本书的前十章后，深觉有些纸上谈兵，摸不到头脑，在看保护模式时，突然发现，每章节会有一些学习目标，所以就以解决这些问题为目标进行学习吧。带着问题学习，才能更有收获。</p>
<h1 id="INTEL8086处理器的通用寄存器和段地址加偏移地址的内存访问方式"><a href="#INTEL8086处理器的通用寄存器和段地址加偏移地址的内存访问方式" class="headerlink" title="INTEL8086处理器的通用寄存器和段地址加偏移地址的内存访问方式"></a>INTEL8086处理器的通用寄存器和段地址加偏移地址的内存访问方式</h1><p>首先有必要介绍一下<a href="https://zh.wikipedia.org/wiki/Intel_8086">INTEL8086处理器</a>，它的诞生开启了x86架构的先河（至于为啥叫x86我就不知道了），直到现在，我们仍离不开它，或者说，在某些环境中，多多少少还能看到它的影子。</p>
<p>它是INTEL发布的第一款x86架构的16位微处理器。16位指的是它有16根数据总线，每次能处理至多2字节的数据。并且有20位外部地址总线，所以寻址空间为$2^{20}=1MB$。</p>
<h2 id="INTEL8086处理器的通用寄存器"><a href="#INTEL8086处理器的通用寄存器" class="headerlink" title="INTEL8086处理器的通用寄存器"></a>INTEL8086处理器的通用寄存器</h2><p>8086内部一共有8个通用寄存器，分别为AX、BX、CX、DX、SI、DI、BP、SP。这8个寄存器都是16位的，并且前4个又能分别拆成2个8位寄存器使用：</p>
<p><a href="https://imgtu.com/i/fCFsIO"><img src="https://z3.ax1x.com/2021/08/02/fCFsIO.png" alt="fCFsIO.png"></a></p>
<p>AL（AX Low）指的是低8位寄存器；AH（AX High）指的是高8位寄存器。操作低8位寄存器AL时，不影响高8位寄存器AH中的数据，反之也成立。</p>
<p>AX～DX寄存器比其他4个寄存器更加通用，从名字就能看出来。其余4个寄存器更加常用于以下工作：</p>
<ul>
<li>SI(Source Index)：源变址寄存器</li>
<li>DI(Destination Index)：目的变址寄存器</li>
<li>BP(Base Pointer)：基指针寄存器</li>
<li>SP(Stack Pointer)：堆栈指针寄存器</li>
</ul>
<p>这四个寄存器不能像AX～DX寄存器一样被分为高8位和低8位，什么时候需要使用了，我们再做分析。</p>
<h2 id="段地址加偏移地址的内存访问方式"><a href="#段地址加偏移地址的内存访问方式" class="headerlink" title="段地址加偏移地址的内存访问方式"></a>段地址加偏移地址的内存访问方式</h2><p>先介绍一下背景：</p>
<p>首先说一下我们为什么要使用内存，为什么不直接使用寄存器来存储数据。</p>
<p>这是因为寄存器造价太高，我们不得不使用价格稍微便宜，容量更大的内存来暂时存储数据。</p>
<p>在内存中有数据段和代码段，处理器并不知道什么是数据什么是指令，同样的数据在不同的空间中解释也不同。例如ADD指令，假如它翻译成的机器码是0100 1001，如果处理器将这段数据当作指令解释，那它就是ADD指令；而如果处理器将其解释为数据，那就是十进制的1+8+64=73。为了方便记忆这些操作码，人们发明了汇编语言，而编译器就充当了这个过程中的翻译官，当我们写完了汇编代码后，编译器会将程序翻译成对应的机器码，这样处理器就能理解了。</p>
<p>好了，说了这么多，我都等不及了，赶紧访问内存吧，怎么访问？起码我现在知道一点：内存至少分成两部分，可事实上，内存里乱的很。为啥呢？因为我们有时不止运行一个程序，所以内存里不止一套数据和代码，它们被加载到内存中的位置是随机的！</p>
<p>假如有个新手程序员写了一条指令，在内存中的0100（<strong>物理地址</strong>：内存的真实地址）处取一次数据，可0100处放的是别的程序的数据，我靠，这不就越俎(zǔ)代庖了吗？而且我可不想我程序的数据被别的程序读取，甚至修改！这其实是因为程序员想直接访问物理内存导致的结果。为了我们的程序能够总是正确的运行，我们不能直接使用物理地址了，这太不安全了，所以设计一套能够“自圆其说”的内存访问方式，这就是<strong>程序的重定向</strong>。</p>
<p>所以我们采用了<strong>内存分段策略</strong>，这个段可不是上边的数据段和代码段的段，而是使用“段：偏移”或“段地址：偏移地址”。（<strong>逻辑地址</strong>：段地址+偏移地址）这怎么理解呢？</p>
<p>可以这么理解：</p>
<p>把段地址想象成一个车技很好的大哥，偏移地址就是个特别听话的小弟。每次加载程序时，都可能在内存中的不同地方，段地址大哥的车技很好，就带着偏移地址小弟在内存中“漂移”，每次加载的时候位置都不一样，但偏移地址小弟只需要跟着段地址大哥飞就行了。</p>
<h2 id="内存分段机制"><a href="#内存分段机制" class="headerlink" title="内存分段机制"></a>内存分段机制</h2><p>为了在硬件级实现这样的功能，处理器需要两个段寄存器：<strong>代码段寄存器</strong>(Code Segment, CS)和<strong>数据段寄存器</strong>(Data Segment, DS)。加载程序时，CS和DS中的数据都会被重置，当代码段中的指令想要访问数据时，就需要将DS中的段地址与指令中的偏移地址相加，得到访问内存所需的物理地址。</p>
<h1 id="分段机制对程序重定位的好处"><a href="#分段机制对程序重定位的好处" class="headerlink" title="分段机制对程序重定位的好处"></a>分段机制对程序重定位的好处</h1><p>从上边的叙述中就可以简单的概括出，使用分段机制，可以更简单的进行程序的重定位。在编写程序时，我们就不用真正考虑数据到底在内存中的什么地方，自有段地址为我们搞定。</p>
<h1 id="INTEL8086处理器内存分段的本质及灵活性"><a href="#INTEL8086处理器内存分段的本质及灵活性" class="headerlink" title="INTEL8086处理器内存分段的本质及灵活性"></a>INTEL8086处理器内存分段的本质及灵活性</h1><p>受制于自身限制，INTEL8086的内存分段机制更加复杂。</p>
<h2 id="INTEL8086的内存分段机制"><a href="#INTEL8086的内存分段机制" class="headerlink" title="INTEL8086的内存分段机制"></a>INTEL8086的内存分段机制</h2><p>8086内部有4个段寄存器：</p>
<ul>
<li>CS：代码段寄存器</li>
<li>DS：数据段寄存器</li>
<li>ES：(Extra Segment)附加段寄存器：程序中需要两个数据段时，ES可以为DS提供辅助</li>
<li>SS：(Stack Segment)栈段寄存器</li>
</ul>
<p><a href="https://imgtu.com/i/fCJRp9"><img src="https://z3.ax1x.com/2021/08/02/fCJRp9.png" alt="fCJRp9.png"></a></p>
<h2 id="INTEL8086内存访问"><a href="#INTEL8086内存访问" class="headerlink" title="INTEL8086内存访问"></a>INTEL8086内存访问</h2><p>之前说8086有20位外部地址总线，可以访问1MB的内存，可在CPU内部是如何实现的呢？</p>
<p>一共有3个部件参与这个工作。当加载程序时，代码段寄存器DS中会保存当前指令的段地址，IP寄存器会保存段内偏移地址，将段地址左移4位后，加上偏移地址，组成20位的物理地址，这个20位的物理地址不会保存在寄存器中（寄存器里当然也放不下），而是传给输入输出控制电路，然后再传输到地址总线上，从而到内存中寻址。找到代码段中的指令后，会有专门的电路用来执行指令，指令中如果有数据，那么它一定是数据段的偏移地址，我们还需要使用数据段寄存器DS来获得数据段的段地址，将两个地址相加，就可以得到数据的物理地址了。</p>
<blockquote>
<p>详情可参阅<a href="https://www.bilibili.com/video/BV1xE411N74T?p=20">计算机语言 x86汇编语言：从实模式到保护模式</a></p>
</blockquote>
<p>8086访问内存使用了段地址加偏移地址的分段机制，一共有两种方式：</p>
<ol>
<li>充分利用偏移地址，偏移地址寄存器有16位，内存有20位，那么内存就可以被分成$\frac{2^{20}}{2^{16}}=2^{4}=16$个段，那么每个段就有$2^{16}=64KB$大小，偏移地址寄存器的16位地址全被得到了利用</li>
<li>充分利用段地址，段地址寄存器有16位，那么就可以将内存分为$2^{16}=65536$个段，那么每个段就只有$2^{4}=16B$，此时段地址寄存器的16位地址全部得到了利用。</li>
</ol>
<p>这两种方式肯定有各自的优缺点，这里先不做讨论。</p>
<h2 id="灵活性"><a href="#灵活性" class="headerlink" title="灵活性"></a>灵活性</h2><p>通过以上的分析，我们就知道8086的内存访问非常灵活了，那么灵活在哪呢？</p>
<p>我认为，正是由于分段机制的两种策略，再根据不同的使用场景，我们可以将内存分成一定数量的段，这这个数量是由我们决定的，我们可以分16～65536这个区间中的，这么多种不同的数量。（这里面可能涉及字对齐的问题，所以不是任意的数都可以取，假如你非要把内存分成17个段，那么肯定无法平均分配了，最后一块内存不够长了，就会有一定的bug）</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>x86</tag>
      </tags>
  </entry>
  <entry>
    <title>代价聚合</title>
    <url>/202105199e704f9b/</url>
    <content><![CDATA[<p>上次能获得视差图后，整个立体匹配算法的整体框架已经有了，剩下的就是优化工作了，优化肯定有个优先级，什么样的优化、怎样优化是需要我们自己根据实际的项目进行评估的，以优化匹配精度是需要牺牲一些效率的，我做的项目对精度的要求不是特别高，但需要做到实时，所以根据项目情况进行优化吧。</p>
<p>首先第一个做的优化是<strong>代价聚合</strong>，这应该都不叫优化了，但我还是把他归为优化一类，因为从效果来看，上次的确是已经获得深度图了，根据<a href="http://vision.deis.unibo.it/~smatt/Seminars/StereoVision.pdf">Stereo Vision:Algorithms and Applications</a>的ppt讲义可以知道，代价聚合也是半全局算法SGM绕不开的，所以就接着搞吧。</p>
<p>还是跟着李迎松博士的博客搞得，代价聚合使用SO(Scanline Optimizaion)算法，即<strong>扫描线优化算法</strong>。</p>
<h1 id="视差主序"><a href="#视差主序" class="headerlink" title="视差主序"></a>视差主序</h1><blockquote>
<p>看过前篇的同学们肯定已经接触了视差主序的概念，我再次重申一遍是因为它很重要，关系到我如何存取代价数组的值。</p>
<p>我们谈到主序，大家会想起二维数组中数据的存储方式，如果是行主序，则数据优先在行内按顺序紧密排列，即第0行第0列和第0行第1列是相邻的元素；如果是列主序，则数据优先在列内按顺序紧密排列，即第0行第0列和第1行第0列是相邻的元素。主序类型，决定了通过行列号计算元素在数组中相对首地址的位置偏移量的方式，也决定了数组采用哪种遍历顺序会更高效（缓存原理）。</p>
<p>代价数组有三个维度：行、列、视差，视差主序的意思是同一个像素点各视差下的代价值紧密排列，即代价数组元素的排列顺序为：</p>
<p>(0,0)像素的所有视差对应的代价值；<br>(0,1)像素的所有视差对应的代价值；<br>…<br>…<br>(0,w-1)像素的所有视差对应的代价值；<br>(1,0)像素的所有视差对应的代价值；<br>(1,1)像素的所有视差对应的代价值；<br>…<br>…<br>第(h-1,w-1)个像素的所有视差对应的代价值；</p>
<p>这样排列的好处是：单个像素的代价值都挨在一起，聚合时可以达到很高的存取效率。这对于大尺寸影像来说可带来明显的效率优势，对于像CUDA这类存储效率至关重要的平台来说就有明显优势。</p>
<p>视差主序下，( i , j , d ) ( i, j, d )(i,j,d)位置的代价值由如下方式获得（cost为代价数组）：</p>
<p>cost[i <em> width </em> disp_range + j*disp_range + d]<br>1<br>大家思考下为何是这样获取，理解下视差主序的含义。</p>
<p>介绍完主序方式，就可以开始摄入正餐了!</p>
</blockquote>
<p>一开始没太注重这个视差主序，后来在研究了一段时间李博的代码后才知道李博在文章最前面就将这个概念说明的用意，这是我的一点疑惑，并有幸得到了李博的解答：</p>
<p>问：SGM算法中的代价数组为什么使用一维数组而不使用多维数组呢，难道一维数组性能更好吗？</p>
<p>答：其实一般情况下使用都差不多，多维数组就是你用着方便。一维数组因为是连续的，所以会有缓存命中率高、可以任意转换指针类型（这个在CUDA的三维数组里会频繁使用）等优点，实际上如果你直接让编译器分配一个三维数组，他大概率就是底层分配的一维数组，再做一个偏移量管理。而如果你手动分配多个2维数组组合成3维数组，比如一个vector里面很多mat，那多个2维数组不是连续的，效率是会比连续的一维数组要慢一点。一维数组主要是要你自己计算偏移量，实际上使用更灵活，整体效率更好的。</p>
<h1 id="左右路径聚合"><a href="#左右路径聚合" class="headerlink" title="左右路径聚合"></a>左右路径聚合</h1><p>在同一行内从左到右执行聚合：<br><a href="https://imgtu.com/i/g5xQSO"><img src="https://z3.ax1x.com/2021/05/19/g5xQSO.png" alt="g5xQSO.png" style="zoom: 50%;" /></a></p>
<p>代价计算公式：</p>
<script type="math/tex; mode=display">
L_{r}(\mathrm{p}, d)=\mathrm{C}(\mathrm{p}, d)+\min \left\{\begin{array}{l}
L_{r}(\mathrm{p}-\mathrm{r}, d) \\
L_{r}(\mathrm{p}-\mathrm{r}, d-1)+P_{1} \\
L_{r}(\mathrm{p}-\mathrm{r}, d+1)+P_{1} \\
\min _{i} L_{r}(\mathrm{p}-\mathrm{r}, i)+P_{2}
\end{array}\right\}-\min _{i} L_{r}(\mathrm{p}-\mathrm{r}, i)</script><p><a href="https://imgtu.com/i/gLA0je"><img src="https://z3.ax1x.com/2021/05/22/gLA0je.png" alt="gLA0je.png"></a></p>
<h1 id="上下路径聚合"><a href="#上下路径聚合" class="headerlink" title="上下路径聚合"></a>上下路径聚合</h1><p><a href="https://imgtu.com/i/gLAzDJ"><img src="https://z3.ax1x.com/2021/05/22/gLAzDJ.png" alt="gLAzDJ.png" style="zoom:50%;" /></a></p>
<p>原理与左右路径聚合一致</p>
<h1 id="总路径聚合"><a href="#总路径聚合" class="headerlink" title="总路径聚合"></a>总路径聚合</h1><p><a href="https://imgtu.com/i/gLE18f"><img src="https://z3.ax1x.com/2021/05/22/gLE18f.png" alt="gLE18f.png" style="zoom:50%;" /></a></p>
<p>四路径聚合已经能达到我的要求了，而且四路径比八路径效率更高，八路径会有不干活的情况。八路径聚合可看李博的这篇博客：<a href="https://blog.csdn.net/rs_lys/article/details/105396761">代价聚合2</a></p>
<p>实验结果可看李博的博客。</p>
<blockquote id="fn_1">
<sup>1</sup>. <a href="https://ethanli.blog.csdn.net/article/details/105316274">【码上实战】【立体匹配系列】经典SGM：（3）代价聚合</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
]]></content>
      <categories>
        <category>机器视觉</category>
      </categories>
  </entry>
  <entry>
    <title>代价计算与视差计算</title>
    <url>/2021051835824a08/</url>
    <content><![CDATA[<p>上次实现了census变换和计算Hamming距离后，就可以得到像素的二进制编码位串，并对两个编码过的像素（实际上是编码过的位串）进行Hamming距离计算，以计算他们在某种意义上的相似性。有了他俩的帮助，就能进行代价计算和视差计算了。</p>
<h1 id="代价计算"><a href="#代价计算" class="headerlink" title="代价计算"></a>代价计算</h1><p>代价计算的默认前提是两副图像已经经过极线矫正了，这样才能使图像尽量达到我们想要的理想情况，即像素只有横向上的位移。代价计算的算法也是基于这个前提的。正是由于有一个横向位移，所以需要指定一个视差范围，在这个视差范围内寻找最为匹配的像素。这里我先搬来了李博的代码，对着代码分析是如何计算代价的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SemiGlobalMatching::ComputeCost</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> sint32&amp; min_disparity = option_.min_disparity;</span><br><span class="line">    <span class="keyword">const</span> sint32&amp; max_disparity = option_.max_disparity;</span><br><span class="line">    <span class="keyword">const</span> sint32 disp_range = max_disparity - min_disparity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算代价（基于Hamming距离）</span></span><br><span class="line">    <span class="keyword">for</span> (sint32 i = <span class="number">0</span>; i &lt; height_; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (sint32 j = <span class="number">0</span>; j &lt; width_; j++) &#123;</span><br><span class="line">            <span class="comment">// 逐视差计算代价值</span></span><br><span class="line">            <span class="keyword">for</span> (sint32 d = min_disparity; d &lt; max_disparity; d++) &#123;</span><br><span class="line">                <span class="comment">// cost_init_是视差空间图像，cost是单个视差的引用</span></span><br><span class="line">                <span class="keyword">auto</span>&amp; cost = cost_init_[i * width_ * disp_range + j * disp_range + (d - min_disparity)];</span><br><span class="line">                <span class="comment">// j-d 代表行上的索引，超出索引范围后，为其赋值为 127，表示灰度中值</span></span><br><span class="line">                <span class="keyword">if</span> (j - d &lt; <span class="number">0</span> || j - d &gt;= width_) &#123;</span><br><span class="line">                    cost = UINT8_MAX/<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 左影像census值</span></span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">auto</span>&amp; census_val_l = <span class="keyword">static_cast</span>&lt;uint32*&gt;(census_left_)[i * width_ + j];</span><br><span class="line">                <span class="comment">// 右影像对应像点的census值</span></span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">auto</span>&amp; census_val_r = <span class="keyword">static_cast</span>&lt;uint32*&gt;(census_right_)[i * width_ + j - d];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 计算匹配代价，以左图为基准，右图中对应位置的像素点以及这一点所在行的前d个像素进行对比，获得第三个维度的多个视差</span></span><br><span class="line">                cost = sgm_util::Hamming32(census_val_l, census_val_r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如指定视差范围为0～64，以左图为基准，使用右图对应位置的像素点以及这一点所在行的前d个像素进行对比，获得第三个维度的64个视差，<code>if (j - d &lt; 0 || j - d &gt;= width_)</code>用来处理边缘那些超出图像索引范围的像素，给他们赋予灰度中值，从而可以得到一个<strong>视差空间图像(DSI)</strong>：<br><a href="https://imgtu.com/i/gQlvRg"><img src="https://z3.ax1x.com/2021/05/06/gQlvRg.png" alt="gQlvRg.png"></a></p>
<p>得到这个视差空间图像后，就可以进行视差计算了：</p>
<h1 id="视差计算"><a href="#视差计算" class="headerlink" title="视差计算"></a>视差计算</h1><p>视差计算采用<strong>赢家通吃（WTA）</strong>算法，很简单的，就是对单个像素的64个代价值求其最小值，作为这个像素点最终的视差值：</p>
<p><a href="https://imgtu.com/i/ghRLF0"><img src="https://z3.ax1x.com/2021/05/18/ghRLF0.png" alt="ghRLF0.png"></a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SemiGlobalMatching::ComputeDisparity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最小最大视差</span></span><br><span class="line">    <span class="keyword">const</span> sint32&amp; min_disparity = option_.min_disparity;</span><br><span class="line">    <span class="keyword">const</span> sint32&amp; max_disparity = option_.max_disparity;</span><br><span class="line">    <span class="keyword">const</span> sint32 disp_range = max_disparity - min_disparity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> sint32 width = width_;</span><br><span class="line">    <span class="keyword">const</span> sint32 height = height_;</span><br><span class="line">    <span class="comment">// 未实现聚合步骤，暂用初始代价值来代替</span></span><br><span class="line">    <span class="keyword">auto</span> cost_ptr = cost_init_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐像素计算最优视差</span></span><br><span class="line">    <span class="keyword">for</span> (sint32 i = <span class="number">0</span>; i &lt; height_; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (sint32 j = <span class="number">0</span>; j &lt; width_; j++) &#123;</span><br><span class="line"></span><br><span class="line">            uint16 min_cost = UINT16_MAX;</span><br><span class="line">            uint16 max_cost = <span class="number">0</span>;</span><br><span class="line">            sint32 best_disparity = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历视差范围内的所有代价值，输出最小代价值及对应的视差值</span></span><br><span class="line">            <span class="keyword">for</span> (sint32 d = min_disparity; d &lt; max_disparity; d++) &#123;</span><br><span class="line">                <span class="keyword">const</span> sint32 d_idx = d - min_disparity; <span class="comment">// 视差索引</span></span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">auto</span>&amp; cost = cost_ptr[i * width * disp_range + j * disp_range + d_idx];</span><br><span class="line">                <span class="keyword">if</span>(min_cost &gt; cost) &#123;</span><br><span class="line">                    min_cost = cost;</span><br><span class="line">                    best_disparity = d;</span><br><span class="line">                &#125;</span><br><span class="line">                max_cost = <span class="built_in">std</span>::max(max_cost, <span class="keyword">static_cast</span>&lt;uint16&gt;(cost));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 最小代价值对应的视差值即为像素的最优视差</span></span><br><span class="line">            <span class="keyword">if</span> (max_cost != min_cost) &#123;</span><br><span class="line">                disp_left_[i * width_ + j] = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(best_disparity);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果所有视差下的代价值都一样，则该像素无效</span></span><br><span class="line">                disp_left_[i * width_ + j] = Invalid_Float;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就有了一个完整可运行的框架，剩下的就只是优化工作了，运行主函数可以获得实验结果：</p>
<p><a href="https://imgtu.com/i/g4QFy9"><img src="https://z3.ax1x.com/2021/05/19/g4QFy9.png" alt="g4QFy9.png"></a></p>
<blockquote id="fn_1">
<sup>1</sup>. <a href="https://blog.csdn.net/rs_lys/article/details/84305717">【理论恒叨】【立体匹配系列】经典SGM：（4）视差计算、视差优化</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_2">
<sup>2</sup>. <a href="https://blog.csdn.net/rs_lys/article/details/105142484?spm=1001.2014.3001.5501">【码上实战】【立体匹配系列】经典SGM：（2）代价计算</a><a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
]]></content>
      <categories>
        <category>机器视觉</category>
      </categories>
  </entry>
  <entry>
    <title>Census变换</title>
    <url>/2021051334caeb6d/</url>
    <content><![CDATA[<h1 id="Census变换-2是什么"><a href="#Census变换-2是什么" class="headerlink" title="Census变换 2是什么"></a>Census变换<sup><a href="#fn_ 2" id="reffn_ 2"> 2</a></sup>是什么</h1><p>是一种非参数局部变换方法，通过变换两幅图像，使用相关性，以计算图像的匹配关系。依赖像素强度的相对顺序而不是强度值本身，所以对图像亮度不敏感。census变换是对局部空间结构的非参数化总结。</p>
<p>设$P$是一个像素，$I(P)$是像素强度（通常是一个8bit整数），$N(P)$是围绕$P$的直径为$d$的正方形邻域中的一组像素。所有非参数变换都取决于$P$与邻域$N(P)$中像素强度的比较结果：</p>
<script type="math/tex; mode=display">
\xi(P, P^{\prime})=\left\{\begin{array}{ll}
1 & \text { if } I(P^{\prime}) < I(P)\\
0 & \text { if } I(P^{\prime}) \geq  I(P)
\end{array}\right.</script><p>非参数局部变换仅依赖于有序对集：</p>
<script type="math/tex; mode=display">
\Xi(P)=\bigcup_{P^{\prime} \in N(P)}\left(P^{\prime}, \xi\left(P, P^{\prime}\right)\right)</script><p>$R_{\tau}(P)$将像素P周围的局部邻域映射到表示强度小于$P$的相邻像素集的位串。设$N(P)=P \bigoplus D$，其中$\bigoplus$是Minkowski和，D是一组位移，设$\bigotimes $表示缩并（上标和下标相同的参数在相乘求和后，可看作标量）。则可以指定census变换：</p>
<script type="math/tex; mode=display">
R_{\tau}(P)=\bigotimes_{[i, j] \in D} \xi(P, P+[i, j])</script><p>利用Hamming距离（即两个位串中不同位的数目）来比较census变换后图像的两个像素的相似度。为了计算匹配关系，在应用census变换后最小化Hamming距离。</p>
<p>Hamming距离即两个比特串的对应位不相同的数量，计算方法为将两个比特串进行亦或运算，再统计亦或运算结果的比特位中不为1的个数：</p>
<script type="math/tex; mode=display">
\mathrm{C}(u, v, d):=\operatorname{Hamming}\left(C_{s l}(u, v), C_{s r}(u-d, v)\right)</script><p><a href="https://imgtu.com/i/gsUhcR"><img src="https://z3.ax1x.com/2021/05/14/gsUhcR.jpg" alt="gsUhcR.jpg"></a></p>
<p>Census变换对整体的明暗变化并不敏感，因为是比较的相对灰度关系，所以即使左右影像亮度不一致，也能得到较好的匹配效果。</p>
<p><strong>Census相比互信息还具有并行度高的优点，因为Census变换值是局部窗口运算，所以每个像素可以独立运算，这个特性让其可以很好的设计多线程并行计算模型，无论是CPU并行还是GPU并行都能达到非常高的并行效率。</strong></p>
<h2 id="大白话理解census变换与Hamming距离"><a href="#大白话理解census变换与Hamming距离" class="headerlink" title="大白话理解census变换与Hamming距离"></a>大白话理解census变换与Hamming距离</h2><p><strong>census变换</strong>就是对一个像素的编码方式，使用这个像素周围的像素与其作比较，比它大就得1，否则就得0，所以就能得到一个二进制位串，这就完成了对这个像素的编码，这不是随意的，而是依赖他周围的像素，因为是互相比较得出的值，所以只能得出相对的信息，而忽略一些绝对的信息。</p>
<p><strong>Hamming距离</strong>就是对两个二进制位串按位比较不同位的个数。</p>
<h1 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h1><p>为了计算图像的匹配关系</p>
<h1 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h1><p>直接上代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">census_transform_3x3</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span> *source, <span class="keyword">uint32_t</span> *census, <span class="keyword">const</span> <span class="keyword">int32_t</span> &amp;width,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> <span class="keyword">int32_t</span> &amp;height)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int32_t</span> i = <span class="number">1</span>; i &lt; height - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int32_t</span> j = <span class="number">1</span>; j &lt; width - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="comment">// 中心像素值</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">uint8_t</span> gray_center = source[i * width + j];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历大小为3x3的窗口内邻域像素，逐一比较像素值与中心像素值的的大小，计算census值</span></span><br><span class="line">            <span class="keyword">uint32_t</span> census_val = <span class="number">0u</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int32_t</span> r = <span class="number">-1</span>; r &lt;= <span class="number">1</span>; r++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int32_t</span> c = <span class="number">-1</span>; c &lt;= <span class="number">1</span>; c++) &#123;</span><br><span class="line">                    census_val &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">uint8_t</span> gray = source[(i + r) * width +j + c];</span><br><span class="line">                    <span class="keyword">if</span> (gray &lt; gray_center)</span><br><span class="line">                        census_val += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            printf(&quot;%d&quot;, gray_center);</span></span><br><span class="line">            <span class="comment">// 中心像素的census值，为之后的代价计算做准备</span></span><br><span class="line">            census[i * width + j] = census_val;</span><br><span class="line">            <span class="comment">// 打印二进制数</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;中心像素的二进制位串：&quot;</span>&lt;&lt;<span class="built_in">bitset</span>&lt;9&gt;(census_val)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="comment">// 打印十六进制数</span></span><br><span class="line"><span class="comment">//            printf(&quot;中心像素的十六进制位串：%x\n&quot;, census_val);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">Hamming32</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint32_t</span> &amp;x, <span class="keyword">const</span> <span class="keyword">uint32_t</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> dist = <span class="number">0</span>, val = x ^ y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Count the number of set bits</span></span><br><span class="line">    <span class="keyword">while</span> (val)&#123;</span><br><span class="line">        ++dist;</span><br><span class="line">        val &amp;= val - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Mat uM1 = Mat(<span class="number">3</span>,<span class="number">3</span>,CV_8UC1);	<span class="comment">// 声明一个3x3的单通道矩阵</span></span><br><span class="line">    Mat uM2 = Mat(<span class="number">3</span>,<span class="number">3</span>,CV_8UC1);	<span class="comment">// 声明一个3x3的单通道矩阵</span></span><br><span class="line">    randu(uM1,Scalar::all(<span class="number">0</span>), Scalar::all(<span class="number">255</span>));	<span class="comment">// 对uM进行初始化，初始化值的范围为0～255</span></span><br><span class="line">    randu(uM2,Scalar::all(<span class="number">0</span>), Scalar::all(<span class="number">255</span>));	<span class="comment">// 对uM进行初始化，初始化值的范围为0～255</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; uM1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; uM2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> width = uM1.cols;</span><br><span class="line">    <span class="keyword">int32_t</span> height = uM1.rows;</span><br><span class="line">    <span class="keyword">auto</span> *census1 = <span class="keyword">new</span> <span class="keyword">uint32_t</span> [width * height](); <span class="comment">// 声明一个动态数组</span></span><br><span class="line">    <span class="keyword">auto</span> *census2 = <span class="keyword">new</span> <span class="keyword">uint32_t</span> [width * height](); <span class="comment">// 声明一个动态数组</span></span><br><span class="line">    <span class="comment">// 窗口大小为3x3的 census 变换</span></span><br><span class="line">    census_transform_3x3(uM1.data, census1, width, height);</span><br><span class="line">    census_transform_3x3(uM2.data, census2, width, height);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> Hamming = Hamming32(census1[<span class="number">4</span>],census2[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hamming:&quot;</span> &lt;&lt; Hamming &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果验证：</p>
<p><a href="https://imgtu.com/i/gsUufH"><img src="https://z3.ax1x.com/2021/05/14/gsUufH.png" alt="gsUufH.png"></a></p>
<hr>
<p>PS:</p>
<p>这里插一嘴，census变换的论文中，二进制位串的求法和代码<sup><a href="#fn_ 1" id="reffn_ 1"> 1</a></sup>里正好是相反的，但不会影响Hamming距离的结果，因为我理解census变换只是一种将图像信息转化为二进制的编码方式，只要两张图片都遵守这种编码方式就行，真正核心的地方就是Hamming距离来匹配图像了</p>
<blockquote id="fn_1">
<sup>1</sup>. <a href="https://blog.csdn.net/rs_lys/article/details/83614915">【理论恒叨】【立体匹配系列】经典SGM：（2）匹配代价计算之Census变换</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_2">
<sup>2</sup>. ZABIH R, WOODFILL J. Non-parametric local transforms for computing visual correspondence[M]. 1994: 151-158.<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
]]></content>
      <categories>
        <category>机器视觉</category>
      </categories>
  </entry>
  <entry>
    <title>在Ubuntu20上安装配置Opnecv3.1.0(C++)</title>
    <url>/20210513bc5902fd/</url>
    <content><![CDATA[<p>最近在学习一些双目立体匹配的算法，大部分开源的代码还都是基于C++的，所以我需要在我的Ubuntu20.10上安装配置C++版本的Opencv，没想到这么麻烦，所以记录一下。</p>
<p>我使用的环境是：</p>
<ul>
<li>Ubuntu20.10</li>
<li>Opencv3.1.0</li>
<li>Clion</li>
</ul>
<p>以下为安装步骤：</p>
<h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><ol>
<li><p>在Opencv<a href="https://opencv.org/">官网</a>下载source压缩包，然后在本地解压。</p>
</li>
<li><p>编译并安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建并进入 build 文件夹</span></span><br><span class="line">mkdir build</span><br><span class="line">cd bulid</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 cmake 进行编译</span></span><br><span class="line">cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local ..</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 多线程编译，更快。我的电脑4核，所以是j4</span></span><br><span class="line">make -j4</span><br><span class="line"></span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>这样其实就安装好了</p>
</li>
</ol>
<h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>安装好了之后需要验证一下，使用这段代码进行验证：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argv,<span class="keyword">char</span>** argc)</span></span>&#123;</span><br><span class="line">	Mat image;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按照自己的目录</span></span><br><span class="line">    image = cv::imread(<span class="string">&quot;../electrode.jpg&quot;</span>, <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">if</span> ( !image.data )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No image data \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    namedWindow(<span class="string">&quot;Display Image&quot;</span>, WINDOW_AUTOSIZE );</span><br><span class="line">    imshow(<span class="string">&quot;Display Image&quot;</span>, image);</span><br><span class="line">    waitKey(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="一些bug的解决方式"><a href="#一些bug的解决方式" class="headerlink" title="一些bug的解决方式"></a>一些bug的解决方式</h1><ol>
<li><p><code>/usr/include/c++/7/cstdlib:75:15: fatal error: stdlib.h: 没有那个文件或目录</code></p>
<p>在cmake时，添加一项参数：<code>-DENABLE_PRECOMPILED_HEADERS=OFF</code>，所以我的cmake命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local .. -DENABLE_PRECOMPILED_HEADERS=OFF</span><br></pre></td></tr></table></figure>
<p>然后再make、make install就可以了</p>
</li>
<li><p>使用代码验证时，需要配置一下Clion的<code>CMakelists.txt</code>：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">find_package(OpenCV REQUIRED)</span><br><span class="line"></span><br><span class="line">target_link_libraries( ClionTest $&#123;OpenCV_LIBS&#125; ) // ClionTest是项目名</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行代码时，出现类似以下这样的错误，代表缺少一些显示窗口的库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">OpenCV Error: Unspecified error (The function is not implemented. Rebuild the library with Windows, GTK+ 2.x or Carbon support. If you are on Ubuntu or Debian, install libgtk2.0-dev and pkg-config, then re-run cmake or configure script) in cvNamedWindow, file /home/wangtaocs/Downloads/opencv-3.1.0/modules/highgui/src/window.cpp, line 527</span><br><span class="line">terminate called after throwing an instance of &#x27;cv::Exception&#x27;</span><br><span class="line">  what():  /home/wangtaocs/Downloads/opencv-3.1.0/modules/highgui/src/window.cpp:527: error: (-2) The function is not implemented. Rebuild the library with Windows, GTK+ 2.x or Carbon support. If you are on Ubuntu or Debian, install libgtk2.0-dev and pkg-config, then re-run cmake or configure script in function cvNamedWindow</span><br></pre></td></tr></table></figure>
<p>解决办法是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install libgtk2.0-dev pkg-config</span><br></pre></td></tr></table></figure>
<p>然后重新进行上边的步骤，编译安装opencv即可</p>
</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/88ad5441c2ae">Ubuntu下安装配置opencv3.2.0 以及代码测试</a></p>
<p><a href="https://blog.csdn.net/u010632165/article/details/81431030">OpenCV Error: Unspecified Error(The Function is not implemented)</a></p>
]]></content>
      <categories>
        <category>机器视觉</category>
      </categories>
  </entry>
  <entry>
    <title>对极几何</title>
    <url>/202105099103d3fa/</url>
    <content><![CDATA[<h1 id="双目视觉的对极几何"><a href="#双目视觉的对极几何" class="headerlink" title="双目视觉的对极几何"></a>双目视觉的对极几何</h1><ol>
<li><p>对极几何是什么？</p>
<p>对极几何是相机在两个不同的位置生成的两幅图像，其拍摄位置和生成图像之间存在特殊的几何关系。其基本几何模型如下：</p>
<p><a href="https://imgtu.com/i/gYkU6s"><img src="https://z3.ax1x.com/2021/05/09/gYkU6s.png" alt="gYkU6s.png" style="zoom: 67%;" /></a></p>
</li>
<li><p>对极几何的作用</p>
<ol>
<li>解决立体匹配的问题，这里把C0和C1想象成两个相机，各获得一副图像，图像的内容会存在一定的约束关系，依靠这种关系，我们可以确定物体的深度</li>
<li>解决相机位姿与拍摄点的相对位置问题。把C0和C1想象成一个相机在两个不同的位置获得的两幅图像，根据约束关系，可以推导出相机的位姿。</li>
</ol>
<p>双目主要利用第一条。</p>
</li>
<li><p>基本概念</p>
<ol>
<li>极点（Epipoles）：两个相机得基线与两个成像平面得交点，如上图中的e0、e1</li>
<li>极线（Epipolar Lines）：空间中点在成像平面上的投影点与极点的连线，如上图中的l0、l1</li>
<li>极平面（Epipolar Plane）：空间中的点与两个相机的光轴中心点所组成的平面，如上图c0、c1、p所在的平面</li>
</ol>
</li>
<li><p>对极约束</p>
<p>假定相机参数已知，那么对于空间中P点，它将和两个相机的中心点O1和O2，唯一确定对极几何的几何关系，极点、极线、极平面都将确定，而对极约束描叙的就是：<strong>在平面1上成像为p的所有空间点，其必定投影在平面2的极线上，反之亦然。</strong></p>
</li>
</ol>
<h2 id="双目相机获得深度图的原理"><a href="#双目相机获得深度图的原理" class="headerlink" title="双目相机获得深度图的原理"></a>双目相机获得深度图的原理</h2><p>双目相机获得深度图的原理</p>
<p><a href="https://imgtu.com/i/guK3WR"><img src="https://z3.ax1x.com/2021/05/04/guK3WR.jpg" alt="guK3WR.jpg" style="zoom:50%;" /></a></p>
<p>如图，可抽象为双目相机成像的鸟瞰图，$O_{R}$与$O_{T}$分别为左右相机的光心，红色线为相机CCD，$A$、$B$为相机CCD的中点，设相机CCD的长度为$L$，物体P在左右相机的CCD上的像点分别为$P_{R}$、$P_{T}$，像点距离CCD左端的距离分别为$x_{R}$、$x_{T}$，相机的焦距为$f$，相机光心的距离为$b$，求物体的距离$Z$</p>
<p><a href="https://imgtu.com/i/gul3Wj"><img src="https://z3.ax1x.com/2021/05/04/gul3Wj.jpg" alt="gul3Wj.jpg" style="zoom:50%;" /></a></p>
<p>视差：</p>
<script type="math/tex; mode=display">
disparity=X_{R}-X_{T}</script><p><a href="https://imgtu.com/i/gul4te"><img src="https://z3.ax1x.com/2021/05/04/gul4te.png" alt="gul4te.png"></a></p>
<p>物体越近，视差越大；物体越远，视差越小。</p>
<h2 id="关键矩阵"><a href="#关键矩阵" class="headerlink" title="关键矩阵"></a>关键矩阵</h2><p>双目相机获得的图像存在约束关系，这种约束关系就是靠这三个关键矩阵来描述的：<strong>本质矩阵、基础矩阵、单应性矩阵</strong>。它们可以建立两个视图公共点之间的坐标联系，或者完成公共点之间的坐标转换。它们就像立体视觉双视图之间的桥梁，让彼此紧密相连，形成一个整体，才算有了立体视觉系统的概念。</p>
<h3 id="本质矩阵和基础矩阵"><a href="#本质矩阵和基础矩阵" class="headerlink" title="本质矩阵和基础矩阵"></a>本质矩阵和基础矩阵</h3><p>变量说明：</p>
<ol>
<li>d1、d2为深度，是一个标量</li>
<li>K1、K2为左右相机的内参</li>
<li>R、t为旋转和平移矩阵</li>
<li>p1、p2为图像坐标系</li>
<li>x1、x2为像素坐标系</li>
</ol>
<p>设空间点p在左相机坐标系下的坐标为P，则在右相机坐标系下的坐标为RP+t；在左右像平面上的投影为p1和p2，则：</p>
<script type="math/tex; mode=display">
d_{1}p_{1}=K_{1}P,d_{2}p_{2}=K_{2}(RP+t)</script><p>等号左边的p齐次坐标，如果对空间点也取齐次，即将空间点归一化到$Z=1$的平面，d就变成了1，上式变成：</p>
<script type="math/tex; mode=display">
p_{1}=K_{1}P,p_{2}=K_{2}(RP+t)</script><p>将矩阵K移到等号左边：</p>
<script type="math/tex; mode=display">
K_{1}^{-1}p_{1}=P,K_{2}^{-1}p_{2}=(RP+t)</script><p>设：</p>
<script type="math/tex; mode=display">
x_{1}=K_{1}^{-1}p_{1}=P,x_{2}=K_{2}^{-1}p_{2}=(RP+t) \tag{1}</script><p>则：</p>
<script type="math/tex; mode=display">
x_{2}=Rx_{1}+t</script><p>两边左叉乘 t ：</p>
<script type="math/tex; mode=display">
t\times x_{2}=t\times Rx_{1}+t\times t</script><p>其中，</p>
<script type="math/tex; mode=display">
t\times t=0</script><p>所以：</p>
<script type="math/tex; mode=display">
t\times x_{2}=t\times Rx_{1}</script><p>两边左乘$x_{2}^{\mathrm{T}}$：</p>
<script type="math/tex; mode=display">
x_{2}^{\mathrm{T}}t\times x_{2}=x_{2}^{\mathrm{T}}t\times Rx_{1} \tag{3}</script><p>左边显然等于0，则：</p>
<script type="math/tex; mode=display">
x_{2}^{\mathrm{T}}t\times Rx_{1}=0 \tag{2}</script><p>其中的$t\times R$就成为<strong>本质矩阵</strong>，用E表示：</p>
<script type="math/tex; mode=display">
E=t\times R</script><p>也可以记为：</p>
<script type="math/tex; mode=display">
E=t\verb!^!R</script><p>其中$t\verb!^!$为t的反对称矩阵。</p>
<p>将(1)式代入(2)式中，可得：</p>
<script type="math/tex; mode=display">
(K_{2}^{-1}p_{2})^{\mathrm{T}}t\verb!^!RK_{1}^{-1}p_{1}=0</script><p>即：</p>
<script type="math/tex; mode=display">
p_{2}^{\mathrm{T}}K_{2}^{\mathrm{-T}}t\verb!^!RK_{1}^{-1}p_{1}=0</script><p>其中的$K_{2}^{\mathrm{-T}}t\verb!^!RK_{1}^{-1}$称为<strong>基础矩阵</strong>，用F表示：</p>
<script type="math/tex; mode=display">
F=K_{2}^{\mathrm{-T}}t\verb!^!RK_{1}^{-1}</script><h3 id="单应性矩阵"><a href="#单应性矩阵" class="headerlink" title="单应性矩阵"></a>单应性矩阵</h3><p>直接将左视图像素坐标转换到右视图像素坐标。特定条件是<strong>同一平面</strong>。表达式：</p>
<script type="math/tex; mode=display">
p_{2}=Hp_{1},p_{1}=H^{-1}p_{2}</script><p>单应性矩阵不仅可以描述同一平面的像素点之间的关系，而且同一个平面在任意坐标系之间都可以建立单应性变换关系。比如影像坐标系与影像坐标系之间，世界坐标系和影像坐标系之间，如下图所示：</p>
<p><a href="https://imgtu.com/i/gYdxhT"><img src="https://z3.ax1x.com/2021/05/09/gYdxhT.png" alt="gYdxhT.png"></a></p>
<p>在双目立体视觉内，单应性变换是张式相机标定法的理论基础，纯平的标定板平面和影像平面存在单应性变换关系，同时它们存在世界坐标系到影像坐标系之间的投影变换关系，两个关系对等即可解出相机的内外参数。</p>
<p><a href="https://imgtu.com/i/gYwVN6"><img src="https://z3.ax1x.com/2021/05/09/gYwVN6.png" alt="gYwVN6.png"></a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/rs_lys/article/details/113854675?spm=1001.2014.3001.5501">立体视觉入门指南（2）：关键矩阵（本质矩阵，基础矩阵，单应矩阵）</a></p>
<p><a href="http://harrymei.github.io/2018/06/18/%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95%E7%9A%84%E7%90%86%E8%A7%A3/">对极几何的理解</a></p>
<hr>
<p>(3)式中</p>
<script type="math/tex; mode=display">
x_{2}^{\mathrm{T}}t\times x_{2}=0</script><p>是为什么呢？</p>
<ol>
<li>t叉乘x2的结果向量必定垂直于x2</li>
<li>x2的转置必定与这个结果向量垂直</li>
<li>所以结果为0</li>
</ol>
]]></content>
      <categories>
        <category>机器视觉</category>
      </categories>
  </entry>
  <entry>
    <title>相机的标定与矫正</title>
    <url>/20210504a7bce01e/</url>
    <content><![CDATA[<h1 id="相机的标定与矫正"><a href="#相机的标定与矫正" class="headerlink" title="相机的标定与矫正"></a>相机的标定与矫正</h1><p>在讲解什么是标定与矫正前，有必要梳理一下相机的成像原理。</p>
<p>相机是一个比较复杂的光学系统，但可以将其抽象为一个理想的几何模型：小孔成像</p>
<h2 id="成像原理"><a href="#成像原理" class="headerlink" title="成像原理"></a>成像原理</h2><p>光线经过一个光学系统，在成像元件上可以获得像。</p>
<h3 id="小孔成像"><a href="#小孔成像" class="headerlink" title="小孔成像"></a>小孔成像</h3><p><a href="https://imgtu.com/i/geqs2T"><img src="https://z3.ax1x.com/2021/05/03/geqs2T.png" alt="geqs2T.png"></a></p>
<script type="math/tex; mode=display">
\frac{U}{V}=\frac{W}{X}</script><p>因为小孔成像不能为CCD成像提供足够的光线，所以引入了透镜，从而汇集更多的光线，但这也带来了<strong>畸变</strong></p>
<h3 id="理想透镜成像1"><a href="#理想透镜成像1" class="headerlink" title="理想透镜成像1"></a>理想透镜成像<sup><a href="#fn_1" id="reffn_1">1</a></sup></h3><p><a href="https://imgtu.com/i/gY0maq"><img src="https://z3.ax1x.com/2021/05/09/gY0maq.jpg" alt="gY0maq.jpg"></a></p>
<script type="math/tex; mode=display">
\frac{1}{f}=\frac{1}{u}+\frac{1}{v}</script><h2 id="相机成像过程"><a href="#相机成像过程" class="headerlink" title="相机成像过程"></a>相机成像过程</h2><p>基于理想光学透镜的成像原理，再辅以四种坐标系的变换，现实世界中的物体就可以映射为图像了</p>
<h3 id="四大坐标系"><a href="#四大坐标系" class="headerlink" title="四大坐标系"></a>四大坐标系</h3><ol>
<li>世界坐标系：描述世界中物体位置的绝对坐标系</li>
<li>相机坐标系：以相机为原点建立的坐标系，单位为m</li>
<li>图像坐标系：光心对应图像上的点，以其为原点建立的坐标系</li>
<li>像素坐标系：图像的左上角为原点建立的坐标系</li>
</ol>
<h3 id="坐标系间的变换"><a href="#坐标系间的变换" class="headerlink" title="坐标系间的变换"></a>坐标系间的变换</h3><p>为了方便计算，引入了<a href="https://blog.csdn.net/baidu_38172402/article/details/89013617">齐次坐标</a></p>
<h4 id="世界坐标系→相机坐标系"><a href="#世界坐标系→相机坐标系" class="headerlink" title="世界坐标系→相机坐标系"></a>世界坐标系→相机坐标系</h4><p><a href="https://imgtu.com/i/gY00zD"><img src="https://z3.ax1x.com/2021/05/09/gY00zD.png" alt="gY00zD.png"></a></p>
<p>转换矩阵为：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
R & T\\ 
\vec{0} & 1
\end{bmatrix}</script><p>R为旋转矩阵，T为平移矩阵</p>
<h4 id="相机坐标系→图像坐标系"><a href="#相机坐标系→图像坐标系" class="headerlink" title="相机坐标系→图像坐标系"></a>相机坐标系→图像坐标系</h4><p><a href="https://imgtu.com/i/gY0got"><img src="https://z3.ax1x.com/2021/05/09/gY0got.png" alt="gY0got.png"></a></p>
<p>投影透视关系，从3D转换到2D，在这一过程中，深度信息丢失，怎么丢失的呢？</p>
<p>在投影透视关系中，物理世界中的一点在直线pP上时，都会被投影到图像上的同一点，二维的直线被压缩成了一维的点，在这个过程中，丢失了一个维度的信息。</p>
<p>观察这个计算：</p>
<script type="math/tex; mode=display">
Z_{C}\left[\begin{array}{l}
x \\
y \\
1
\end{array}\right]=\left[\begin{array}{llll}
f & 0 & 0 & 0 \\
0 & f & 0 & 0 \\
0 & 0 & 1 & 0
\end{array}\right]\left[\begin{array}{c}
X_{c} \\
Y_{c} \\
Z_{c} \\
1
\end{array}\right]</script><p>等号左边有一个公有系数Zc，移到等号右边，变为：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
x \\
y \\
1
\end{array}\right]=\left[\begin{array}{llll}
\frac{f}{Z_{C}} & 0 & 0 & 0 \\
0 & \frac{f}{Z_{C}} & 0 & 0 \\
0 & 0 & \frac{1}{Z_{C}} & 0
\end{array}\right]\left[\begin{array}{c}
X_{c} \\
Y_{c} \\
Z_{c} \\
1
\end{array}\right]</script><p>此时投影点p的单位还是mm，并不是pixel，需要进一步转换到像素坐标系。</p>
<h4 id="图像坐标系→像素坐标系"><a href="#图像坐标系→像素坐标系" class="headerlink" title="图像坐标系→像素坐标系"></a>图像坐标系→像素坐标系</h4><p><a href="https://imgtu.com/i/gY05Qg"><img src="https://z3.ax1x.com/2021/05/09/gY05Qg.png" alt="gY05Qg.png"></a></p>
<p>dx与dy分别表示每个像素在横轴x和纵轴y上的物理尺寸，单位为:毫米/像素。那么x/dx的单位就是像素了。即最后u与v的单位变成了像素。转换矩阵为：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{ccc}
\frac{1}{d x} & 0 & u_{0} \\
0 & \frac{1}{d y} & v_{0} \\
0 & 0 & 1
\end{array}\right]</script><h4 id="综上"><a href="#综上" class="headerlink" title="综上"></a>综上</h4><p>通过上面四个坐标系的转换就可以得到一个点从世界坐标系如何转换到像素坐标系</p>
<p><a href="https://imgtu.com/i/gY0oLj"><img src="https://z3.ax1x.com/2021/05/09/gY0oLj.png" alt="gY0oLj.png"></a></p>
<p>即：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{l}
u \\
v \\
1
\end{array}\right]=\frac{1}{Z_{C}} \times\left[\begin{array}{cccc}
\frac{f}{d x} & 0 & u_{0} & 0 \\
0 & \frac{f}{d x} & v_{0} & 0 \\
0 & 0 & 1 & 0
\end{array}\right] \times\left[\begin{array}{cc}
R & T \\
\overrightarrow{0} & 1
\end{array}\right] \times\left[\begin{array}{c}
X_{W} \\
Y_{W} \\
Z_{W} \\
1
\end{array}\right]</script><h2 id="相机标定2"><a href="#相机标定2" class="headerlink" title="相机标定2"></a>相机标定<sup><a href="#fn_2" id="reffn_2">2</a></sup></h2><blockquote>
<p>标定，主要是指使用标准的计量仪器对所使用仪器的准确度（精度）进行检测是否符合标准，一般大多用于精密度较高的仪器。标定也可以认为是校准。</p>
</blockquote>
<p>所以我理解，相机标定是<strong>校准相机</strong>，方便我们进行后边的工作。具体一点，害！还是求内参。</p>
<p>相机的标定原理是比较复杂的，如果想探寻原理，非<a href="https://ieeexplore.ieee.org/abstract/document/888718">张正友标定法</a>不看了，这里我只想追求结果，就先不看他了。</p>
<h3 id="用Matlab进行双目相机标定"><a href="#用Matlab进行双目相机标定" class="headerlink" title="用Matlab进行双目相机标定"></a>用Matlab进行双目相机标定</h3><p>具体操作看<a href="https://blog.csdn.net/weixin_43956351/article/details/94394892">这篇博客</a>，这里只对结果进行简单的分析</p>
<p><a href="https://imgtu.com/i/gml3FJ"><img src="https://z3.ax1x.com/2021/05/03/gml3FJ.png" alt="gml3FJ.png"></a></p>
<p>主要看这些参数：</p>
<p><a href="https://imgtu.com/i/gmlsfA"><img src="https://z3.ax1x.com/2021/05/03/gmlsfA.png" alt="gmlsfA.png"></a></p>
<p>内参矩阵：</p>
<p><a href="https://imgtu.com/i/gml5kQ"><img src="https://z3.ax1x.com/2021/05/03/gml5kQ.png" alt="gml5kQ.png"></a></p>
<p>这里的f也不是真的焦距，而是f/dx和f/dy；Matlab求出的内参矩阵是<strong>转置</strong>过的，在程序中使用时还需要再转置回去。</p>
<p>分析一下标定结果：</p>
<ol>
<li><p>图片分辨率为640*480，u0 = 264, v0 = 247，</p>
<p>u0,v0是图像中心点的坐标。而u0应该等于320，v0应该等于240，误差很大</p>
</li>
<li><p>“焦距”=518</p>
</li>
</ol>
<h2 id="畸变矫正"><a href="#畸变矫正" class="headerlink" title="畸变矫正"></a>畸变矫正</h2><p>之前在引入理想透镜成像中，我们引入了畸变，现在该解决畸变问题了，详细可看<a href="http://zhaoxuhui.top/blog/2018/04/17/CameraCalibration.html">这篇博客</a>的畸变部分的讲解。</p>
<p><a href="https://imgtu.com/i/gm1c4J"><img src="https://z3.ax1x.com/2021/05/03/gm1c4J.jpg" alt="gm1c4J.jpg"></a></p>
<ol>
<li>径向畸变：由于透镜的形状造成。对于透镜来说，远离透镜中心的光线比靠近透镜中心的光线更加弯曲。<br>eg：鱼眼畸变，桶形畸变</li>
<li>切向畸变：相机的组装造成。制造缺陷，透镜与成像平面不平行。感光元件CCD不是矩形，而是平行四边形</li>
</ol>
<p>解决畸变问题只需要在写程序时加载畸变参数就可以矫正图像了，Opencv也有相应的接口。</p>
<p>这里想注明一下参数<br><a href="https://imgtu.com/i/gm3uaF"><img src="https://z3.ax1x.com/2021/05/03/gm3uaF.png" alt="gm3uaF.png"></a></p>
<p>畸变参数的一般顺序是k1,k2,p1,p2,k3。之所以把k3放在最后其实也很容易理解，因为前面说了一般k1,k2用来处理径向畸变足矣，k3相对而言用的比较少。 在获得了畸变参数以后，也就找到了真实观测的带畸变的像素与无畸变的像素间的关系，重采样即可实现影像校正。</p>
<p>在这里径向畸变参数k1=0.2090, k2=-0.2842；切向畸变参数p1=0, p2=0。</p>
<blockquote id="fn_1">
<sup>1</sup>. 来自百度百科<a href="https://baike.baidu.com/item/%E6%88%90%E5%83%8F%E5%85%AC%E5%BC%8F">成像公式</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_2">
<sup>2</sup>. 到底什么是<a href="https://baike.baidu.com/item/%E6%A0%87%E5%AE%9A/304113">标定</a><a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
]]></content>
      <categories>
        <category>机器视觉</category>
      </categories>
  </entry>
  <entry>
    <title>记录在Ubuntu20.10上安装Steam</title>
    <url>/20210402d632b58c/</url>
    <content><![CDATA[<p>在之前在Ubuntu20.04上我就尝试安装过Steam，当时是可以正常安装的，不过当时还是双系统，现在已经完全使用Ubuntu了，只留了一个Windows10的虚拟机以备不时之需。昨天入坑了fpv，看的我也特别想玩儿，所以安装个Steam玩一玩模拟器先，没想到安装个Steam这么曲折，遂记录一下：</p>
<p>我首先在Steam官网下载了deb安装包，安装后有一些32位的库依赖一直安装不上，这个问题主要由以下方法解决：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install aptitude</span><br><span class="line">sudo aptitude installlibgl1-mesa-dri:i386 libgl1-mesa-glx:i386 libc6:i386</span><br><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>
<p>如此便可成功安装32位的库依赖，可以解决启动Steam时，缺少<code>libGL.so</code>等问题</p>
<p>接下来，我以为可以正常使用Steam了，没想到启动Steam时，总是闪退，经我查阅诸多资料，尝试了很多遍后，印证了一个问题：显卡驱动不合适(需要使用32位的驱动)。按照以下方法，对显卡驱动降级即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt purge $(dpkg -l | awk &#x27;&#123;print $2&#125;&#x27; | grep nvidia)    // 卸载原来的显卡驱动</span><br><span class="line">sudo apt-get install nvidia-driver-440 libnvidia-gl-440:i386  // 安装32位的显卡驱动</span><br><span class="line">reboot                                                        // 重启生效</span><br></pre></td></tr></table></figure>
<p>如此，即可搞定。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu安装配置Maven</title>
    <url>/202103254b45059f/</url>
    <content><![CDATA[<ol>
<li>安装Maven：<code>sudo apt install maven</code></li>
<li><code>mvn -v</code></li>
<li>运行<code>mvn help:system</code>，下载maven-help-plugin，包括pom文件和jar文件，下载到了本地仓库，打印出所有的Java系统属性和环境变量，在用户目录下会生成.m2目录。</li>
<li><code>cp /usr/share/maven/conf/settings.xml ~/.m2</code>，这是一条最佳实践。</li>
</ol>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu安装并配置Docker</title>
    <url>/202103233717081c/</url>
    <content><![CDATA[<h1 id="安装并配置docker"><a href="#安装并配置docker" class="headerlink" title="安装并配置docker"></a>安装并配置docker</h1><ol>
<li><p>安装：</p>
<ul>
<li><code>sudo snap install docker</code>，不推荐这个办法，因为无法浏览/var/lib/docker，不能好好研究Docker的工作原理</li>
<li><code>curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</code>，使用官方脚本安装，推荐。</li>
</ul>
</li>
<li><p>添加用户组，使用命令时无需使用sudo：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo groupadd docker                  # 添加docker用户组</span><br><span class="line">sudo gpasswd -a $wangtaocs docker     # 检测当前用户是否已经在docker用户组中</span><br><span class="line">sudo gpasswd -a $USER docker          # 将当前用户添加至docker用户组</span><br><span class="line">newgrp docker                         # 更新docker用户组</span><br><span class="line">sudo chmod a+rw /var/run/docker.sock  # 增加docker用户组读写权限</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果启用了防火墙：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/default/ufw             # 修改防火墙配置</span><br><span class="line">DEFAULT_FORWARD_POLICY=&quot;DROP&quot;         # 修改配置文件中的参数</span><br><span class="line">DEFAULT_FORWARD_POLICY=&quot;ACCEPT&quot;</span><br><span class="line">sudo ufw reload						  # 重新加载防火墙</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="Docker入门"><a href="#Docker入门" class="headerlink" title="Docker入门"></a>Docker入门</h1><ol>
<li><p>常用命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker info				   	# 显示系统范围信息</span><br><span class="line">docker run					# 创建并运行容器</span><br><span class="line">docker create				# 创建容器但不运行</span><br><span class="line">docker ps -a			   	# 查看所有容器列表</span><br><span class="line">docker ps				   	# 查看正在运行的容器列表</span><br><span class="line">docker start container     	# 启动名为container的容器</span><br><span class="line">docker start containerID   	# 启动ID为container_ID的容器</span><br><span class="line">docker attach container	   	# 重新附着到该容器的会话上,如果其有一个会话</span><br><span class="line">docker logs container	   	# 获取容器的日志</span><br><span class="line">docker top container	   	# 查看容器中的进程</span><br><span class="line">docker stats container1 container2		# 查看一个或多个守护式容器的统计信息，快速监控主机上的一组容器</span><br><span class="line">docker exec 				# 在容器内部运行进程</span><br><span class="line">docker stop container		# 停止守护进程</span><br><span class="line">docker inspect container	# 显示容器的详细信息</span><br><span class="line">docker rm containerID		# 删除ID为containerID的容器</span><br></pre></td></tr></table></figure>
</li>
<li><p>没有删除全部容器的命令，可以巧用以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm `sudo docker ps -a -q`</span><br></pre></td></tr></table></figure>
<p>上面的<code>docker ps</code>命令会列出现有的全部容器,-a标志代表列出所有容器,而-q标志则表示只需要返回容器的ID而不会返回容器的其他信息。这样我们就得到了容器ID的列表,并传给了docker rm命令,从而达到删除所有容器的目的。</p>
</li>
</ol>
<h1 id="使用Docker镜像和仓库"><a href="#使用Docker镜像和仓库" class="headerlink" title="使用Docker镜像和仓库"></a>使用Docker镜像和仓库</h1><ol>
<li><p>常用命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull					# 拉取镜像</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="实战部署一个mysql5-7容器"><a href="#实战部署一个mysql5-7容器" class="headerlink" title="实战部署一个mysql5.7容器"></a>实战部署一个mysql5.7容器</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.7			# 拉取镜像</span><br><span class="line">docker run --name mysql5.7 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7		# 部署镜像</span><br><span class="line">docker ps						# 查看镜像运行情况</span><br><span class="line">docker exec -it mysql5.7 bash	# 运行一个bash与mysql交互</span><br></pre></td></tr></table></figure>
<p>可在<code>/etc/mysql/my.cnf</code>编辑配置mysql的配置文件</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>53.最大子序和</title>
    <url>/20210310396fd427/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [0]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [-1]</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>
<p><strong>示例 5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [-100000]</span><br><span class="line">输出：-100000</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3 * 10^4</code></li>
<li><code>-10^5 &lt;= nums[i] &lt;= 10^5</code></li>
</ul>
<p><strong>进阶：</strong>如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>没有很好的思路，参考的官方题解……</p>
<p>思路大概是这样：把数组的第一个元素先当做最大和，然后开始遍历数组，如果当前指针的前一个数字大于零，则将它加到现在指针所指向的值；否则不对数组做任何更新操作。然后取出数组中的最大元素并返回。</p>
<p>我理解为：在遍历过程中，正数是有益于寻找最大和的，所以遇到正数时，就将其进行向后累加；而遇到负数时，其对结果是不利的，所以会到此为止。<br>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原序列</span></span><br><span class="line">nums = [-<span class="number">2</span>,<span class="number">1</span>,-<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line"><span class="comment">//遍历后的序列</span></span><br><span class="line">nums = [-<span class="number">2</span>,<span class="number">1</span>,-<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p>遍历后的序列上的每一位数字表示当前位置具有的连续子数组最大和。所以返回整个数组的最大值即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxRes = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)</span><br><span class="line">            <span class="keyword">if</span>(nums[i - <span class="number">1</span>] &gt; <span class="number">0</span>)</span><br><span class="line">                nums[i] += nums[i - <span class="number">1</span>];</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我的题解：时间复杂度：O(2n); 空间复杂度：O(1)</p>
<hr>
<p>官方的题解是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, maxAns = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            pre = Math.max(pre + x, x);</span><br><span class="line">            maxAns = Math.max(maxAns, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxAns;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>官方题解的巧妙之处在于，在遍历数组的时，同时做了两件事：1.使用pre指针更新数组；2.使用maxAns一直指向更新数组的最大值，最后直接返回maxAns即可。</p>
<p>时间复杂度：O(n); 空间复杂度：O(1)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>dynamic-programming</tag>
        <tag>divide-and-conquer</tag>
      </tags>
  </entry>
  <entry>
    <title>C程序编译执行过程</title>
    <url>/20210307639039ec/</url>
    <content><![CDATA[<p>最近在看CSAPP（Computer System: A Programmer’s Perspective, 深入理解计算机系统），看到第三章 程序的机器级表示，第二节讲了一下C程序的编译执行过程，以前在《C Primer Plus》上也看到过类似的内容，感觉比较有意思，遂记录一下。</p>
<p>源文件只是以字节序列的形式存储在磁盘上，它是如何运行在机器上的呢？</p>
<p>源文件会经历以下历程：</p>
<ol>
<li><p><strong>预处理（Preprocessing）</strong>：将#include等头文件进行置换，形成完整的程序文件，一般预处理后，文件会变大。得到的是文本文件。<br>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// preprocessing.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = PI;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>gcc -E preprocessing.c -o preprocessing.i</code>预编译后：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// preprocessing.i</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;preprocessing.c&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"># <span class="number">31</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/stdc-predef.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">32</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;preprocessing.c&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>int a = PI;</code>被宏定义的PI值进行了替换。</p>
</li>
<li><p><strong>编译（Compilation）</strong>：使用编译器，将完整的C代码编译成汇编代码。得到的仍然是文本文件。<br>以3.2.2的程序为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mstore.c</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">mult2</span><span class="params">(<span class="keyword">long</span>, <span class="keyword">long</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multstore</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> y, <span class="keyword">long</span> *dest)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> t = mult2(x, y);</span><br><span class="line">    *dest = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>gcc -S mstore.i -o mstore.s</code>进行编译后：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">	.file</span>	<span class="string">&quot;mstore.c&quot;</span></span><br><span class="line"><span class="meta">	.text</span></span><br><span class="line"><span class="meta">	.globl</span>	multstore</span><br><span class="line"><span class="meta">	.type</span>	multstore, @function</span><br><span class="line"><span class="symbol">multstore:</span></span><br><span class="line"><span class="symbol">.LFB0:</span></span><br><span class="line"><span class="meta">	.cfi_startproc</span></span><br><span class="line">	endbr64</span><br><span class="line">	pushq	%rbx</span><br><span class="line"><span class="meta">	.cfi_def_cfa_offset</span> <span class="number">16</span></span><br><span class="line"><span class="meta">	.cfi_offset</span> <span class="number">3</span>, -<span class="number">16</span></span><br><span class="line">	<span class="keyword">movq</span>	%rdx, %rbx</span><br><span class="line">	<span class="keyword">call</span>	mult2@PLT</span><br><span class="line">	<span class="keyword">movq</span>	%rax, (%rbx)</span><br><span class="line">	popq	%rbx</span><br><span class="line"><span class="meta">	.cfi_def_cfa_offset</span> <span class="number">8</span></span><br><span class="line">	<span class="keyword">ret</span></span><br><span class="line"><span class="meta">	.cfi_endproc</span></span><br><span class="line"><span class="symbol">.LFE0:</span></span><br><span class="line"><span class="meta">	.size</span>	multstore, .-multstore</span><br><span class="line"><span class="meta">	.ident</span>	<span class="string">&quot;GCC: (Ubuntu 10.2.0-13ubuntu1) 10.2.0&quot;</span></span><br><span class="line"><span class="meta">	.section</span>	.note<span class="number">.</span>GNU-stack,<span class="string">&quot;&quot;</span>,@progbits</span><br><span class="line"><span class="meta">	.section</span>	.note<span class="number">.</span>gnu<span class="number">.</span>property,<span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="meta">	.align</span> <span class="number">8</span></span><br><span class="line"><span class="meta">	.long</span>	 1f - 0f</span><br><span class="line"><span class="meta">	.long</span>	 4f - 1f</span><br><span class="line"><span class="meta">	.long</span>	 <span class="number">5</span></span><br><span class="line"><span class="number">0</span>:</span><br><span class="line"><span class="meta">	.string</span>	 <span class="string">&quot;GNU&quot;</span></span><br><span class="line"><span class="number">1</span>:</span><br><span class="line"><span class="meta">	.align</span> <span class="number">8</span></span><br><span class="line"><span class="meta">	.long</span>	 <span class="number">0xc0000002</span></span><br><span class="line"><span class="meta">	.long</span>	 3f - 2f</span><br><span class="line"><span class="number">2</span>:</span><br><span class="line"><span class="meta">	.long</span>	 <span class="number">0x3</span></span><br><span class="line"><span class="number">3</span>:</span><br><span class="line"><span class="meta">	.align</span> <span class="number">8</span></span><br><span class="line"><span class="number">4</span>:</span><br></pre></td></tr></table></figure>
<p>以“.”开头的都是指导汇编器和链接器工作的伪指令，可以忽略。</p>
</li>
<li><p><strong>汇编（Assemble）</strong>：将汇编代码转换成机器代码，得到的是二进制的目标文件。<br>使用<code>gcc -c mstore.s -o mstore.o</code>进行汇编；因为二进制文件无法直接查看，因此可以使用<code>objdump -d mstore.o</code>反汇编进行查看：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">mstore<span class="number">.</span>o：     文件格式 elf64-x86-<span class="number">64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of <span class="meta">section</span> .text:</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000000</span> &lt;multstore&gt;:</span><br><span class="line">   <span class="number">0</span>:	f3 0f 1e fa          	endbr64 </span><br><span class="line">   <span class="number">4</span>:	<span class="number">53</span>                   	<span class="keyword">push</span>   %rbx</span><br><span class="line">   <span class="number">5</span>:	<span class="number">48</span> <span class="number">89</span> d3             	<span class="keyword">mov</span>    %rdx,%rbx</span><br><span class="line">   <span class="number">8</span>:	e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	callq  d &lt;multstore+<span class="number">0xd</span>&gt;</span><br><span class="line"><span class="symbol">   d:</span>	<span class="number">48</span> <span class="number">89</span> <span class="number">03</span>             	<span class="keyword">mov</span>    %rax,(%rbx)</span><br><span class="line">  <span class="number">10</span>:	5b                   	<span class="keyword">pop</span>    %rbx</span><br><span class="line">  <span class="number">11</span>:	c3                   	retq   </span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>链接（Linking）</strong>：链接多个目标文件以及库文件等，最终得到可执行文件。</p>
</li>
</ol>
<p>总结这些只是为了了解C代码是如何变成机器代码，并最终被CPU执行的。当然我可以一步到位，直接由C代码得到可执行程序：<br><code>gcc mstore.c -o mstore</code></p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
  </entry>
  <entry>
    <title>搭建个人家庭服务器</title>
    <url>/20210228a4ca4f79/</url>
    <content><![CDATA[<p>前几天我从回收站捡了回垃圾，并安装了CentOS系统，今天就利用我的家庭网络，搭建一个个人服务器。</p>
<h1 id="1-申请公网ip"><a href="#1-申请公网ip" class="headerlink" title="1.申请公网ip"></a>1.申请公网ip</h1><p>我家里是200M电信宽带，去网上查了下，电信可以申请公网ip，这样可以省下很大一部分精力搞内网穿透。至于怎么申请，可以采用一些话术，比如说家里要装监控，需要公网ip，或者什么也不说，就直接申请，千万不要说家里要部署服务器，至于为啥，我也不知道，广大网友都是这么说的，反正搞到公网ip就行了。</p>
<p>这里想插一嘴，公网ip其实也不是永远固定的，经过我几天的折腾我发现每次重启光猫后，指定的公网ip都会变化，那为什么还叫公网ip呢，我理解是每次光猫与电信机房建立连接时，机房都会分配一个ip给我的光猫，只要这个连接不中断，我就会一直占有这个ip，别人就可以从公网ping到我，而当我与机房的连接中断时，机房就会将这个ip地址收回，就像java的垃圾回收一样，这个ip地址下次就会分配给别的光猫。只有专线才是固定的，永远不会变，但是很贵。还有一点，只有下行带宽是200M，上行带宽我测了一下，只有50M。</p>
<h1 id="2-转发"><a href="#2-转发" class="headerlink" title="2.转发"></a>2.转发</h1><p>这里我其实踩了很多坑，其实有了公网ip后，应该明白的一点就是，怎么做路由，怎么让request发送到指定的物理机。</p>
<p>这里还是有必要再提一下电信的宽带，当申请到公网ip后，这个ip是与这条接到光猫上的宽带绑定的，电信的光猫对外有拨号上网的功能，对内有路由的功能，网上很多思路都是进入光猫的超级管理员模式，将接在光猫上的服务器做桥接，或是更暴力一点，直接搞DMZ主机（我简单了解了一下DMZ，这个会把服务器的所有端口暴露在外，响应所有请求，不太安全）。我进行了以下尝试：</p>
<ol>
<li>进入光猫的超级管理员模式，用户名为<code>telecomadmin</code>，密码是<code>nE7jA%5m</code>，这里看别人居然还需要抓包破解啥的，但我偶然遇到一个帖子，说可以试试这个密码，没想到还真的可以。进入到超级管理员模式后，我试着进行桥接，但不幸的是，我的光猫无法联网了，最终我不小心删除了光猫的拨号上网的配置文件，导致我不得不联系维修人员，在获得了拨号上网的逻辑ID后，我才又连上了网，但此时光猫已经被我使用超级管理员权限复位好几回了……</li>
<li>既然桥接失败了，那只能考虑转发了。我又一次进入了光猫的后台，只不过是普通用户模式，我偶然发现了，电信的光猫可以做端口映射，很简单，照着填就可以了。我在网上查了一下，很多人都说不起作用，但我还是试了试，没想到还真的成功了。</li>
</ol>
<p>至此，我的家庭服务器就搭建好了。</p>
<h1 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h1><p>那怎么测试呢，ping一下？不行，就算不做端口映射，也能ping成功，因为光猫也会响应。所以我在服务器上安装了ssh服务，用我的ubuntu进行远程登录。</p>
<ol>
<li>在服务器端（CentOS）安装openssh-server服务</li>
<li>在ubuntu上安装openssh客户端</li>
</ol>
<p>用电脑连接手机热点，确保请求是从公网发起的，然后用ssh连接服务器，连上就说明成功了。</p>
<hr>
<p>下一次尝试，将个人博客部署在服务器上，就真的说明能用了。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>物理机安装CentOS</title>
    <url>/202102223d55054c/</url>
    <content><![CDATA[<p>记一次捡垃圾之旅。<br>一直想在家里装个NAS，利用起来闲置的带宽，但是蜗牛星际这种矿渣都开始有奸商开始抄了，本来只需不到300块钱就能搞一个，后来快四百了，这还不包括硬盘，在家里装个2T的NAS的话，得七百多块钱了，性价比就不高了。后来看着看着就看垃圾佬捡垃圾的视频了，一时兴起，昨天我就真的去回收站捡垃圾去了，还真让我捡了个，花了50块钱，捡垃圾真香！</p>
<p>下面展示一下具体配置：<br>CPU：AMD Athlon Ⅱ X2 245<br>内存：DDR3  2GB<br>硬盘：东芝500GB 7200r</p>
<hr>
<p>本来想装个黑群晖的，后来又想把这个当服务器了，遂想装个CentOS，搞了两个晚上才搞好，主要是卡在装网卡驱动上了，记录一下：</p>
<p>我本来想着装个Server版本的，因为内存只有两个G，但是装好了一直连不上网，我还以为是我装的Minimal版的原因，所以又装了GUI版的，发现还是不行，后来查了半天资料，哦，才想到网卡是没驱动，所以一直看着没网卡。</p>
<p>接下来主要就是搞定网卡，连上网。主要参考了这篇博客：<a href="https://blog.csdn.net/justcyf/article/details/52453868">https://blog.csdn.net/justcyf/article/details/52453868</a></p>
<ol>
<li><p>查看设备信息，确定自己网卡型号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lspci -nn | grep -i net</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载驱动<br>下载驱动的地址：<a href="https://mirror.imt-systems.com/elrepo/archive/elrepo/el7/x86_64/RPMS/">https://mirror.imt-systems.com/elrepo/archive/elrepo/el7/x86_64/RPMS/</a></p>
<p>先查看内核版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure>
<p>然后找对应内核的驱动，这里博主也没说怎么对应的，我就把找到的4个版本的驱动都试了一遍，最后一遍才成功……成功的时候会显示Done！</p>
</li>
<li><p>安装驱动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su rpm -ivh kmod-forcedeth-0.64-1.el7.elrepo.x86_64.rpm </span><br></pre></td></tr></table></figure>
</li>
<li><p>启动服务<br>先查看哪些服务在运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsmod | grep forcedeth</span><br></pre></td></tr></table></figure>
<p>没反应就是啥也没启动。<br>激活驱动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">modprobe forcedeth</span><br></pre></td></tr></table></figure>
<p>然后就可以看到forcedeth了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsmod | grep forcedeth</span><br><span class="line">forcedeth              71574  0 </span><br></pre></td></tr></table></figure>
</li>
<li><p>再<code>ifconfig</code>就能看到网卡了</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>MyBatis Generator的使用</title>
    <url>/20210205c5aa4d75/</url>
    <content><![CDATA[<p>使用MyBatis Generator(MBG)可以自动生成model层中的对象，并可根据数据库中的表字段，自动生成Getter和Setter，还可以自定义生成其他的方法，例如：toString()方法等。当数据库中有多张表时，使用MBG可以自动生成对象，免去编写大量重复的代码。</p>
<p>下面简单的记录MBG的使用：</p>
<h1 id="设计数据库表"><a href="#设计数据库表" class="headerlink" title="设计数据库表"></a>设计数据库表</h1><p>新建一个数据库<code>mbg_test</code>，使用Navicat设计两张数据库表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Navicat MySQL Data Transfer</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Source Server         : root</span></span><br><span class="line"><span class="comment">Source Server Version : 50733</span></span><br><span class="line"><span class="comment">Source Host           : localhost:3306</span></span><br><span class="line"><span class="comment">Source Database       : mbg_test</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Target Server Type    : MYSQL</span></span><br><span class="line"><span class="comment">Target Server Version : 50733</span></span><br><span class="line"><span class="comment">File Encoding         : 65001</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Date: 2021-02-05 21:18:17</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for product</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`product`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`product`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`title`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`price`</span> <span class="built_in">decimal</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`create_time`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="string">`update_time`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for user</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`user`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`password`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`create_time`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="string">`update_time`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>
<h1 id="新建Maven工程"><a href="#新建Maven工程" class="headerlink" title="新建Maven工程"></a>新建Maven工程</h1><ol>
<li><p>向<code>pom.xml</code>中添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.38<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- MyBatis 生成器 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>搭建项目结构：<br><a href="https://imgchr.com/i/yJUTfg"><img src="https://s3.ax1x.com/2021/02/05/yJUTfg.png" alt="yJUTfg.png" style="zoom:50%;" /></a></p>
</li>
<li><p>新建并编辑<code>generatorConfig.xml</code>文件：<br>具体的标签配置可以参照《MyBatis从入门到精通》的 5.1 XML配置详解</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;MySqlContext&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3&quot;</span> <span class="attr">defaultModelType</span>=<span class="string">&quot;flat&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;beginningDelimiter&quot;</span> <span class="attr">value</span>=<span class="string">&quot;`&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;endingDelimiter&quot;</span> <span class="attr">value</span>=<span class="string">&quot;`&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;javaFileEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--可以自定义生成model的代码注释--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">commentGenerator</span> <span class="attr">type</span>=<span class="string">&quot;com.mybatis.demo.mbg.CommentGenerator&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suppressDate&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;addRemarkComments&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置数据库连接--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mbg_test?useSSL=false&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定生成model的路径--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.mybatis.demo.mbg.model&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定生成mapper.xml的路径, windows中使用 &quot;\&quot;, 类Unix使用 &quot;/&quot;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.mybatis.demo.mbg.mapper&quot;</span>  <span class="attr">targetProject</span>=<span class="string">&quot;src/main/resources&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定生成mapper接口的的路径--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.mybatis.demo.mbg.mapper&quot;</span>  <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--生成全部表tableName设为%--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;%&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generatedKey</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">sqlStatement</span>=<span class="string">&quot;MySql&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>新建并编辑<code>Generator.java</code>文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mybatis.demo.mbg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wangtao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 0.1 2021-02-05 21:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.api.MyBatisGenerator;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.config.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.config.xml.ConfigurationParser;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.internal.DefaultShellCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//MBG 执行过程中的警告信息</span></span><br><span class="line">        List&lt;String&gt; warnings = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">//当生成的代码重复时，覆盖原代码</span></span><br><span class="line">        <span class="keyword">boolean</span> overwrite = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//读取我们的 MBG 配置文件</span></span><br><span class="line">        InputStream is = Generator.class.getResourceAsStream(<span class="string">&quot;/generator/generatorConfig.xml&quot;</span>);</span><br><span class="line">        ConfigurationParser cp = <span class="keyword">new</span> ConfigurationParser(warnings);</span><br><span class="line">        Configuration config = cp.parseConfiguration(is);</span><br><span class="line">        is.close();</span><br><span class="line"></span><br><span class="line">        DefaultShellCallback callback = <span class="keyword">new</span> DefaultShellCallback(overwrite);</span><br><span class="line">        <span class="comment">//创建 MBG</span></span><br><span class="line">        MyBatisGenerator myBatisGenerator = <span class="keyword">new</span> MyBatisGenerator(config, callback, warnings);</span><br><span class="line">        <span class="comment">//执行生成代码</span></span><br><span class="line">        myBatisGenerator.generate(<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//输出警告信息</span></span><br><span class="line">        <span class="keyword">for</span>(String warning : warnings)&#123;</span><br><span class="line">            System.out.println(warning);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建并编辑<code>CommentGenerator.java</code>文件，以生成文档注释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mybatis.demo.mbg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.api.IntrospectedColumn;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.api.IntrospectedTable;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.api.dom.java.Field;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.internal.DefaultCommentGenerator;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.internal.util.StringUtility;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义注释生成器</span></span><br><span class="line"><span class="comment"> * Created by macro on 2018/4/26.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommentGenerator</span> <span class="keyword">extends</span> <span class="title">DefaultCommentGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> addRemarkComments = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置用户配置的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addConfigurationProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.addConfigurationProperties(properties);</span><br><span class="line">        <span class="keyword">this</span>.addRemarkComments = StringUtility.isTrue(properties.getProperty(<span class="string">&quot;addRemarkComments&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给字段添加注释</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFieldComment</span><span class="params">(Field field, IntrospectedTable introspectedTable,</span></span></span><br><span class="line"><span class="function"><span class="params">                                IntrospectedColumn introspectedColumn)</span> </span>&#123;</span><br><span class="line">        String remarks = introspectedColumn.getRemarks();</span><br><span class="line">        <span class="comment">//根据参数和备注信息判断是否添加备注信息</span></span><br><span class="line">        <span class="keyword">if</span> (addRemarkComments &amp;&amp; StringUtility.stringHasValue(remarks)) &#123;</span><br><span class="line">            addFieldJavaDoc(field, remarks);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给model的字段添加注释</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addFieldJavaDoc</span><span class="params">(Field field, String remarks)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//文档注释开始</span></span><br><span class="line">        field.addJavaDocLine(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">        <span class="comment">//获取数据库字段的备注信息</span></span><br><span class="line">        String[] remarkLines = remarks.split(System.getProperty(<span class="string">&quot;line.separator&quot;</span>));</span><br><span class="line">        <span class="keyword">for</span> (String remarkLine : remarkLines) &#123;</span><br><span class="line">            field.addJavaDocLine(<span class="string">&quot; * &quot;</span> + remarkLine);</span><br><span class="line">        &#125;</span><br><span class="line">        addJavadocTag(field, <span class="keyword">false</span>);</span><br><span class="line">        field.addJavaDocLine(<span class="string">&quot; */&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行<code>Generator.java</code>，即可生成对应数据库表的model、Mapper接口、mapper.xml映射文件。</p>
</li>
</ol>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>创建并编辑<code>UserMapperTest.java</code>，用来测试接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mybatis.demo.mbg.mapper;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wangtao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 0.1 2021-02-05 22:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Reader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.junit.BeforeClass;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mybatis.demo.mbg.model.User;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeClass</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Reader reader = Resources.getResourceAsReader(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(reader);</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ignore) &#123;</span><br><span class="line">            ignore.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectByPrimaryKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取 sqlSession</span></span><br><span class="line">        SqlSession sqlSession = getSqlSession();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取 UserMapper 接口</span></span><br><span class="line">            UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">            <span class="comment">//调用 selectByPrimaryKey 方法，查询 id = 1 的用户</span></span><br><span class="line">            User user = userMapper.selectByPrimaryKey(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//不要忘记关闭 sqlSession</span></span><br><span class="line">            sqlSession.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>能查到数据库中的数据，表明MBG成功了</p>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu20.10安装配置maven</title>
    <url>/2021020164b72101/</url>
    <content><![CDATA[<ol>
<li><p>下载maven：<br><a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a></p>
</li>
<li><p>解压到/opt文件夹下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-maven-3.6.3-bin.tar.gz -C /opt</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置环境变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br></pre></td></tr></table></figure>
<p>将以下内容追加到文件中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">set</span> Maven environment</span></span><br><span class="line">export M2_HOME=/opt/apache-maven</span><br><span class="line">export PATH=$M2_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>更新源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看maven版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn -v</span><br></pre></td></tr></table></figure>
<p>检查不报错，即为安装成功。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu20.10安装并配置mysql</title>
    <url>/20210131ee667999/</url>
    <content><![CDATA[<h1 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h1><p><a href="https://blog.csdn.net/liang19890820/article/details/105071479">https://blog.csdn.net/liang19890820/article/details/105071479</a></p>
<ol>
<li><p>使用命令行安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install mysql-server</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置mysql密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mysql_secure_installation</span><br></pre></td></tr></table></figure>
</li>
<li><p>允许本地root直连<br>进入mysql配置界面：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mysql</span><br></pre></td></tr></table></figure>
<p>将认证方式改为密码登录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED WITH mysql_native_password BY <span class="string">&#x27;123456&#x27;</span>;</span></span><br></pre></td></tr></table></figure>
<p>查看用户登录方式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT user, authentication_string, plugin, host FROM mysql.user;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>退出mysql</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; exit</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这样就可以登录mysql了：<code>mysql -uroot -p</code></p>
<h1 id="安装一个mysql图形化界面"><a href="#安装一个mysql图形化界面" class="headerlink" title="安装一个mysql图形化界面"></a>安装一个mysql图形化界面</h1><p>我选择了mysql-workbench，因为开源免费</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">snap install mysql-workbench-community</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux目录配置的依据——FHS</title>
    <url>/20210119786270d3/</url>
    <content><![CDATA[<p>今天读到了<strong>《鸟哥的LINUX的私房菜》</strong>的<strong>5.3.1 Linux目录配置的依据——FHS</strong>，终于以解我用了半年多Ubuntu以来，对根目录下各个文件夹的内容的一些疑惑，遂写一篇博客用来记录一下。我只是简单介绍一下，如果有深究的需要，那么就去看原书吧。</p>
<p>Filesystem Hierarchy Standard (FHS)：文件系统层次结构标准，有了这个标准就可以对很多系统文件进行规范分类了。</p>
<p><a href="https://imgchr.com/i/s2m00K"><img src="https://s3.ax1x.com/2021/01/19/s2m00K.png" alt="s2m00K.png" style="zoom:50%;" /></a></p>
<p>接下来，我逐一说明一下，各文件夹都是什么</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>目录</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>/bin</td>
<td>主要是很多能被执行的命令，例如：ls，cat等等，这是个链接文件，链接的是：/usr/bin</td>
</tr>
<tr>
<td>/boot</td>
<td>启动文件</td>
</tr>
<tr>
<td>/cdrom</td>
<td>光驱cd中的文件，如果电脑没光驱，这个文件夹中就不会有文件，鸟哥的书中，根目录下并没有这个文件夹，可能是Ubuntu做了一些改变</td>
</tr>
<tr>
<td>/dev</td>
<td>设备文件，是device的缩写，</td>
</tr>
<tr>
<td>/etc</td>
<td>配置文件，这不是个单词的缩写，而是and so on等等的缩写=etc，意为一些零碎的东西</td>
</tr>
<tr>
<td>/home</td>
<td>家目录，这个应该不陌生，每个用户都会有一个自己的/home</td>
</tr>
<tr>
<td>/lib<br/>lib32<br/>/lib64<br/>/libx32</td>
<td>均为链接文件，链接的是/usr下的对应文件，实际意义均是函数库文件</td>
</tr>
<tr>
<td>/lost+found</td>
<td>当文件系统发生错误时, 将一些遗失的片段放置到这个目录下</td>
</tr>
<tr>
<td>/media</td>
<td>多媒体文件，可删除的设备</td>
</tr>
<tr>
<td>/mnt</td>
<td>临时挂载的设备，与/media功能相同</td>
</tr>
<tr>
<td>/opt</td>
<td>第三方软件的存放目录，是option的缩写</td>
</tr>
<tr>
<td>/proc</td>
<td>这个目录是一个虚拟文件系统，查看属性的确是不占任何硬盘空间，大小是0bytes</td>
</tr>
<tr>
<td>/root</td>
<td>root用户的家目录</td>
</tr>
<tr>
<td>/run</td>
<td>系统启动后产生的各种信息的存放位置，可用内存模拟</td>
</tr>
<tr>
<td>/sbin</td>
<td>链接到/usr中对应文件，也是一些能执行的命令，但可能没有/bin中的的命令重要</td>
</tr>
<tr>
<td>/snap</td>
<td>Ubuntu自带的商店</td>
</tr>
<tr>
<td>/srv</td>
<td>网络服务所要使用的数据文件，是service的缩写</td>
</tr>
<tr>
<td>/tmp</td>
<td>一般用户执行文件程序暂时存放文件的地方，</td>
</tr>
<tr>
<td>/usr</td>
<td>这个最有意思了，我一直以为是user的缩写，原来是unix software resource的缩写，见名知意，就是UNIX系统软件存放资源的地方，因为Linux是类UNIX的嘛（/usr≈Windows中的“C:\Windows (当中的一部份) + C:\Program files\”这两个目录的综合体）</td>
</tr>
<tr>
<td>/var</td>
<td>经常性变动的文件，包括缓存、日志以及某些软件运行产生的文件，包括程序文件(lock file, run file),或者例如 MySQL数据库的文件等等，是varible的缩写吧</td>
</tr>
</tbody>
</table>
</div>
<p>所以，一般我们要动的文件夹主要是：</p>
<ul>
<li>/etc，因为我们经常需要配置点东西</li>
<li>/home，我们自己的文件都放在这，当然经常访问了</li>
<li>/mnt，我的Ubuntu桌面版上所有的硬盘都挂载在这里了</li>
<li>/opt，我们自己安装点文件，得放在这吧</li>
</ul>
<p>别的可能就不经常动了，如果需要动，那可就要小心了。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu的小记</title>
    <url>/202011291c7300b7/</url>
    <content><![CDATA[<ol>
<li><p>新版应用商店安装:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt intall gnome-software</span><br></pre></td></tr></table></figure>
<p><a href="https://imgchr.com/i/Dc8PIg"><img src="https://s3.ax1x.com/2020/11/29/Dc8PIg.png" alt="Dc8PIg.png"></a></p>
<p>左边的叫gnome-software;右边的叫software-center;都不好用,连vscode都搜不到,不过左边的还能浏览一点,右边的什么都加载不出来</p>
</li>
<li><p>安装java开发环境：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这个安装的是open-jdk</span></span><br><span class="line">sudo apt install default-jre</span><br><span class="line">sudo apt install default-jdk</span><br><span class="line">java --version</span><br></pre></td></tr></table></figure>
<p>啊！Linux也太方便了。</p>
<hr>
<p>安装oracle-jdk比较麻烦</p>
<p>法一：<a href="https://jingyan.baidu.com/article/25648fc1797a649191fd00ca.html">https://jingyan.baidu.com/article/25648fc1797a649191fd00ca.html</a></p>
<p>法二：（我的电脑不管用）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加java源</span></span><br><span class="line">sudo add-apt-repository ppa:linuxuprising/java</span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新源</span></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install oracle-java15-installer</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>appImageLauncher使用教程</title>
    <url>/202011267ca87167/</url>
    <content><![CDATA[<p>appimage格式的文件类似于windows上的绿色免安装版软件,安装appImageLauncher可以管理这些应用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装appImageLauncher</span></span><br><span class="line">sudo add-apt-repository ppa:appimagelauncher-team/stable</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install appimagelauncher</span><br></pre></td></tr></table></figure>
<p>创建/home/Applications/文件夹,集中管理appimage文件:<br><a href="https://imgchr.com/i/DBKxZq"><img src="https://s3.ax1x.com/2020/11/26/DBKxZq.png" alt="DBKxZq.png"></a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 给予最高权限</span></span><br><span class="line">sudo chmod a+x Motrix.appimage</span><br></pre></td></tr></table></figure>
<p>双击运行后,就可以在菜单中看到app了</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>在Ubuntu上自动挂载NTFS,并读写</title>
    <url>/20201126eacca14f/</url>
    <content><![CDATA[<h1 id="自动挂载的姿势之一"><a href="#自动挂载的姿势之一" class="headerlink" title="自动挂载的姿势之一"></a>自动挂载的姿势之一</h1><p>我的电脑安装了双系统,HDD在Ubuntu中使用磁盘工具自动开机挂载没有写入权限,操作起来很不方便,使用以下方法解决:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看所有的HDD分区</span></span><br><span class="line">sudo fdisk -l</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修复磁盘分区</span></span><br><span class="line">sudo ntfsfix /dev/sdb1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以读写权限挂载磁盘</span></span><br><span class="line">sudo mount -o rw /dev/sda1 /mnt/Data/</span><br><span class="line">sudo mount -o rw /dev/sda2 /mnt/Entertainment/</span><br><span class="line">sudo mount -o rw /dev/sda3 /mnt/Learn/</span><br></pre></td></tr></table></figure>
<p>如果还是不行,请赋予/mnt中的文件夹最高的权限</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo chmod 777 /mnt/Data/</span><br><span class="line">sudo chmod 777 /mnt/Entertainment/</span><br><span class="line">sudo chmod 777 /mnt/Learn/</span><br></pre></td></tr></table></figure>
<p>使用开机脚本将分区自动挂载</p>
<p>在/home中创建一个脚本<code>automount-rw.sh</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> automount-rw.sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> auto mount NTFS <span class="string">&#x27;ro&#x27;</span> -&gt; <span class="string">&#x27;rw&#x27;</span></span></span><br><span class="line">echo &quot;密码&quot;|sudo -S mount -o rw /dev/sda1 /mnt/Data/</span><br><span class="line">echo &quot;密码&quot;|sudo -S mount -o rw /dev/sda2 /mnt/Entertainment/</span><br><span class="line">echo &quot;密码&quot;|sudo -S mount -o rw /dev/sda3 /mnt/Learn/</span><br></pre></td></tr></table></figure>
<p>这样做不好的地方是密码以明文的形式放在了脚本中,个人的电脑可以这么搞.</p>
<h1 id="自动挂载的姿势之二"><a href="#自动挂载的姿势之二" class="headerlink" title="自动挂载的姿势之二"></a>自动挂载的姿势之二</h1><p>2021.2.15</p>
<p>今天看了鸟哥的私房菜的<strong>7.4 设置启动挂载</strong>，才知道原来根文件系统也是通过系统配置自动挂载的，以前从来都没有思考过。通过查看<code>cat /etc/fstab</code>就可以了解系统在开机时是如何自动挂载文件系统的，值得说的一点是<code>/</code>根文件系统是最先被挂载的，有了根文件系统，才能挂载其他的文件系统。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> /etc/fstab: static file system information.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Use &#x27;blkid&#x27; to print the universally unique identifier for a</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> device; this may be used with UUID= as a more robust way to name devices</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> that works even <span class="keyword">if</span> disks are added and removed. See fstab(5).</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> / was on /dev/nvme0n1p3 during installation</span></span><br><span class="line">UUID=d0be529a-c200-4bad-9086-bdbe580a4255 /               ext4    errors=remount-ro 0       1</span><br><span class="line"><span class="meta">#</span><span class="bash"> /boot/efi was on /dev/nvme0n1p2 during installation</span></span><br><span class="line">UUID=25A5-9DBA  /boot/efi       vfat    umask=0077      0       1</span><br><span class="line"><span class="meta">#</span><span class="bash"> /home was on /dev/nvme0n1p4 during installation</span></span><br><span class="line">UUID=6ad9690a-dfef-4fb0-a6da-a3aff8c8b622 /home           ext4    defaults        0       2</span><br><span class="line">/swapfile                                 none            swap    sw              0       0</span><br><span class="line">LABEL=Data /mnt/Data auto nosuid,nodev,nofail,x-gvfs-show,noauto 0 0</span><br><span class="line">LABEL=Entertainment /mnt/Entertainment auto nosuid,nodev,nofail,x-gvfs-show,noauto 0 0</span><br><span class="line">LABEL=Learn /mnt/Learn auto nosuid,nodev,nofail,x-gvfs-show,noauto 0 0</span><br></pre></td></tr></table></figure>
<p>这是我的<code>/etc/fstab</code>文件的内容，可以知道先挂载了根文件系统，然后挂载了efi，方便bios启动后，引导内核的启动，然后挂载了<code>/home</code>目录，这里顺便再说一下<code>/swapfile</code>这个文件系统，根据我粗浅的了解，以前ubuntu在安装时，创建一个与内存大小相当的交换分区有助于提高性能，我将它理解为虚拟内存（不知道合不合理），但现在电脑的配置都比较高了，基本用不着交换分区了，比如我的电脑内存16G，很够用了。想起来以前安装ubuntu16.04的时候还是需要划分一个交换分区的。</p>
<p>后边的这三个应该就是之前写的自动挂载脚本所创建的内容了，可以看到，拿Data这个文件系统来说，<strong>挂载点</strong>是：<code>/mnt/Data</code>；<strong>磁盘分区的文件系统</strong>是auto；<strong>文件系统参数</strong>是：<code>nosuid,nodev,nofail,x-gvfs-show,noauto</code>；最后两栏是<strong>能否被dump备份命令作用</strong>以及<strong>是否以fsck检验扇区</strong>，这两个都是0</p>
<p>之前写的自动挂载脚本在开机进入操作系统后才会被执行，今天看了书，可以优化一下了，原来的自动挂载脚本可以删掉了，鸟叔说挂载时最好还是用UUID去挂载，所以使用<code>sudo blkid</code>查看磁盘的UUID：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(base) wangtao@pc:~$ sudo blkid</span><br><span class="line">[sudo] wangtao 的密码： </span><br><span class="line">/dev/nvme0n1p3: UUID=&quot;d0be529a-c200-4bad-9086-bdbe580a4255&quot; BLOCK_SIZE=&quot;4096&quot; TYPE=&quot;ext4&quot; PARTUUID=&quot;9e9e48fc-c69b-4eb3-97e4-58b43f56de6c&quot;</span><br><span class="line">/dev/loop0: TYPE=&quot;squashfs&quot;</span><br><span class="line">/dev/loop1: TYPE=&quot;squashfs&quot;</span><br><span class="line">/dev/loop2: TYPE=&quot;squashfs&quot;</span><br><span class="line">/dev/loop3: TYPE=&quot;squashfs&quot;</span><br><span class="line">/dev/loop4: TYPE=&quot;squashfs&quot;</span><br><span class="line">/dev/loop5: TYPE=&quot;squashfs&quot;</span><br><span class="line">/dev/loop6: TYPE=&quot;squashfs&quot;</span><br><span class="line">/dev/loop7: TYPE=&quot;squashfs&quot;</span><br><span class="line">/dev/nvme0n1p1: LABEL=&quot;MS&quot; BLOCK_SIZE=&quot;512&quot; UUID=&quot;C25E6DFF5E6DEC9B&quot; TYPE=&quot;ntfs&quot; PARTLABEL=&quot;Basic data partition&quot; PARTUUID=&quot;ba4c815e-781d-44bf-ac01-cda07d2cfeab&quot;</span><br><span class="line">/dev/nvme0n1p2: UUID=&quot;25A5-9DBA&quot; BLOCK_SIZE=&quot;512&quot; TYPE=&quot;vfat&quot; PARTLABEL=&quot;EFI system partition&quot; PARTUUID=&quot;80565be5-f68a-470e-86c2-1c9bc74e88de&quot;</span><br><span class="line">/dev/nvme0n1p4: UUID=&quot;6ad9690a-dfef-4fb0-a6da-a3aff8c8b622&quot; BLOCK_SIZE=&quot;4096&quot; TYPE=&quot;ext4&quot; PARTUUID=&quot;bf1e37df-7442-4c60-9312-bdb432e29c58&quot;</span><br><span class="line">/dev/sda1: LABEL=&quot;Data&quot; BLOCK_SIZE=&quot;512&quot; UUID=&quot;9AC8F872C8F84E4F&quot; TYPE=&quot;ntfs&quot; PARTLABEL=&quot;Basic data partition&quot; PARTUUID=&quot;c5f722e6-b530-4fe4-a93b-e0c72e5fb08c&quot;</span><br><span class="line">/dev/sda2: LABEL=&quot;Entertainment&quot; BLOCK_SIZE=&quot;512&quot; UUID=&quot;1E0039C50039A4A5&quot; TYPE=&quot;ntfs&quot; PARTLABEL=&quot;Basic data partition&quot; PARTUUID=&quot;c11b7960-95c2-47ea-ac64-e39059a2daa6&quot;</span><br><span class="line">/dev/sda3: LABEL=&quot;Learn&quot; BLOCK_SIZE=&quot;512&quot; UUID=&quot;88123AB2123AA4DA&quot; TYPE=&quot;ntfs&quot; PARTLABEL=&quot;Basic data partition&quot; PARTUUID=&quot;6cb3ae63-879c-4558-b483-77c6ff882408&quot;</span><br><span class="line">/dev/loop8: TYPE=&quot;squashfs&quot;</span><br><span class="line">/dev/loop9: TYPE=&quot;squashfs&quot;</span><br><span class="line">/dev/loop10: TYPE=&quot;squashfs&quot;</span><br></pre></td></tr></table></figure>
<p>然后修改<code>/etc/fstab</code>的内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> automount HDD</span></span><br><span class="line">UUID=9AC8F872C8F84E4F /mnt/Data auto defaults 0 0</span><br><span class="line">UUID=1E0039C50039A4A5 /mnt/Entertainment auto defaults 0 0</span><br><span class="line">UUID=88123AB2123AA4DA /mnt/Learn auto defaults 0 0</span><br></pre></td></tr></table></figure>
<p>重启即可。</p>
<p>成功了记得去挂载点看看就行了，linux向来是报忧不报喜的，哈哈~</p>
<hr>
<p>2021.2.27</p>
<p>今天打算上传一下博客，发现磁盘权限全都变成只读了，我还以为是<code>/etc/fstab</code>出了问题，可劲百度。后来才知道，双系统的Windows有个快速启动的功能，会占用磁盘，导致ubuntu进系统的时候只能以只读的方式挂载。所以需要关闭windows的快速启动：以管理员权限运行cmd：<code>powercfg /h off</code>即可。然后回到ubuntu把磁盘修复一下就可以了。最后可以用<code>mount -l</code>可以查看磁盘的挂载权限状态。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>babysit your network</title>
    <url>/20201125f82e/</url>
    <content><![CDATA[<p>从0到1，开始训练你的神经网络</p>
<h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><p>面对实际的项目，往往要快速搭建一个可以运行的网络，不要想着精心设计，而是快速迭代优化。训练一个神经网络大概需要三大块内容：数据加载类、神经网络类、损失函数类。基于这些，还可以编写训练函数、评价函数、预测函数，从而训练你的网络，评价模型的好坏，并将预测结果进行可视化。</p>
<p>所以，你有三个思路来完成工作：</p>
<ol>
<li>自顶向下：明确你的优化目标，先完成损失函数，然后设计网络，最后完成数据加载类</li>
<li>自底向上：先编写数据加载类，再设计网络，最后设计损失函数；</li>
<li>两开花</li>
</ol>
<p>我的建议是：不管好坏，先制定一个优化目标，然后设计你的神经网络，最后在完成数据加载。<br>数据加载是个脏活，没什么可说的，我在这里想说一下，如何设计你的网络结构：</p>
<ol>
<li>首先分析问题的复杂程度，来决定如何设计网络；</li>
<li>站在前人的肩膀上：参照一个经典的网络进行修改</li>
<li>从零开始，自己搭建一个合适的网络。</li>
</ol>
<p>我认为神经网络的设计是门艺术，没有最好，只有更好。</p>
<h1 id="搭建网络"><a href="#搭建网络" class="headerlink" title="搭建网络"></a>搭建网络</h1><h2 id="CNN1"><a href="#CNN1" class="headerlink" title="CNN1"></a>CNN<sup><a href="#fn_1" id="reffn_1">1</a></sup></h2><h3 id="超参数"><a href="#超参数" class="headerlink" title="超参数"></a>超参数</h3><ol>
<li>卷积核的大小：<br>小过滤器收集更多的局部信息：3×3；5×5<br>大过滤器收集更多的全局信息：9×9；11×11</li>
<li>padding：保留边界信息，提高性能</li>
<li>stride：减小图像大小</li>
<li>channels：特征数，太多可能过拟合</li>
<li>pooling：下采样，降维</li>
<li>BN：激活层后，Dropout之后</li>
</ol>
<h3 id="设计网络的guideline"><a href="#设计网络的guideline" class="headerlink" title="设计网络的guideline"></a>设计网络的guideline</h3><blockquote>
<p>基本原则：保证特征空间初始阶段宽而浅；而后期窄而深</p>
</blockquote>
<ol>
<li><p>使用较小的滤波器收集尽可能多的局部信息，然后逐渐增加滤波器的宽度，以减少特征空间的宽度，以代表更多的、全局的、高级的、有代表性的信息</p>
</li>
<li><p>通道数开始时应该很低，这样能检测到低层次的特征，这些低层次的特征合成许多复杂的形状（通过增加通道的数量），有助于区分类别。<br>增加过滤器的数量以增加特征空间的深度，从而有助于学习更多级别的全局抽象结构。使特征空间更深而窄的另一个办法是缩小特征空间以输入到稠密网络。</p>
<p>在神经网络的各层结构中，通道往往会增加或保持不变。</p>
</li>
<li><p>对于中小尺寸图像，使用的卷积核大小通常为3×3、5×5、7×7；最大池化通常为2×2、3×3，步幅为2；较大的卷积核可以将大图像缩小到适当的大小。</p>
</li>
<li><p>如果重视边界信息，请使用same卷积</p>
</li>
<li><p>增加层数，直到过拟合为止。一旦在验证集中获得较高的准确性，采用以下方式来减少过拟合：</p>
<p>L1/L2正则化；Dropout；BatchNorm；数据扩充</p>
</li>
<li><p>设计网络时，以经典网络为灵感。灵感是指结构中的趋势，不是完全的抄袭：<br>layers：Conv-Pool-Conv-Pool；Conv-Conv-Pool-Conv-Conv-Pool<br>channels：32–64–128；32–32-64–64</p>
</li>
</ol>
<h2 id="DNN2"><a href="#DNN2" class="headerlink" title="DNN2"></a>DNN<sup><a href="#fn_2" id="reffn_2">2</a></sup></h2><h3 id="超参数-1"><a href="#超参数-1" class="headerlink" title="超参数"></a>超参数</h3><ol>
<li>层数：<br>太多：过拟合，梯度消失/爆炸<br>太少：高偏差，低性能</li>
<li>激活函数</li>
<li>优化器：SGD容易陷入局部最优；Adam快速收敛<br><a href="https://imgchr.com/i/DdYrnJ"><img src="https://s3.ax1x.com/2020/11/25/DdYrnJ.gif" alt="DdYrnJ.gif"></a></li>
<li>学习率：$10^{-n}$<br>SGD：$10^{-1}$；Adam：$10^{-2}$/$10^{-3}$<br>learningrate_decay：0.000005或其他</li>
<li>初始化：<br>He-normal/uniform初始化—&gt;ReLU<br>Glorot-normal/uniform初始化—&gt;Sigmoid</li>
<li>batch_size：$2^{n}$（便于优化内存）<br>太大：学习缓慢<br>太小：权重分散</li>
<li>epochs：<br>太大：过拟合；泛化问题<br>太小：限制模型潜力</li>
<li>Dropout：0~1，通常为0.5。优化偏差方差，解决过拟合</li>
<li>正则化（Regularization）：以增加偏差的方式减少误差</li>
</ol>
<p>关于如何设计网络,这里有篇论文:<a href="https://wangtaocs.lanzous.com/i9NCNisdzrg">A practical theory for designing very deep convolutional neural networks</a></p>
<h1 id="训练网络"><a href="#训练网络" class="headerlink" title="训练网络"></a>训练网络</h1><p>当按照以上方式完成了三个基本模块之后，就可以训练自己的网络了。<br>训练时的超参数主要有epochs，batch_size，lr</p>
<ol>
<li>epoch：建议前期选小一点，这是为了快速获得训练结果，然后马上推进后面的工作；</li>
<li>batch_size：选择你电脑性能内的最大值</li>
<li>lr：根据不同的优化器选择不同的大小</li>
</ol>
<p>训练时，建议每隔几个epochs就保存一次模型，以便后期进行对比。</p>
<h2 id="调整参数3"><a href="#调整参数3" class="headerlink" title="调整参数3"></a>调整参数<sup><a href="#fn_3" id="reffn_3">3</a></sup></h2><p>这部分是引用别人的,我觉得写的特别好,就保存下来了,话糙理不糙啊.原文的链接在<a href="https://www.sohu.com/a/241208957_787107">这里</a></p>
<p>基本原则:快速试错</p>
<p>一些大的注意事项:</p>
<p>1.刚开始, 先上小规模数据, 模型往大了放, 只要不爆显存, 能用256个filter你就别用128个. <strong>直接奔着过拟合去. 没错, 就是训练过拟合网络</strong>, 连测试集验证集这些都可以不用.</p>
<p>为什么?</p>
<p>+ 你要验证自己的训练脚本的流程对不对. 这一步小数据量, 生成速度快, 但是所有的脚本都是和未来大规模训练一致的(除了少跑点循环)</p>
<p>+ 如果小数据量下, 你这么粗暴的大网络奔着过拟合去都没效果. 那么, 你要开始反思自己了, 模型的输入输出是不是有问题? 要不要检查自己的代码(永远不要怀疑工具库, 除非你动过代码)? 模型解决的问题定义是不是有问题? 你对应用场景的理解是不是有错? 不要怀疑NN的能力, 不要怀疑NN的能力, 不要怀疑NN的能力. 就我们调参狗能遇到的问题, NN没法拟合的, 这概率是有多小?</p>
<p>+ 你可以不这么做, 但是等你数据准备了两天, 结果发现有问题要重新生成的时候, 你这周时间就酱油了.</p>
<p>2.Loss设计要合理.</p>
<p>+ 一般来说分类就是Softmax, 回归就是L2的loss. 但是要注意loss的错误范围(主要是回归), 你预测一个label是10000的值, 模型输出0, 你算算这loss多大, 这还是单变量的情况下. 一般结果都是nan. 所以不仅仅输入要做normalization, 输出也要这么弄.</p>
<p>+ 多任务情况下, 各loss想法限制在一个量级上, 或者最终限制在一个量级上, 初期可以着重一个任务的loss</p>
<p>3.观察loss胜于观察准确率</p>
<p>准确率虽然是评测指标, 但是训练过程中还是要注意loss的. 你会发现有些情况下, 准确率是突变的, 原来一直是0, 可能保持上千迭代, 然后突然变1. 要是因为这个你提前中断训练了, 只有老天替你惋惜了. 而loss是不会有这么诡异的情况发生的, 毕竟优化目标是loss.</p>
<p>给NN一点时间, 要根据任务留给NN的学习一定空间. 不能说前面一段时间没起色就不管了. 有些情况下就是前面一段时间看不出起色, 然后开始稳定学习.</p>
<p>4.确认分类网络学习充分</p>
<p>分类网络就是学习类别之间的界限. 你会发现, 网络就是慢慢的从类别模糊到类别清晰的. 怎么发现? 看Softmax输出的概率的分布. 如果是二分类, 你会发现, 刚开始的网络预测都是在0.5上下, 很模糊. 随着学习过程, 网络预测会慢慢的移动到0,1这种极值附近. 所以, 如果你的网络预测分布靠中间, 再学习学习.</p>
<p>5.Learning Rate设置合理</p>
<p>+ 太大: loss爆炸, 或者nan</p>
<p>+ 太小: 半天loss没反映(但是, LR需要降低的情况也是这样, 这里可视化网络中间结果, 不是weights, 有效果, 俩者可视化结果是不一样的, 太小的话中间结果有点水波纹或者噪点的样子, 因为filter学习太慢的原因, 试过就会知道很明显)</p>
<p>+ 需要进一步降低了: loss在当前LR下一路降了下来, 但是半天不再降了.</p>
<p>+ 如果有个复杂点的任务, 刚开始, 是需要人肉盯着调LR的. 后面熟悉这个任务网络学习的特性后, 可以扔一边跑去了.</p>
<p>+ 如果上面的Loss设计那块你没法合理, 初始情况下容易爆, 先上一个小LR保证不爆, 等loss降下来了, 再慢慢升LR, 之后当然还会慢慢再降LR, 虽然这很蛋疼.</p>
<p>+ LR在可以工作的最大值下往小收一收, 免得ReLU把神经元弄死了. 当然, 我是个心急的人, 总爱设个大点的.</p>
<p>6.对比训练集和验证集的loss</p>
<p>判断过拟合, 训练是否足够, 是否需要early stop的依据, 这都是中规中矩的原则, 不多说了.</p>
<p>7.清楚receptive field的大小</p>
<p>CV的任务, context window是很重要的. 所以你对自己模型的receptive field的大小要心中有数. 这个对效果的影响还是很显著的. 特别是用FCN, 大目标需要很大的receptive field. 不像有fully connection的网络, 好歹有个fc兜底, 全局信息都有.</p>
<p>简短的注意事项: </p>
<ol>
<li>预处理: -mean/std zero-center就够了, PCA, 白化什么的都用不上. 我个人观点, 反正CNN能学习encoder, PCA用不用其实关系不大, 大不了网络里面自己学习出来一个.</li>
<li>shuffle, shuffle, shuffle.</li>
<li>网络原理的理解最重要, CNN的conv这块, 你得明白sobel算子的边界检测.</li>
<li>Dropout, Dropout, Dropout(不仅仅可以防止过拟合, 其实这相当于做人力成本最低的Ensemble, 当然, 训练起来会比没有Dropout的要慢一点, 同时网络参数你最好相应加一点, 对, 这会再慢一点).</li>
<li>CNN更加适合训练回答是否的问题, 如果任务比较复杂, 考虑先用分类任务训练一个模型再finetune.</li>
<li>无脑用ReLU(CV领域).</li>
<li>无脑用3x3.</li>
<li>无脑用xavier.</li>
<li>LRN一类的, 其实可以不用. 不行可以再拿来试试看.</li>
<li>filter数量2^n.</li>
<li>多尺度的图片输入(或者网络内部利用多尺度下的结果)有很好的提升效果.</li>
<li>第一层的filter, 数量不要太少. 否则根本学不出来(底层特征很重要).</li>
<li>sgd adam 这些选择上, 看你个人选择. 一般对网络不是决定性的. 反正我无脑用sgd + momentum.</li>
<li>batch normalization我一直没用, 虽然我知道这个很好, 我不用仅仅是因为我懒. 所以要鼓励使用batch normalization.</li>
<li>不要完全相信论文里面的东西. 结构什么的觉得可能有效果, 可以拿去试试.</li>
<li>你有95%概率不会使用超过40层的模型.</li>
<li>shortcut的联接是有作用的.</li>
<li>暴力调参最可取, 毕竟, 自己的生命最重要. 你调完这个模型说不定过两天这模型就扔掉了.</li>
<li>机器, 机器, 机器.</li>
<li>Google的inception论文, 结构要好好看看.</li>
<li>一些传统的方法, 要稍微了解了解. 我自己的程序就用过1x14的手写filter, 写过之后你看看inception里面的1x7, 7x1 就会会心一笑…</li>
</ol>
<h1 id="优化模型"><a href="#优化模型" class="headerlink" title="优化模型"></a>优化模型</h1><p>当模型已经很好的拟合结果,甚至是过拟合时,就可以考虑优化了.跟快速开始中一样,仍然有三个部分可以优化.<br>但在优化之前,你必须完成你的评价函数了,你需要一个合理的评价指标,你的目的就是尽量在这个指标下做到最好.</p>
<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>从数据下手是优化模型的灵丹妙药,但是人力成本就很高了,最优的方案当然是扩充你的数据集,使样本空间更大.如果做不到这些,或者是你的数据集已经很庞大了,那这将收效甚微.可以考虑用代码的方式进行数据扩增(data augmentation):翻转,旋转,裁剪等.这样可以成倍地扩充数据集.具体如何扩增,请对实际问题进行分析.</p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>如果效果已经很好了,就不需要再增加层数了,这样只会徒增参数,起不到什么效果.可以考虑的是:在网络的开始几层添加BatchNorm,不需要太多,这样可以加速收敛.如果过拟合了,可以在最后几层使用Dropout.对于优化网络,我的心得还不是很多.</p>
<h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>损失函数放在最后,我认为这是最不该优化的地方,因为这是你最初设计网络,训练模型一直想要逼近的目标,如果你修改了损失函数,甚至是大改特改,推倒重来,那这将意味着你之前做的努力都付之东流了</p>
<h1 id="神经网络可以解决什么问题4"><a href="#神经网络可以解决什么问题4" class="headerlink" title="神经网络可以解决什么问题4"></a>神经网络可以解决什么问题<sup><a href="#fn_4" id="reffn_4">4</a></sup></h1><p>这是我做完项目之后的反思,神经网络究竟能干什么,它的极限在哪里,它不能解决什么,这有待以后的深入学习.<br>经过我查阅了大量博客,没有找到相关的论文(肯定有这方面的论文,只是我没找到)</p>
<p>神经网络目前主要可以解决(预测)两类问题:</p>
<ol>
<li>分类问题(Classification)(离散问题)</li>
<li>回归问题(Regression)(连续问题)</li>
</ol>
<p>比如手写数字识别就是一个典型的分类问题,体重预测是一个典型的回归问题.而一些比较复杂的情景我认为就是既有分类问题,也有回归问题.比如说目标识别中,定位目标是一个回归问题,检测目标是什么类别是一个分类问题.</p>
<p>当你分析清楚实际问题到底是哪类问题时,就可以采用不同的策略.<br>具体什么策略我还没有研究.</p>
<hr>
<blockquote id="fn_1">
<sup>1</sup>. <a href="https://towardsdatascience.com/a-guide-to-an-efficient-way-to-build-neural-network-architectures-part-ii-hyper-parameter-42efca01e5d7">A guide to an efficient way to build neural network architectures- Part II: Hyper-parameter selection and tuning for Convolutional Neural Networks using Hyperas on Fashion-MNIST</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_2">
<sup>2</sup>. <a href="https://towardsdatascience.com/a-guide-to-an-efficient-way-to-build-neural-network-architectures-part-i-hyper-parameter-8129009f131b">A guide to an efficient way to build neural network architectures- Part I: Hyper-parameter selection and tuning for Dense Networks using Hyperas on Fashion-MNIST</a><a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_3">
<sup>3</sup>. <a href="https://www.sohu.com/a/241208957_787107">卷积神经网络的卷积核大小、个数，卷积层数如何确定呢？</a><a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_4">
<sup>4</sup>. <a href="https://blog.csdn.net/qq_44704609/article/details/104573503">深度学习 分类问题与回归问题</a><a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a>
</blockquote>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
  </entry>
  <entry>
    <title>YOLOv1</title>
    <url>/2020110662617/</url>
    <content><![CDATA[<h1 id="论文简述"><a href="#论文简述" class="headerlink" title="论文简述"></a>论文简述</h1><p><a href="https://pjreddie.com/darknet/yolov1/">YOLOv1</a><br>一个实时目标检测模型，因对整张图片进行检测（Unified Detection），使用卷积进行滑动窗口的实现，大大提高了对象检测的效率。因为第二段是论文的核心内容，因此本文将YOLOv1的第二段进行主观式理解与翻译，如有不对还请指正。你可以在这里<a href="https://arxiv.org/abs/1506.02640">下载</a></p>
<h1 id="理解式翻译"><a href="#理解式翻译" class="headerlink" title="理解式翻译"></a>理解式翻译</h1><p>以下为论文原文翻译</p>
<h2 id="2-统一检测"><a href="#2-统一检测" class="headerlink" title="2.统一检测"></a>2.统一检测</h2><p><strong>Ⅰ.</strong></p>
<ol>
<li>将目标检测的分离组件统一到一个神经网络</li>
<li>使用整张图片的特征预测bounding box（以下简称bbox）</li>
<li>同时预测一张照片的所有bbox和类别</li>
<li>此网络考虑整张图片和所有目标</li>
<li>端到端训练、实时、高平均精度</li>
</ol>
<p><strong>Ⅱ.</strong></p>
<ol>
<li>将图片分成$S \times S$的网格</li>
<li>如果对象的中心点落在一个cell中，这个cell就负责检测这个目标</li>
</ol>
<p><strong>Ⅲ.</strong></p>
<ol>
<li>每个cell预测B个bbox和这些bbox的置信度</li>
<li>置信度反映了：模型有多确信box包含一个对象；box预测得有多精确</li>
<li>定义置信度$=Pr(Object) \ast IOU_{pred}^{truth}$</li>
<li>cell中没有对象时，置信度为0</li>
<li>否则置信度=介于预测box与真实值之间的IOU</li>
</ol>
<p><strong>Ⅳ.</strong></p>
<ol>
<li>每个bbox包含五个预测值：$x,y,w,h,confidence$</li>
<li>$(x,y)$坐标代表box相对于cell边界的中心点</li>
<li>相对于整个图像预测宽度和高度</li>
<li>最后，置信度代表介于预测box与真实box之间的IOU</li>
</ol>
<p><strong>Ⅴ.</strong></p>
<ol>
<li>每个cell预测了C个条件类别概率，$Pr(Class_{i} \mid Object)$</li>
<li>这些概率是在cell包含一个对象的条件下成立的</li>
<li>只预测每个cell中国的类别可能性的一个集合，而不管B个box的数量</li>
</ol>
<p><strong>Ⅵ.</strong></p>
<ol>
<li>测试时，将条件类别概率×每个box的置信度预测值，从而得到了每个box特定类别的置信度：<br><a href="https://imgchr.com/i/B5OT9x"><img src="https://s1.ax1x.com/2020/11/07/B5OT9x.png" alt="B5OT9x.png"></a></li>
<li>这些置信度编码了：在box中出现某个类别的可能性；预测box有多适合目标</li>
</ol>
<p><strong>Ⅶ.</strong></p>
<ol>
<li>为了在PASCAL VOC（以下简称PV）上测试YOLO，令S=7，B=2，PV有20个类别，所以C=20，最终预测值是一个7×7×30的张量</li>
</ol>
<h3 id="2-1-网络设计"><a href="#2-1-网络设计" class="headerlink" title="2.1 网络设计"></a>2.1 网络设计</h3><p><a href="https://imgchr.com/i/BIj081"><img src="https://s1.ax1x.com/2020/11/08/BIj081.png" alt="BIj081.png"></a></p>
<p><strong>Ⅰ.</strong></p>
<ol>
<li>使用卷积神经网络实现这个模型并在PV数据集上评估</li>
<li>初始化卷积层，从图片中提取特征，然后使用全连接层预测输出可能性和坐标</li>
</ol>
<p><strong>Ⅱ.</strong></p>
<ol>
<li>网络结构受GoogLeNet启发</li>
<li>有24层卷积层和2层全连接层</li>
<li>为了代替GoogLeNet中的inception模块，使用了1×1reduction层和3×3卷积层</li>
</ol>
<p><strong>Ⅲ.</strong></p>
<ol>
<li>训练了YOLO的更快版本，为了达到更快的边界预测</li>
<li>Fast YOLO使用了更少的卷积层（9层而非24层）以及层中更少的过滤器</li>
<li>所有的训练和测试参数介于YOLO与Fast YOLO之间</li>
</ol>
<h3 id="2-2-训练"><a href="#2-2-训练" class="headerlink" title="2.2 训练"></a>2.2 训练</h3><p><strong>Ⅰ.</strong></p>
<ol>
<li>在ImageNet上预训练了卷积层</li>
<li>为了预训练使用了前20层卷积+一个平均池化层+一个全连接层</li>
<li>训练大约一周，在ImageNet 2012验证集中是top5，88%的准确率</li>
<li>使用Darknet框架做所有的训练和推导</li>
</ol>
<p><strong>Ⅱ.</strong></p>
<ol>
<li>然后将模型转化为执行检测</li>
<li>Ren等证明预训练卷积层和全连接层可提升性能</li>
<li>以此为鉴，我们加了4层卷积层和2层全连接层，并随机初始化权重</li>
<li>检测需要更细粒度的视觉信息，所以将分辨率224×224 -&gt; 448×448</li>
</ol>
<p><strong>Ⅲ.</strong></p>
<ol>
<li>最后一层能同时预测类别概率和bbox坐标</li>
<li>用图像的宽高归一化bbox的宽高，使它们的取值为[0,1]</li>
<li>将bbox的(x,y)坐标参数化为特定网格单元位置的偏移量，使其取值为[0,1]</li>
</ol>
<p><strong>Ⅳ.</strong></p>
<ol>
<li>最后一层使用线性激活函数，其他层使用LeakyReLu</li>
</ol>
<p><strong>Ⅴ.</strong></p>
<ol>
<li>优化模型的平方和误差输出</li>
<li>使用平方和误差是因为其易于优化，然而它不能完美校准最大平均精度</li>
<li>它将定位误差等价为分类误差，这不太理想</li>
<li>而且在每张图片的cell中，很多都不包含对象</li>
<li>这使这些cell的置信度趋向0，经常会掩盖确实包含对象的cell的梯度</li>
<li>这导致模型不稳定，造成训练过早发生偏离</li>
</ol>
<p><strong>Ⅵ.</strong></p>
<ol>
<li>为了进行补救，增加了来自bbox座标预测的损失；并减少了来自不包含对象的box的置信度损失</li>
<li>使用两个参数$\lambda _{coord}$，$\lambda _{noobj}$来完成它</li>
<li>设置$\lambda _{coord}=5$，$\lambda _{noobj}=0.5$</li>
</ol>
<p><strong>Ⅶ.</strong></p>
<ol>
<li>平方和误差也平等地权衡了大box和小box的误差</li>
<li>误差指标应该反映大box的小误差，而不是小box的</li>
<li>为尽量解决这个问题，预测bbox宽高的平方根来取代宽高</li>
</ol>
<p><strong>Ⅷ.</strong></p>
<ol>
<li>YOLO在每个cell预测了很多bbox</li>
<li>在训练时，只想要一个bbox预测来负责每个目标对象</li>
<li>我们分配一个预测框负责预测一个对象，基于这个对象的预测拥有和真实值的最大当前IOU</li>
<li>这导致bbox预测框</li>
<li>每个预测框都能更好的预测某些尺寸，长宽比或对象类别，从而提高整体召回率</li>
</ol>
<p><strong>Ⅸ.</strong></p>
<ol>
<li><p>训练期间优化了下面这个复杂的损失函数：<br><a href="https://imgchr.com/i/BImUJ0"><img src="https://s1.ax1x.com/2020/11/07/BImUJ0.md.png" alt="BImUJ0.md.png" style="zoom:67%;" /></a></p>
<p>其中$1_{i}^{obj}$表示对象是否出现在第i个cell中，$1_{ij}^{obj}$表示在第i个cell中第j个bbox预测框负责那次预测。</p>
</li>
</ol>
<p><strong>Ⅹ.</strong></p>
<ol>
<li>注意：如果cell中存在目标，损失函数只会惩罚分类错误（之前条件类别概率讨论过）</li>
<li>如果预测框负责真实值的box（在cell中拥有任意预测框的最高IOU），它也会惩罚bbox的座标误差</li>
</ol>
<p><strong>Ⅺ.</strong></p>
<ol>
<li>在PV2007和2012训练和验证集上训练网络135个epoch</li>
<li>在2012年的数据上测试时，也包括VOC2007测试数据进行训练</li>
<li>训练时，batch_size=64,momentum=0.9,decay=0.0005</li>
</ol>
<p><strong>Ⅻ.</strong></p>
<ol>
<li>学习率变化如下：</li>
<li>第一个epoch，我们将学习率从$10^{-3}$缓慢提升到$10^{-2}$</li>
<li>如果以高学习率开始，由于梯度不稳定，我们的模型会发散</li>
<li>用$10^{-2}$训练75个epoch，$10^{-3}$训练30个epoch，最后$10^{-4}$训练30个epoch</li>
</ol>
<p><strong>XIII.</strong></p>
<ol>
<li>为了避免过拟合，使用dropout和数据扩充</li>
<li>dropout层中，rate=0.5，位于第一个连接层后，防止层与层之间的共同适应</li>
<li>对于数据扩充，引入随机缩放和至多20%原始图像的大小变换</li>
<li>在HSV颜色空间中随即调整1.5倍曝光和饱和度</li>
</ol>
<h3 id="2-3-推论"><a href="#2-3-推论" class="headerlink" title="2.3 推论"></a>2.3 推论</h3><p><strong>Ⅰ.</strong></p>
<ol>
<li>就像训练，预测图像的检测只需要一次网络评估</li>
<li>在PV上，网络在每张图片上可预测98个bbox和每个box的类别概率</li>
<li>不像基于分类器的方法，因为YOLO只需一次网络评估，所以在测试时速度特别快</li>
</ol>
<p><strong>Ⅱ.</strong></p>
<ol>
<li>网络设计在bbox预测中强制空间分集</li>
<li>通常，很明显一个对象落到一个cell中，并且网络只为每个对象预测一个box</li>
<li>然而，一些大目标或多个cell附近的对象能够被很好的定位</li>
<li>非极大值抑制可避免多次检测</li>
<li>对R-CNN或DPM来说，性能不是最重要的，但极大值抑制可提高2%-3%的mAP</li>
</ol>
<h3 id="2-4-YOLO的不足"><a href="#2-4-YOLO的不足" class="headerlink" title="2.4 YOLO的不足"></a>2.4 YOLO的不足</h3><p><strong>Ⅰ.</strong></p>
<ol>
<li>YOLO对bbox预测施加了强大的空间约束，因为每个cell只能预测连个box和一个类别</li>
<li>这种空间约束限制了模型可以预测的附近物体的数量</li>
<li>模型不擅长处理成组的小目标，例如成群的鸟</li>
</ol>
<p><strong>Ⅱ.</strong></p>
<ol>
<li>因为模型从数据中学习预测bbox，它很难推广到新的、不同长宽比或配置的目标</li>
<li>模型使用相对粗糙的特征预测bbox，因为我们的结构拥有从输出图像获得的下采样层</li>
</ol>
<p><strong>Ⅲ.</strong></p>
<ol>
<li>最后，虽然我们近似检测性能的损失函数，但我们的损失函数同等对待小box与大box的误差</li>
<li>大box中的小误差通常是良性的，但小box中的小误差对IOU有更大的影响</li>
<li>误差的主要来源是定位错误</li>
</ol>
]]></content>
      <categories>
        <category>paper阅读笔记</category>
      </categories>
  </entry>
  <entry>
    <title>8.目标检测</title>
    <url>/2020102647531/</url>
    <content><![CDATA[<h1 id="目标定位"><a href="#目标定位" class="headerlink" title="目标定位"></a>目标定位</h1><ol>
<li><p>如何定位图片中对象的位置？<br>目标的参数化表示，让神经网络多输出4个单元：</p>
<ul>
<li>$b_{x}$：边界框的中心点的x坐标</li>
<li>$b_{y}$：边界框的中心点的y坐标</li>
<li>$b_{h}$：边界框的高度</li>
<li>$b_{w}$：边界框的宽度</li>
</ul>
</li>
<li><p>如何为监督学习任务定义目标标签$y$？</p>
<script type="math/tex; mode=display">
y=\left[\begin{array}{l}
p_{c} \\
b_{x} \\
b_{y} \\
b_{h} \\
b_{w} \\
c_{1} \\
c_{2} \\
c_{3}
\end{array}\right]</script><ul>
<li>$p_{c}$：表示是否存在目标；使用逻辑回归</li>
<li>$b_{x},b_{y},b_{h},b_{w}$：边界框参数；</li>
<li>$c_{1},c_{2},c_{3}$：不同类别；使用softmax，甚至是均方误差。</li>
</ul>
<p>$p_{c}=1$时，表示图中存在目标对象；<br>$p_{c}=0$时，表示图中不存在目标对象，其余参数无意义。</p>
</li>
</ol>
<h1 id="特征点检测"><a href="#特征点检测" class="headerlink" title="特征点检测"></a>特征点检测</h1><p>假设构建一个人脸特征点检测的神经网络，检测人脸的64个关键点，则神经网络的最后一层需要输出129个单元：每个点的坐标为$(x,y)$，一共需要128个单元，还需要一个单元来确定是否存在人脸，所以一共需要129个单元。</p>
<h1 id="目标检测"><a href="#目标检测" class="headerlink" title="目标检测"></a>目标检测</h1><p>基于滑动窗口的目标检测算法。</p>
<ol>
<li>构建标签训练集，训练卷积网络，然后利用其实现滑动窗口实现目标检测：</li>
<li>选定一个特定大小的窗口，将其中的部分图像输入网络，判断是否存在目标；</li>
<li>使用这个窗口遍历整张图片（这个过程有些类似于过滤器卷积输入图像），对每个位置进行分类；</li>
<li>选用更大的窗口重复以上步骤，肯定会有一个窗口可以检测到目标。</li>
</ol>
<p>缺点：</p>
<ul>
<li>小步幅窗口多，性能较好，但计算成本太大；</li>
<li>大步幅窗口少，性能差，计算成本相对低。</li>
</ul>
<h1 id="滑动窗口的卷积实现"><a href="#滑动窗口的卷积实现" class="headerlink" title="滑动窗口的卷积实现"></a>滑动窗口的卷积实现</h1><p><img src="http://www.ai-start.com/dl2017/images/b33768b46b3a06ff229a153765782b48.png" alt=""></p>
<p>使用卷积可以实现计算共享，提高性能。<br>上图中，14×14×3的蓝色矩阵代表输入训练集，经过神经网络的训练，可以得到一个1×1×4的分类结果；<br>16×16×3代表在测试集上进行抽象的滑动窗口，这里并没有真的滑动窗口，而是整个图片进行卷积计算后，2×2的预测结果正好可以与模拟的四次滑动窗口进行映射，这样，利用卷积计算，一次性的实现了整张图片的滑动窗口检测。其中，MAX POOL的维度可以控制抽象滑动窗口的步长。</p>
<h1 id="Bounding-Box预测"><a href="#Bounding-Box预测" class="headerlink" title="Bounding Box预测"></a>Bounding Box预测</h1><p>滑动窗口的卷积实现效率较高，但不能获得最精准的边界框，为了得到更精准的边界框，采用Bounding Box预测</p>
<p>此算法相当于将原图像进行了裁剪，并对每个小子图进行标注。例如裁剪为3×3的图像后，要对九个子图都进行标注，并当作训练数据，训练整个网络</p>
<h1 id="交并比"><a href="#交并比" class="headerlink" title="交并比"></a>交并比</h1><p>评价对象检测算法。</p>
<p><img src="http://www.ai-start.com/dl2017/images/38eea69baa46091d516a0b7a33e5379e.png" alt=""></p>
<p>$IoU&gt;0.5$时，可以采用。这个0.5是人为规定的，如果需要提高对算法的要求，可以规定更大的$IoU$</p>
<h1 id="非极大值抑制"><a href="#非极大值抑制" class="headerlink" title="非极大值抑制"></a>非极大值抑制</h1><p>非极大值抑制可以确保算法对每个对象只检测一次</p>
<ol>
<li>去掉概率低于某个阈值的边框</li>
<li>选择概率最大的边框，去掉与概率最大的边框交并比较大的边框</li>
</ol>
<h1 id="Anchor-Boxes"><a href="#Anchor-Boxes" class="headerlink" title="Anchor Boxes"></a>Anchor Boxes</h1><p>到目前为止，对象检测中存在的一个问题是每个格子只能检测出一个对象，如果你想让一个格子检测出多个对象，就是用<strong>Anchor Boxes</strong>。</p>
<p>预先定义两个不同形状的<strong>anchor box</strong>，或者<strong>anchor box</strong>形状，把预测结果和这两个<strong>anchor box</strong>关联起来。<br>定义类别标签，不使用：</p>
<script type="math/tex; mode=display">
\left[\begin{array}{llllllll}
p_{c} & b_{x} & b_{y} & b_{h} & b_{w} & c_{1} & c_{2} & c_{3}
\end{array}\right]^{T}</script><p>而是重复两次，使用：</p>
<script type="math/tex; mode=display">
\left.\begin{array}{lllllllllllll}
y=\left[p_{c}\right. & b_{x} & b_{y} & b_{h} & b_{w} & c_{1} & c_{2} & c_{3} & p_{c} & b_{x} & b_{y} & b_{h} & b_{w} & c_{1} & c_{2} & c_{3}
\end{array}\right]^{T}</script><p><img src="http://www.ai-start.com/dl2017/images/2e357b5b92122660c550dcfb0901519c.png" alt=""></p>
<p>前8个参数和<strong>anchor box 1</strong>关联，后8个参数和<strong>anchor box 2</strong>关联</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
  </entry>
  <entry>
    <title>7.卷积神经网络</title>
    <url>/2020101715916/</url>
    <content><![CDATA[<h1 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h1><h2 id="卷积运算“-”"><a href="#卷积运算“-”" class="headerlink" title="卷积运算“$*$”"></a>卷积运算“$*$”</h2><p><img src="http://www.ai-start.com/dl2017/images/7099a5373f2281626aa8ddd47a180571.png" alt=""></p>
<p>$*$是卷积的标准符号</p>
<p><img src="http://www.ai-start.com/dl2017/images/2b4796e91703492fe5a87d4fd95fcd6b.png" alt=""></p>
<p>$3+1+2+0+0+0+(-1)+(-8)+(-2)=-5$即为卷积计算。</p>
<p>$n \times n$的图像用$f \times f$的过滤器卷积，得到$(n-f+1)\times(n-f+1)$的矩阵。</p>
<h2 id="边缘检测-1"><a href="#边缘检测-1" class="headerlink" title="边缘检测"></a>边缘检测</h2><ul>
<li>正边：边缘由亮到暗</li>
<li>复边：边缘由暗到亮</li>
</ul>
<ol>
<li>垂直边缘：<br><img src="http://www.ai-start.com/dl2017/images/0c8b5b8441557b671431d515aefa1e8a.png" style="zoom:67%;" /></li>
<li>水平边缘：<br><img src="http://www.ai-start.com/dl2017/images/f4adb9d91879e1c1aaef9bc9e244c64a.png" style="zoom:67%;" /></li>
</ol>
<p>滤波器：</p>
<ol>
<li><strong>Sobel</strong>滤波器：<script type="math/tex; mode=display">
\left[\begin{array}{lll}1 & 0 & -1 \\ 2 & 0 & -2 \\ 1 & 0 & -1\end{array}\right]</script></li>
<li><strong>Scharr</strong>滤波器：<script type="math/tex; mode=display">
\left[\begin{array}{ccc}
3 & 0 & -3 \\
10 & 0 & -10 \\
3 & 0 & -3
\end{array}\right]</script></li>
</ol>
<p><img src="http://www.ai-start.com/dl2017/images/f889ad7011738a23d78070e8ed2df04e.png" alt=""></p>
<p>将矩阵中所有的数字视为参数，通过数据反馈，让神经网络自动去学习它们，我们会发现神经网络可以学习一些低级的特征，例如这些边缘的特征。相比这种单纯的垂直边缘和水平边缘，它可以检测出45°或70°或73°，甚至是任何角度的边缘。</p>
<h1 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h1><p>在图像的最外层用0进行数据填充。</p>
<p>为了解决以下两个问题：</p>
<ol>
<li>越卷积，图像越小</li>
<li>图像边缘位置特征部分丢失：图像边缘的数据被采用的较少</li>
</ol>
<p>两种填充方式：</p>
<ul>
<li><p>Valid卷积：不填充</p>
</li>
<li><p>Same卷积：输入输出大小相同</p>
<script type="math/tex; mode=display">
n+2p-f+1=n</script><script type="math/tex; mode=display">
p=\frac{f-1}{2}</script></li>
</ul>
<p>$f$通常是奇数，原因：</p>
<ol>
<li>如果是偶数，只能使用一些不对称填充。</li>
<li>使用奇数过滤器可以有一个中心点，方便指出过滤器的位置。</li>
</ol>
<h1 id="卷积步长"><a href="#卷积步长" class="headerlink" title="卷积步长"></a>卷积步长</h1><p>过滤器每次横向移动的距离</p>
<p>$n \times n$的图像用$f \times f$的过滤器卷积，步长为$S$，得到$\left \lfloor \frac{n+2p-f}{S}+1 \right \rfloor\times\left \lfloor \frac{n+2p-f}{S}+1 \right \rfloor$的矩阵。</p>
<h1 id="三维卷积"><a href="#三维卷积" class="headerlink" title="三维卷积"></a>三维卷积</h1><p><img src="https://s1.ax1x.com/2020/10/18/0Xa7VI.png" alt="0Xa7VI.png" style="zoom:33%;" /></p>
<p>多种特征匹配卷积，使用n个不同的过滤器对矩阵进行卷积运算，然后将卷积后的一维矩阵叠加为新的n维矩阵：</p>
<p><img src="https://s1.ax1x.com/2020/10/18/0Xd2es.png" alt="0Xd2es.png" style="zoom:33%;" /></p>
<h1 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h1><p>缩减模型的大小，提高计算速度，同时提高所提取特征的鲁棒性</p>
<ul>
<li>MaxPooling</li>
<li>AveragePooling</li>
</ul>
<h1 id="为什么使用卷积"><a href="#为什么使用卷积" class="headerlink" title="为什么使用卷积"></a>为什么使用卷积</h1><p>卷积层的两个主要优势：参数共享和稀疏连接。使得神经网络的参数大大减少。</p>
<ul>
<li>参数共享<br>共享的就是过滤器中的参数，这个过滤器可以匹配图片中的所有相同类型的特征，从而减少参数</li>
<li>稀疏连接<br>输出通过过滤器过滤输入特征，这些输出是彼此独立的，不会互相影响。</li>
</ul>
<h1 id="经典网络"><a href="#经典网络" class="headerlink" title="经典网络"></a>经典网络</h1><ul>
<li>LeNet</li>
<li>AlexNet</li>
<li>VGG-16</li>
</ul>
<h1 id="残差网络"><a href="#残差网络" class="headerlink" title="残差网络"></a>残差网络</h1><p>ResNet（Residual Network）</p>
<p><a href="https://imgchr.com/i/0zeeaQ"><img src="https://s1.ax1x.com/2020/10/19/0zeeaQ.png" alt="0zeeaQ.png"></a></p>
<p>每两层增加一个捷径，构成一个残差块。如图所示，5个残差块连接在一起构成一个残差网络:</p>
<p><a href="https://imgchr.com/i/0zeDsK"><img src="https://s1.ax1x.com/2020/10/19/0zeDsK.png" alt="0zeDsK.png"></a></p>
<p>如果没有残差网络，对于一个普通网络来说，深度越深意味着用优化算法越难训练。实际上，随着网络深度的加深，训练错误会越来越多。</p>
<p>但有了<strong>ResNets</strong>就不一样了，即使网络再深，训练的表现却不错，比如说训练误差减少，就算是训练深达100层的网络也不例外。有人甚至在1000多层的神经网络中做过实验，尽管目前我还没有看到太多实际应用。但是对的激活，或者这些中间的激活能够到达网络的更深层。这种方式确实有助于解决梯度消失和梯度爆炸问题，让我们在训练更深网络的同时，又能保证良好的性能。也许从另外一个角度来看，随着网络越来深，网络连接会变得臃肿，但是<strong>ResNet</strong>确实在训练深度网络方面非常有效。</p>
<h1 id="残差网络为什么有用"><a href="#残差网络为什么有用" class="headerlink" title="残差网络为什么有用"></a>残差网络为什么有用</h1><p>残差网络使用ReLU作为激活函数，残差块学习恒等函数非常容易，从而确定网络学习不受影响，甚至残差块能提高性能，至少不会降低性能。</p>
<p><a href="https://imgchr.com/i/BSnBTS"><img src="https://s1.ax1x.com/2020/10/20/BSnBTS.png" alt="BSnBTS.png"></a></p>
<h1 id="1×1卷积"><a href="#1×1卷积" class="headerlink" title="1×1卷积"></a>1×1卷积</h1><p><img src="http://www.ai-start.com/dl2017/images/7522d4cbc42b7db1c5a05bc461106590.png" alt=""></p>
<p>相当于6×6＝36个单元格，对每一个单元格所在的信道做了一个全连接网络，所以1×1卷积又叫网络中的网络。</p>
<p><img src="http://www.ai-start.com/dl2017/images/49a16fdc10769a86355911f9e324c728.png" alt=""></p>
<p>使用池化层可以压缩高度和宽度，使用1×1卷积可以控制信道数。</p>
<p>可以用32个大小为1×1的过滤器，严格来讲每个过滤器大小都是1×1×192维，因为过滤器中通道数量必须与输入层中通道的数量保持一致。但是你使用了32个过滤器，输出层为28×28×32，这就是压缩通道数的方法</p>
<h1 id="Inception网络"><a href="#Inception网络" class="headerlink" title="Inception网络"></a>Inception网络</h1><p><img src="http://www.ai-start.com/dl2017/images/46cf8f4fe80f47de754d0e0f13945941.png" alt=""></p>
<p>使用不同的卷积核对某个输入量进行卷积，并将结果叠加在一起组成新的输出，这样一个单元称为Inception网络的基本单元<br><img src="http://www.ai-start.com/dl2017/images/16a042a0f2d3866909533d409ff2ce3b.png" alt=""></p>
<p>将这些基本模块组合起来就形成了Inception网络：<br><img src="http://www.ai-start.com/dl2017/images/1f2a024a28f664aa704be53cea7ca6f8.png" alt=""></p>
<h1 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h1><p>你拥有的数据越多，你需要冻结的层数越少，能够训练的层数就越多。<br>如果有大量数据，就可以把预训练的整个网络作为一个初始化，然后重新训练整个网络</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
  </entry>
  <entry>
    <title>6.超参数调试、Batch正则化和程序框架</title>
    <url>/2020100833501/</url>
    <content><![CDATA[<p><em>这篇有点水，Batch Norm还是不太理解，很多笔记是直接摘抄的</em></p>
<h1 id="调试处理"><a href="#调试处理" class="headerlink" title="调试处理"></a>调试处理</h1><p>超参数优先级排序：</p>
<ol>
<li>学习率$\alpha$</li>
<li><strong>Momentum</strong>算法中的$\beta$；隐藏层单元数量；mini-batch大小</li>
<li>神经网络层数；学习率下降参数；$\beta_{1}=0.9,\beta_{2}=0.999,\varepsilon=10^{-8}$</li>
</ol>
<p><strong>超参数搜索：</strong></p>
<ol>
<li><p>在参数空间中随机取值：</p>
<p><img src="https://s1.ax1x.com/2020/10/10/0srLq0.png" alt="0srLq0.png" style="zoom:67%;" /></p>
</li>
<li><p>粗糙到精细的策略：</p>
<p><img src="https://s1.ax1x.com/2020/10/10/0ssDe0.png" alt="0ssDe0.png" style="zoom:67%;" /></p>
<p>先在参数空间中随机选择，发现最优值大概在某一区域分布时，则放大这块小区域，在这块小区域中更密集地取值或随机取值。</p>
</li>
</ol>
<h1 id="为超参数选择合适的范围"><a href="#为超参数选择合适的范围" class="headerlink" title="为超参数选择合适的范围"></a>为超参数选择合适的范围</h1><p>放弃线性轴而选择<strong>对数轴</strong>搜索超参数。<br>因为在不同的区域，超参数微小的变化对模型的优化影响不同，这显然是不公平的。</p>
<p>例如：在[0.0001,1]这个范围内取值时，如果采用线性轴，在[0.0001,0.1]这个区域中的计算资源仅占10%，而在[0.1,1]这个区域中的计算资源占90%，这样不太好。而采用对数轴，分别依次取0.0001，0.001，0.01，0.1，1，在对数轴上均匀随机取点，这样，在0.0001到0.001之间，就会有更多的搜索资源可用。<br>在python中，对数轴取值这样做：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r = -<span class="number">4</span> * np.random.rand()</span><br><span class="line">alpha = <span class="number">10</span> ** r</span><br></pre></td></tr></table></figure>
<p>对于$\beta$，道理同上 ：$\beta \in [0.9,0.999]$，我们只需要讨论$1-\beta$的范围，即$[0.1,0.001]$（这里颠倒了，是因为能够与[0.9,0.999]对应上）</p>
<p>为什么用线性轴取值不是个好办法，这是因为当$\beta$接近1时，所得结果的灵敏度会变化，即使有微小的变化。所以$\beta$在0.9到0.9005之间取值，无关紧要，你的结果几乎不会变化。但值如果在0.999到0.9995之间，这会对你的算法产生巨大影响。</p>
<p><img src="http://www.ai-start.com/dl2017/images/bb7feac2d0698b8721bfedbc67cc6289.png" alt=""></p>
<h1 id="超参数调试实践"><a href="#超参数调试实践" class="headerlink" title="超参数调试实践"></a>超参数调试实践</h1><p>关于如何搜索超参数的问题，大概两种重要的思想流派或人们通常采用的两种重要但不同的方式：</p>
<ol>
<li>Babysitting one model<br>像个保姆一样，精心的照看一个模型，耐心地调整学习率以及各个超参数，以希望模型的损失越来越低，性能越来越好。</li>
<li>Training Many models in parallel<br>同时训练很多模型，但是不怎么管，最后只挑那个表现最优秀的。</li>
</ol>
<p>计算资源多，选第二种，否则没得选，安心当保姆</p>
<h1 id="归一化网络的激活函数"><a href="#归一化网络的激活函数" class="headerlink" title="归一化网络的激活函数"></a>归一化网络的激活函数</h1><p>吴恩达老师讲的归一化激活函数真正归一的对象是$z=wx+b$中的$z$</p>
<script type="math/tex; mode=display">
\mu = \frac{1}{m}\sum z^{(i)}</script><script type="math/tex; mode=display">
\sigma ^{2}=\frac{1}{m}\sum (z^{(i)}-\mu)^{2}</script><script type="math/tex; mode=display">
z^{(i)}_{norm}=\frac{z^{(i)}-\mu}{\sqrt{\sigma ^{2}+\varepsilon}}</script><script type="math/tex; mode=display">
\tilde{z} = \gamma z^{(i)}_{norm} + \beta</script><p>前三个公式将z值进行了归一化。<br>第四个公式会将正规化后的数据进行缩放和平移变换。$\gamma$和$\beta$是两个需要学习的参数，通过学习调整到合适的值。</p>
<p>这段笔记有助于理解归一化的意义：<br><img src="https://s1.ax1x.com/2020/10/10/0y15WT.png" alt="0y15WT.png"></p>
<h1 id="Batch-Norm为什么奏效"><a href="#Batch-Norm为什么奏效" class="headerlink" title="Batch Norm为什么奏效"></a>Batch Norm为什么奏效</h1><ol>
<li><p>和输入归一化类似，使均值为0，方差为1，从而加速学习。</p>
</li>
<li><p>使权重比网络更滞后或更深层，相比于神经网络中前层的权重，后层更能经受得住变化。</p>
<blockquote>
<p><strong>Batch</strong>归一化减少了输入值改变的问题，它的确使这些值变得更稳定，神经网络的之后层就会有更坚实的基础。即使使输入分布改变了一些，它会改变得更少。它做的是当前层保持学习，当改变时，迫使后层适应的程度减小了，你可以这样想，它减弱了前层参数的作用与后层参数的作用之间的联系，它使得网络每层都可以自己学习，稍稍独立于其它层，这有助于加速整个网络的学习。</p>
<p>我会把<strong>Batch</strong>归一化当成一种正则化，这确实不是其目的，但有时它会对你的算法有额外的期望效应或非期望效应。但是不要把<strong>Batch</strong>归一化当作正则化，把它当作将你归一化隐藏单元激活值并加速学习的方式，我认为正则化几乎是一个意想不到的副作用。</p>
</blockquote>
</li>
</ol>
<h1 id="测试时的Batch-Norm"><a href="#测试时的Batch-Norm" class="headerlink" title="测试时的Batch Norm"></a>测试时的Batch Norm</h1><blockquote>
<p>在训练时，$\mu$和$\sigma^{2}$是在整个<strong>mini-batch</strong>上计算出来的，但在测试时，你可能需要逐一处理样本，方法是根据你的训练集估算$\mu$和$\sigma^{2}$，估算的方式有很多种，理论上你可以在最终的网络中运行整个训练集来得到$\mu$和$\sigma^{2}$，但在实际操作中，我们通常运用指数加权平均来追踪$\mu$和$\sigma^{2}$的值。还可以用指数加权平均，有时也叫做流动平均来粗略估算$\mu$和$\sigma^{2}$，然后在测试中使用和的值来进行你所需要的隐藏单元值的调整。在实践中，不管你用什么方式估算$\mu$和$\sigma^{2}$，这套过程都是比较稳健的，因此我不太会担心你具体的操作方式，而且如果你使用的是某种深度学习框架，通常会有默认的估算$\mu$和$\sigma^{2}$的方式，应该一样会起到比较好的效果。但在实践中，任何合理的估算你的隐藏单元值的均值和方差的方式，在测试中应该都会有效。</p>
</blockquote>
<h1 id="Softmax回归"><a href="#Softmax回归" class="headerlink" title="Softmax回归"></a>Softmax回归</h1><p>非逻辑回归，可以映射更多类别。一般在神经网络的最后一层。会将最后的结果归一化。</p>
<p>通常与交叉熵损失函数结合使用。</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
  </entry>
  <entry>
    <title>5.优化算法</title>
    <url>/2020100337967/</url>
    <content><![CDATA[<h1 id="Mini-batch梯度下降法"><a href="#Mini-batch梯度下降法" class="headerlink" title="Mini-batch梯度下降法"></a>Mini-batch梯度下降法</h1><p>将较大的训练集分割为较小的子集，这些子集叫做<strong>mini-batch</strong>。</p>
<p>如果mini-batch的大小是2的n次方，代码运行的会快一点，64~512的mini-batch比较常见。</p>
<p>假设训练集有5000,000个样本，mini-batch的大小为1000，则整个训练集一共有5000个mini-batch；使用batch训练，遍历整个训练集，梯度下降法只能下降一次，使用mini-batch，遍历一次训练集可以下降5000次；mini-batch大小为1时，则为随机梯度下降，噪声会减小，但会失去所有向量化带来的加速，因为一次性只处理了一个训练样本，这样效率过于低下。选择适合的mini-batch大小。</p>
<p>1 <strong>epoch</strong>代表遍历一次训练集。</p>
<h1 id="指数加权平均数"><a href="#指数加权平均数" class="headerlink" title="指数加权平均数"></a>指数加权平均数</h1><p>接下来我就翻译翻译，什么叫tmd的<strong>指数加权平均数</strong>。</p>
<ol>
<li><p><strong>平均数</strong>：n个数据的总和除以n</p>
<script type="math/tex; mode=display">
average = \frac{1}{n}\sum_{i=1}^{n}x_{i}</script></li>
<li><p><strong>加权平均数</strong>：每个数据乘以其权重，最后求和。</p>
<script type="math/tex; mode=display">
average = \sum_{i=1}^{n}p_{i}x_{i},其中\sum_{i=1}^{n}p_{i}=1</script></li>
<li><p><strong>指数加权平均数</strong>：权值以指数形式存在的<strong>加权平均数</strong><br>背景是温度预测。<br>关键公式：</p>
<script type="math/tex; mode=display">
(1)v_{t}=\beta v_{t-1}+(1-\beta)\theta_{t}</script><p>解释一下各个参数：</p>
<ul>
<li>$v_{t}$：第t天的平均温度</li>
<li>$\beta$：超参数</li>
<li>$\theta_{t}$：第t天的温度</li>
</ul>
<p><img src="http://www.ai-start.com/dl2017/images/9ab7565d5a3e13a9a525ec6d2f119a79.png" alt=""></p>
<p>公式里没看到指数啊？为什么就叫指数加权平均数了呢？</p>
<p>其实公式(1)是一个递推关系式，指数就藏在里面：</p>
<script type="math/tex; mode=display">
v_{100}=0.9v_{99}+0.1\theta_{100}=0.9(0.9v_{98}+0.1\theta_{99})+0.1\theta_{100}=0.1\theta_{100}+0.9\times 0.1\theta_{99}+0.9^{2}v_{98}=\cdots</script><p>由此我们可以看到$v_{99}$的权重为0.9，而$v_{98}$的权重就降为了0.81，随着不断展开，v的距离越远，其权重的次幂就会越高，权重越低。</p>
</li>
</ol>
<h2 id="指数加权平均的偏差修正"><a href="#指数加权平均的偏差修正" class="headerlink" title="指数加权平均的偏差修正"></a>指数加权平均的偏差修正</h2><p>帮助模型在早期获得更好的预测。</p>
<p>不用$v_{t}$，而用$\frac{v_{t}}{1-\beta^{t}}$，t就是现在的天数。举个具体例子，当t=2时，$1-\beta^{t}=1-0.98^{2}=0.0396$，因此对第二天温度的估测变成了$\frac{v_{2}}{0.0396}=\frac{0.0196 \theta_{1}+0.02 \theta_{2}}{0.0396}$，也就是$\theta_{1}$和$\theta_{2}$的加权平均数，并去除了偏差。你会发现随着增加，接近于0，所以当很大的时候，偏差修正几乎没有作用，因此当较大的时候，紫线基本和绿线重合了。</p>
<p><img src="http://www.ai-start.com/dl2017/images/26a3c3022a7f7ae7ba0cd27fc74cbcf6.png" alt=""></p>
<h1 id="梯度下降优化算法"><a href="#梯度下降优化算法" class="headerlink" title="梯度下降优化算法"></a>梯度下降优化算法</h1><h2 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a>Momentum</h2><p>动量梯度下降算法。原理：计算梯度的指数加权平均数，利用其更新权重。运行速度几乎总是快于标准梯度下降算法。</p>
<p>例如这个成本函数：</p>
<p><img src="http://www.ai-start.com/dl2017/images/f378695f4b475da6546b6ab239d27a3d.png" alt=""></p>
<p>红点代表最小值，从蓝点开始梯度下降，为了使梯度下降的速度足够快，需要学习率尽可能高，但学习率太高，可能会偏离函数范围（紫色线），所以需要选择一个合理的学习率。</p>
<p>另一个看待问题的角度是，在纵轴上，你希望学习慢一点，因为你不想要这些摆动，但是在横轴上，你希望加快学习，你希望快速从左向右移，移向最小值，移向红点。使用动量梯度下降法，第t次迭代的过程中，使用mini-batch计算微分dW和db，套用指数加权平均数公式$v=\beta v+(1-\beta) \theta_{t}$，计算：</p>
<script type="math/tex; mode=display">
v_{d W}=\beta v_{d W}+(1-\beta) d W</script><script type="math/tex; mode=display">
v_{d b}=\beta v_{d b}+(1-\beta) d b</script><p>然后更新W和b：</p>
<script type="math/tex; mode=display">
W:=W-\alpha v_{d W}</script><script type="math/tex; mode=display">
b:=b-\alpha v_{d b}</script><p><em>在上几个导数中，你会发现这些纵轴上的摆动平均值接近于零，所以在纵轴方向，你希望放慢一点，平均过程中，正负数相互抵消，所以平均值接近于零。但在横轴方向，所有的微分都指向横轴方向，因此横轴方向的平均值仍然较大，因此用算法几次迭代后，你发现动量梯度下降法，最终纵轴方向的摆动变小了，横轴方向运动更快，因此你的算法走了一条更加直接的路径，在抵达最小值的路上减少了摆动。</em></p>
<p><strong>Momentum</strong>更加适合碗状函数，<strong>Momentum项提供了一个W轴的初速度。</strong></p>
<p>此时有两个超参数：$\alpha$、$\beta$。$\beta=0.9$是很好的鲁棒数（robust）</p>
<h2 id="RMSprop"><a href="#RMSprop" class="headerlink" title="RMSprop"></a>RMSprop</h2><p><strong>RMSprop</strong>算法，全称是<strong>root mean square prop</strong>算法，它也可以加速梯度下降。</p>
<p><strong>RMSprop</strong>可以减缓b轴的摆动，同时加快，至少不是减缓x轴的速度。</p>
<p>套用指数加权平均数公式$v=\beta v+(1-\beta) \theta_{t}$，计算：</p>
<script type="math/tex; mode=display">
S_{d W}=\beta S_{d W}+(1-\beta) d W^{2}</script><script type="math/tex; mode=display">
S_{d b}=\beta S_{d b}+(1-\beta) d b^{2}</script><p>然后更新W和b：</p>
<script type="math/tex; mode=display">
W:=W-\alpha \frac{d W}{\sqrt{S_{d W}}}</script><script type="math/tex; mode=display">
b:=b-\alpha \frac{d b}{\sqrt{S_{d b}}}</script><p>原理：因为原来的函数斜率较大，db就比较大，而dW较小，所以在更新参数时，W会减去较小的一项，b会减去较大的一项，W下降的会慢一些，b会下降的快一些，所以就可以部分消除在b轴上的摆动</p>
<p><img src="http://www.ai-start.com/dl2017/images/d43cf7898bd88adff4aaac607c1bd5a1.png" alt=""></p>
<p><strong>RMSprop</strong>的影响就是你的更新最后会变成这样（绿色线），纵轴方向上摆动较小，而横轴方向继续推进。还有个影响就是，你可以用一个更大学习率，然后加快学习，而无须在纵轴上垂直方向偏离。</p>
<p>为了确保数值稳定，在实际操练的时候，你要在分母上加上一个很小很小的$\varepsilon =10^{-8}$</p>
<h2 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h2><p><strong>Adam≈Momentum+RMSprop</strong></p>
<ol>
<li><p>初始化：</p>
<script type="math/tex; mode=display">
v_{d W}=0, \quad S_{d W}=0, \quad v_{d b}=0, \quad S_{d b}=0</script></li>
<li><p>使用mini-batch计算：</p>
<script type="math/tex; mode=display">
v_{d W}=\beta_{1} v_{d W}+\left(1-\beta_{1}\right) d W,\quad v_{d b}=\beta_{1} v_{d b}+\left(1-\beta_{1}\right) d b</script><script type="math/tex; mode=display">
S_{d W}=\beta_{2} S_{d W}+\left(1-\beta_{2}\right)(d W)^{2},\quad S_{d b}=\beta_{2} S_{d b}+\left(1-\beta_{2}\right)(d b)^{2}</script><script type="math/tex; mode=display">
v_{dW}^{corrected}=\frac{v_{dW}}{1-\beta_{1}^{t}},\quad v_{db}^{corrected}=\frac{v_{db}}{1-\beta_{1}^{t}}</script><script type="math/tex; mode=display">
S_{dW}^{corrected}=\frac{v_{dW}}{1-\beta_{2}^{t}},\quad S_{db}^{corrected}=\frac{v_{db}}{1-\beta_{2}^{t}}</script></li>
<li><p>更新参数：</p>
<script type="math/tex; mode=display">
W:=W-\alpha \frac{v_{dW}^{corrected}}{\sqrt{S_{dW}^{corrected}}+\varepsilon}</script><script type="math/tex; mode=display">
b:=b-\alpha \frac{v_{db}^{corrected}}{\sqrt{S_{db}^{corrected}}+\varepsilon}</script></li>
</ol>
<p>超参数选择：</p>
<ul>
<li>$\alpha$：需要调试</li>
<li>$\beta_{1}$：0.9</li>
<li>$\beta_{2}$：0.999</li>
<li>$\varepsilon$：$10^{-8}$</li>
</ul>
<p><strong>Adam</strong>代表的是<strong>Adaptive Moment Estimation</strong>，$\beta_{1}$用于计算这个微分（$dW$），叫做第一矩，$\beta_{2}$用来计算平方数的指数加权平均数（$(dW)^{2}$），叫做第二矩，所以<strong>Adam</strong>的名字由此而来。</p>
<p>Adam由于有更多的参数，在迭代过程中会占用更多的显存。</p>
<h1 id="学习率衰减"><a href="#学习率衰减" class="headerlink" title="学习率衰减"></a>学习率衰减</h1><p><em>对应《深度学习入门》中的AdaGrad</em></p>
<p>学习率为固定值时，使用mini-batch训练模型有时会有一些噪声，这使得梯度下降时，最终会在最小值附近较大的区域内摆动，而不会收敛到极小值。而使用学习率衰减，可以使学习率在迭代的过程中逐渐下降，使得梯度下降时，能够在最小值附近较小的区域内摆动，甚至可以直接收敛到极小值。</p>
<ol>
<li><p>线性衰减：</p>
<script type="math/tex; mode=display">
\alpha = \frac{1}{1+decayrate*epochnum}\alpha_{0}</script><p>decay-rate称为衰减率，epoch-num为代数，$\alpha_{0}$为初始学习率</p>
</li>
<li><p>指数衰减：</p>
<script type="math/tex; mode=display">
\alpha=\frac{k}{\sqrt{epochnum}}\alpha_{0},或\alpha=\frac{k}{\sqrt{t}}\alpha_{0}</script><p>t为mini-batch</p>
</li>
<li><p>离散下降：<br>在某个步骤有某个学习率之后，学习率减少一半；一会儿减少一半，一会儿又一半。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
  </entry>
  <entry>
    <title>4.深度学习实用层面</title>
    <url>/2020092741052/</url>
    <content><![CDATA[<h1 id="训练、验证、测试集"><a href="#训练、验证、测试集" class="headerlink" title="训练、验证、测试集"></a>训练、验证、测试集</h1><ol>
<li>如果数据集较小，可将所有数据按照3:1:1的比例分配训练集、验证集和测试集；<br>或7:3的比例分配训练集和测试集（无验证集）</li>
<li>如果数据集较大<ul>
<li>百万级别：训练集 : 验证集 : 测试集 = 98% : 1% : 1%</li>
<li>过百万级别：训练集 : 验证集 : 测试集 = 99.5% : 0.25% : 0.25%（或99.5% : 0.4% : 0.1%）</li>
</ul>
</li>
</ol>
<h1 id="偏差、方差"><a href="#偏差、方差" class="headerlink" title="偏差、方差"></a>偏差、方差</h1><blockquote>
<p>知乎回答：<a href="https://www.zhihu.com/people/grindge">Jason Gu</a><br><a href="http://scott.fortmann-roe.com/docs/BiasVariance.html">Understanding the Bias-Variance Tradeoff</a></p>
</blockquote>
<p><strong>偏差：</strong>描述的是<strong>预测值（估计值）的期望与真实值之间的差距</strong>。偏差越大，越偏离真实数据，如下图第二行所示。</p>
<p><strong>方差：</strong>描述的是<strong>预测值</strong>的变化范围，离散程度，也就是<strong>离其期望值的距离</strong>。<strong>方差越大，数据的分布越分散</strong>，如下图右列所示。</p>
<p><img src="https://s1.ax1x.com/2020/09/27/0AM829.png" alt="0AM829.png" style="zoom:50%;" /></p>
<p>举例说明：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Train set error</th>
<th style="text-align:center">1%</th>
<th style="text-align:center">15%</th>
<th style="text-align:center">15%</th>
<th style="text-align:center">0.5%</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Dev set error</td>
<td style="text-align:center">11%</td>
<td style="text-align:center">16%</td>
<td style="text-align:center">30%</td>
<td style="text-align:center">1%</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">高方差</td>
<td style="text-align:center">高偏差</td>
<td style="text-align:center">高偏差&amp;高方差</td>
<td style="text-align:center">低偏差&amp;低方差</td>
</tr>
</tbody>
</table>
</div>
<h1 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h1><p>作用：减少过拟合</p>
<ul>
<li>L1范数：<script type="math/tex; mode=display">
L1=\|w\|_{1}</script></li>
<li>L2范数（更加常用）：<script type="math/tex; mode=display">
L2=\|w\|_{2}^{2}</script></li>
</ul>
<p>正则化：</p>
<ul>
<li><p>L1正则化：</p>
<script type="math/tex; mode=display">
J(w, b)=\frac{1}{m} \sum_{i=1}^{m} L\left(\hat{y}^{(i)}, y^{(i)}\right) + \frac{\lambda}{m}\|\omega\|_{1}</script></li>
<li><p>L2正则化：</p>
<script type="math/tex; mode=display">
J(w, b)=\frac{1}{m} \sum_{i=1}^{m} L\left(\hat{y}^{(i)}, y^{(i)}\right) + \frac{\lambda}{2 m}\|\omega\|_{2}^{2}</script></li>
</ul>
<h2 id="在神经网络中实现正则化"><a href="#在神经网络中实现正则化" class="headerlink" title="在神经网络中实现正则化"></a>在神经网络中实现正则化</h2><script type="math/tex; mode=display">
  (1)J(w^{[1]},b^{[1]},...,w^{[L]},b^{[L]})=\frac{1}{m} \sum_{i=1}^{m} L\left(\hat{y}^{(i)}, y^{(i)}\right)+\frac{\lambda}{2 m}\sum_{l=1}^{L}\|W^{[l]}\|_{F}^{2}</script><p>(1)神经网络的成本函数包含$W^{[1]},b^{[1]}$到$W^{[l]},b^{[l]}$所有参数，$L$为神经网络层数。成本函数等于m个训练样本损失函数的总和的平均值，正则项为：</p>
<script type="math/tex; mode=display">
    \frac{\lambda}{2 m}\sum_{l=1}^{L}\|W^{[l]}\|_{F}^{2}</script><p>矩阵中所有元素的平方和为：</p>
<script type="math/tex; mode=display">
\|W^{[l]}\|^{2}</script><script type="math/tex; mode=display">
(2)\|W^{[l]}\|_{F}^{2}=\sum_{i=1}^{n^{[l-1]}} \sum_{j=1}^{n^{[l]}}(w_{ij})^{2}</script><p>(2)第一个求和符号其值$i$从1到$n^{[l-1]}$，第二个求和符号其值$j$从1到$n^{[l]}$，因为$W$是一个$n^{[l]}×n^{[l-1]}$的多维矩阵，$n^{[l]}$表示$l$层单元的数量，$n^{[l-1]}$表示$l-1$层单元的数量。</p>
<h2 id="使用范数实现梯度下降"><a href="#使用范数实现梯度下降" class="headerlink" title="使用范数实现梯度下降"></a>使用范数实现梯度下降</h2><p><img src="https://s1.ax1x.com/2020/09/28/0E0gBT.jpg" alt="0E0gBT.jpg"></p>
<h1 id="Dropout正则化"><a href="#Dropout正则化" class="headerlink" title="Dropout正则化"></a>Dropout正则化</h1><p>随机删除一些神经网络中的神经元及从该神经元进出的连线。</p>
<p><img src="https://s1.ax1x.com/2020/09/28/0ViNEd.png" alt="0ViNEd.png" style="zoom:50%;" /></p>
<blockquote>
<p>《深度学习入门》</p>
</blockquote>
<p><strong>集成学习</strong>：让多个模型单独学习，推理时再取多个模型的输出平均值，可提高神经网络识别精度。<br>集成学习与Dropout有密切的联系，可以将Dropout理解为，通过在学习过程中随机删除神经元，从而每一次都让不同的模型进行学习。推理时通过对神经元的输出乘以删除比例，可以取得模型的平均值。可以理解为，Dropout将集成学习的效果（模拟地）通过一个网络实现了。</p>
<h2 id="实施Dropout"><a href="#实施Dropout" class="headerlink" title="实施Dropout"></a>实施Dropout</h2><h3 id="正向传播"><a href="#正向传播" class="headerlink" title="正向传播"></a>正向传播</h3><p>对于已经被激活的矩阵A1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A1 = [[ <span class="number">0.46544685</span>,  <span class="number">0.34576201</span>, -<span class="number">0.00239743</span>,  <span class="number">0.34576201</span>, -<span class="number">0.22172585</span>],</span><br><span class="line">      [ <span class="number">0.57248826</span>,  <span class="number">0.42527883</span>, -<span class="number">0.00294878</span>,  <span class="number">0.42527883</span>, -<span class="number">0.27271738</span>],</span><br><span class="line">      [ <span class="number">0.45465921</span>,  <span class="number">0.3377483</span>,  -<span class="number">0.00234186</span>,  <span class="number">0.3377483</span>,  -<span class="number">0.21658692</span>]]</span><br><span class="line">A1 = np.array(A1)</span><br></pre></td></tr></table></figure>
<p><code>keep_prob</code>表示保留神经元的概率</p>
<ol>
<li><p>初始化一个mask：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mask = np.random.randn(A1.shape[<span class="number">0</span>], A1.shape[<span class="number">1</span>])</span><br><span class="line">mask = mask &lt; keep_prob  <span class="comment"># mask会变成一个布尔型数组</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用mask对A1进行遮罩：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A1 = np.multiply(A1, mask)</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了修正期望值，需要除以<code>keep_prob</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A1 = A1 / keep_prob</span><br></pre></td></tr></table></figure>
<hr>
<p><em>这里说一点自己的理解：这个mask翻译成遮罩就非常灵性，可以想象到有一个跟A1一样大的板子叫mask，遮挡在A1上，值为True的地方是个洞，就可以使A1中的数字露出来，而每次这些洞的位置都是随机的。</em></p>
</li>
</ol>
<h3 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h3><p>与正向传播非常类似，只需要两步，<strong>正向传播与反向传播需要使用相同的mask</strong>，所以反向传播时，要将正向传播所使用的mask作为参数，传递给反向传播的函数。</p>
<p>假设只有2层的神经网络：</p>
<ol>
<li><p>使用mask对dA2进行遮罩：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dA2 = np.multiply(mask,dA2)</span><br></pre></td></tr></table></figure>
</li>
<li><p>修正期望值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dA2 = dA2 / keep_prob</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="理解dropout"><a href="#理解dropout" class="headerlink" title="理解dropout"></a>理解dropout</h1><p>不依赖于某一个特定的特征，所以必须将权重传播出去。因为神经元可能会被随时删除，通过传播权重，给其他输入增加一点权重，从而达到压缩权重的平方范数的效果，这和L2正则化的效果类似。</p>
<p>每一层的<strong>keep_prob</strong>可以不同，如果担心某些层比其他层更容易发生过拟合，可以将keep_prob设置地更小；缺点是为了使用交叉验证，需要搜索更多的参数。另一种方案是在一些层上应用<strong>dropout</strong>，而有些层不用dropout，应用dropout的层只含有一个超级参数，就是keep-prob。</p>
<p>在计算机视觉领域，dropout很常用，因为输入的像素点很多，但要牢记dropout只是一种正则化方法。dropout的缺点是代价函数J不明确，每次迭代都会随机移除一些节点，导致无法确定梯度下降的性能。这导致我们所优化的代价函数失去了其应有的意义。</p>
<h1 id="其他正则化方法"><a href="#其他正则化方法" class="headerlink" title="其他正则化方法"></a>其他正则化方法</h1><h2 id="数据扩增"><a href="#数据扩增" class="headerlink" title="数据扩增"></a>数据扩增</h2><p>如果采集新的数据比较困难，可以通过对图片的基本操作：旋转、反转、裁剪等增加训练集，虽然这种方式不如新数据的效果好，但基本没有额外花销。从而以近乎零成本正则化数据集，减少过拟合。</p>
<h2 id="early-stopping"><a href="#early-stopping" class="headerlink" title="early stopping"></a>early stopping</h2><p>在模型还没有发生过拟合（或者过拟合较低）的情况下，提早结束神经网络的训练过程。</p>
<p>优点：</p>
<ul>
<li>防止过拟合</li>
<li>模型训练的代价较低</li>
</ul>
<p>缺点：（提早结束训练，性能不太好，具体表现如下）</p>
<ul>
<li><p>代价函数J没有尽可能降到最低</p>
</li>
<li><p>模型的方差可能也没有降到最低</p>
<hr>
<p><em>通过一种办法同时降低偏差与方差的方法显然是不太现实的。</em></p>
</li>
</ul>
<p>early stopping适用于对模型要求不高的情况，但我认为深度学习没有最好，只有更好，我们只会追求越来越好的模型，而不是在某一个地方驻足，这显然是一个”治标不治本“的办法。</p>
<h1 id="归一化输入"><a href="#归一化输入" class="headerlink" title="归一化输入"></a>归一化输入</h1><p>先说说什么是<strong>归一化</strong>：</p>
<p>让所有数据映射到(0,1)中的方法叫做归一化。公式为：</p>
<script type="math/tex; mode=display">
x^{\prime}=\frac{x-\min (x)}{\max (x)-\min (x)}</script><p>这里的说法其实不太准确，引用知乎答者的回答：</p>
<blockquote>
<p><a href="https://www.zhihu.com/people/jaimer-ais">gokenu</a></p>
<p>正在做相关的作业,我来做一些小小的努力,不让概念太混乱</p>
<p>查看了<a href="http://www.zhihu.com/people/bee96a251718343e7e390ecf0a66cc48">@龚焱</a>的回答中提到的wiki 大致意思是归一化和标准化都属于四种Feature scaling(特征缩放),这四种分别是 </p>
<ol>
<li>Rescaling (min-max normalization)  有时简称normalization(有点坑)<img src="https://www.zhihu.com/equation?tex=x%5E%7B%27%7D+%3D+%5Cfrac%7Bx-min%28x%29%7D%7Bmax%28x%29-min%28x%29%7D" alt="[公式]"> </li>
<li>Mean normalization  <img src="https://www.zhihu.com/equation?tex=x%5E%7B%27%7D+%3D+%5Cfrac%7Bx-mean%28x%29%7D%7Bmax%28x%29-min%28x%29%7D+" alt="[公式]"> </li>
<li>Standardization(Z-score normalization)  <img src="https://www.zhihu.com/equation?tex=+x%5E%7B%27%7D+%3D+%5Cfrac%7Bx-mean%28x%29%7D%7B%5Csigma%7D" alt="[公式]"> </li>
<li>Scaling to unit length  <img src="https://www.zhihu.com/equation?tex=x%5E%7B%27%7D+%3D+%5Cfrac%7Bx%7D%7B%7C%7Cx%7C%7C%7D" alt="[公式]"> </li>
</ol>
<p>对比了一下其它回答和一些博客,一般把第一种叫做归一化,第三种叫做标准化.不是很清楚是怎么翻译的.正则化的英文应该是Regularization,有些博客把这也弄混了.正则化是完全不同的事情了.</p>
<p>然后关于在ML里面是用第一个好还是第三个好,感觉大家都讨论的很激烈.有的认为取决于你的数据的特点(是否稀疏),有的认为取决于数据是否有明确的界限. 个人不太赞同只有归一化让椭圆变成了圆的想法,在我的梯度下降中,两种都加速得挺好…</p>
</blockquote>
<hr>
<p>归一化输入分为两步：</p>
<ol>
<li>零均值化</li>
<li>归一化方差</li>
</ol>
<p>使用二维数据说明什么是归一化输入：</p>
<p><img src="https://s1.ax1x.com/2020/10/01/0MIpo6.png" alt="0MIpo6.png"></p>
<p>第一步是零均值化：</p>
<script type="math/tex; mode=display">
\mu=\frac{1}{m} \sum_{i=1}^{m} x^{(i)}</script><script type="math/tex; mode=display">
x:=x-\mu</script><p>意思是移动训练集，直到它完成零均值化。零均值化后：</p>
<p><img src="https://s1.ax1x.com/2020/10/01/0MIAQH.png" alt="0MIAQH.png"></p>
<blockquote>
<p><a href="http://www.ai-start.com/dl2017/html/lesson2-week1.html">深度学习笔记</a></p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/10/01/0ML34I.png" alt="0ML34I.png"></p>
<p>这里应该套用的是</p>
<script type="math/tex; mode=display">
x^{\prime}=\frac{x-\operatorname{mean}(x)}{\sigma}</script><p>只不过经过步骤一，mean变成0了，$\sigma$变成$\sigma^{2}$了</p>
<p><img src="https://s1.ax1x.com/2020/10/01/0MIc01.png" alt="0MIc01.png"></p>
<p>以上只是解释了归一化输入的两个步骤，接下来解释为什么要归一化输入。</p>
<p><img src="http://www.ai-start.com/dl2017/images/4d0c183882a140ecd205f1618243d7f8.png" alt=""></p>
<p>吴恩达老师的这张ppt非常直观。</p>
<p>使用归一化输入后，代价函数看起来更加对称，无论从什么位置开始，梯度下降都会更快，可以在梯度下降中使用更大的步长，从而提高学习的速度。</p>
<h1 id="梯度消失-梯度爆炸"><a href="#梯度消失-梯度爆炸" class="headerlink" title="梯度消失/梯度爆炸"></a>梯度消失/梯度爆炸</h1><p>训练深层次的神经网络时，导数（梯度）会变得非常大或非常小，甚至是指数级变小，这使训练难度变大。</p>
<p>假设要训练的神经网络长这样：</p>
<p><img src="https://s1.ax1x.com/2020/10/02/0Qd4vF.png" alt="0Qd4vF.png"></p>
<p>其中激活函数</p>
<script type="math/tex; mode=display">
g(z)=z,b^{[l]}=0</script><p>则</p>
<script type="math/tex; mode=display">
\hat{y}=W^{[l]}W^{[l-1]}W^{[l-2]}\cdot \cdot \cdot W^{[3]}W^{[2]}W^{[1]}x</script><p>又</p>
<script type="math/tex; mode=display">
z^{[1]}=W^{[1]}x,a^{[1]}=g(z^{[1]})=z^{[1]}</script><p>则</p>
<script type="math/tex; mode=display">
\hat{y}=W^{[l]}a^{[l-1]}x</script><p>假设</p>
<script type="math/tex; mode=display">
W^{[l]}=
\begin{bmatrix}
 1.5 & 0\\ 
 0 & 1.5
\end{bmatrix}</script><p>则</p>
<script type="math/tex; mode=display">
\hat{y}=W^{[l]}
\begin{bmatrix}
 1.5 & 0\\ 
 0 & 1.5
\end{bmatrix}^{[l-1]}x</script><p>此时，指数$[l-1]$就会导致梯度爆炸；如果</p>
<script type="math/tex; mode=display">
W^{[l]}=
\begin{bmatrix}
 0.5 & 0\\ 
 0 & 0.5
\end{bmatrix}</script><p>此时，指数$[l-1]$就会导致梯度消失。</p>
<h2 id="权重初始化"><a href="#权重初始化" class="headerlink" title="权重初始化"></a>权重初始化</h2><p>为了解决梯度消失/梯度爆炸，虽然不能彻底解决，但很有效。</p>
<p>以单个神经元为例：</p>
<p><img src="http://www.ai-start.com/dl2017/images/db9472c81a2cf6bb704dc398ea1cf017.png" alt=""></p>
<p>有4个输入特征，经过$a=g(z)$处理，最后得到$\hat{y}$。稍后讲深度网络时，这些输入表示为$a^{[l]}$，暂时我们用$x$表示。</p>
<p><img src="https://s1.ax1x.com/2020/10/02/0QDszV.png" alt="0QDszV.png"></p>
<ul>
<li>如果使用<strong>Relu</strong>作为激活函数，则用公式$\sqrt{\frac{2}{n^{[l-1]}}}$</li>
<li>如果使用<strong>tanh</strong>作为激活函数，则用公式$\sqrt{\frac{1}{n^{[l-1]}}}$</li>
</ul>
<p>吴恩达老师说：</p>
<p><img src="https://s1.ax1x.com/2020/10/02/0QrUl6.png" alt="0QrUl6.png"></p>
<p>意思是作为超参数时，调整的优先级较低。</p>
<h1 id="梯度检验"><a href="#梯度检验" class="headerlink" title="梯度检验"></a>梯度检验</h1><p>梯度检验是为了保证<strong>backprop</strong>正确实施，其对整个模型的训练没有作用，为了实现梯度检验，需要先了解梯度的数值逼近</p>
<h2 id="梯度的数值逼近"><a href="#梯度的数值逼近" class="headerlink" title="梯度的数值逼近"></a>梯度的数值逼近</h2><p>这里老师就是讲了个导数的第二种定义（双边误差）：</p>
<script type="math/tex; mode=display">
\left.f^{\prime} (\theta\right)=\frac{f(\theta + \varepsilon)-f(\theta-\varepsilon)}{2 \varepsilon}</script><p>使用双边误差而不使用单边误差是因为更加精确。</p>
<p>比较好理解，不多赘述了</p>
<h2 id="梯度检验-1"><a href="#梯度检验-1" class="headerlink" title="梯度检验"></a>梯度检验</h2><p>将所有$W$和$b$转换为向量，做连接运算，从而组合成一个巨大向量$\theta$，代价函数$J$是所有$W$和$b$的函数，即$J$是$\theta$的函数：</p>
<script type="math/tex; mode=display">
J\left(W^{[1]}, b^{[1]}, \ldots, W^{[l]}, b^{[l]}\right)=J(\theta)</script><p>将所有$dW$和$db$转换为矩阵，注意$dW$和$W$、$db$和$b$具有相同的维度。同样地，经过转换与连接操作后，得到一个巨大向量$d\theta$，它与$\theta$具有相同的维度，问题是：<strong>$d\theta$和代价函数$J$的梯度（坡度）有什么关系？</strong></p>
<p>首先，我们要清楚$J$是超参数$\theta$的一个函数，你也可以将$J$展开为$J\left(\theta_{1}, \theta_{2}, \theta_{3}, \ldots \ldots\right)$，不论超级参数向量$\theta$的维度是多少，为了实施梯度检验，要做的就是循环执行，从而对每个$\theta$也就是对每个组成元素计算$d \theta_{\text {approx }}[i]$的值，我使用双边误差，也就是：</p>
<script type="math/tex; mode=display">
d \theta_{\text {approx }}[i]=\frac{J\left(\theta_{1}, \theta_{2}, \ldots \theta_{i}+\varepsilon, \ldots\right)-J\left(\theta_{1}, \theta_{2}, \ldots \theta_{i}-\varepsilon, \ldots\right)}{2 \varepsilon}</script><p>只对$\theta_{i}$增加$\varepsilon$，其它项保持不变，使用的是双边误差，对另一边做同样的操作，减去$\varepsilon$，其它项全都保持不变。</p>
<p>$d \theta_{\text {approx }}[i]$应该逼近$d \theta_{\text {approx }}$，$d\theta[i]$是代价函数的偏导数，然后需要对i的每个值都执行这个运算，最后得到两个向量，得到$d\theta$的逼近值$d \theta_{\text {approx }}$，它与$d\theta$具有相同维度，它们两个与$\theta$具有相同维度，要做的就是验证这些向量是否彼此接近。</p>
<p>如何衡量彼此接近？</p>
<p>计算以下方程式：</p>
<script type="math/tex; mode=display">
\frac{\| d \theta_{approx}-d \theta \|_{2}}{\left\|d \theta_{approx} \right\|_{2}+\|d \theta\|_{2}}</script><p>上式的值为：</p>
<ul>
<li>$10^{-7}$：很好</li>
<li>$10^{-5}$：注意，可能会有bug</li>
<li>$10^{-3}$：有bug，需要检查所有$\theta$，看是否有一个具体的$i$值，使得$d \theta_{\text {approx }}[i]$ 与 $d \theta[i]$大不相同，并用它来追踪一些求导计算是否正确</li>
</ul>
<h2 id="梯度检验的注意事项"><a href="#梯度检验的注意事项" class="headerlink" title="梯度检验的注意事项"></a>梯度检验的注意事项</h2><ol>
<li><p>梯度检验仅用于调试，不能用于训练</p>
</li>
<li><p>如果算法的梯度检验失败，要检查所有项，尝试找到bug</p>
</li>
<li><p>在实施梯度检验时，如果使用正则化，请注意正则项。如果代价函数</p>
<script type="math/tex; mode=display">
J(\theta)=\frac{1}{m} \sum L\left(\hat{y}^{(i)}, y^{(i)}\right)+\frac{\lambda}{2 m} \sum\left\|W^{[l]}\right\|^{2}</script><p>这就是代价函数$J$的定义，$d\theta$等于与$\theta$相关的$J$函数的梯度，包括这个正则项，记住一定要包括这个正则项。</p>
</li>
<li><p>梯度检验不能与dropout一起使用，如有需要，则先将dropout的keep_prob设为1，使用梯度检验检查无误后，再调整keep_prob</p>
</li>
<li><p><img src="https://s1.ax1x.com/2020/10/02/0Q2ZY4.png" alt="0Q2ZY4.png"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
  </entry>
  <entry>
    <title>2020研究生数学建模大赛E题复盘</title>
    <url>/2020092217439/</url>
    <content><![CDATA[<h1 id="探索大雾演化规律，预测大雾变化趋势"><a href="#探索大雾演化规律，预测大雾变化趋势" class="headerlink" title="探索大雾演化规律，预测大雾变化趋势"></a>探索大雾演化规律，预测大雾变化趋势</h1><ol>
<li><p><strong>关键词</strong>：能见度分析，图像处理，深度学习，神经网络</p>
</li>
<li><p><strong>组队情况</strong></p>
<ul>
<li>19级学长 * 1</li>
<li>20级新生 * 2（我是其中之一）</li>
</ul>
<p><strong>Tips</strong>：选择队友请擦亮双眼，否则就会难受四天半</p>
</li>
<li><p>比赛时间：2020.9.17 8:00:00 ~ 2020.9.21 12:00:00</p>
</li>
<li><p>TimeLine</p>
<ul>
<li><p><strong>第一天（9.17）</strong>：上午八点开始，拿到密钥后解密试题，获得了题目之后，打印成纸质版方便看，A题直接就排除了，20级的同学高**在本科就参加过比赛，比较有经验，选题的任务就交给了他，其他题我没有细看，最后只确定了D题和E题。我看了D题，有些读不懂题，再看了一眼E题后，瞬间就来了兴趣，E题的第二三问已经指明了使用神经网络来做，而我最近刚学了神经网络，正好又在九点半去见了导师，顺便和导师交流了一下这道题目，觉得有的做。此时心中激情澎湃，上午已经有思路了，真好。但还是尊重高同学的意见，因为E题他一点也不懂，最后在下午，我们还是确定了E题。第一天还算比较轻松。</p>
</li>
<li><p><strong>第二天（9.18）</strong>：有些记不清了，晚上开始写代码的，想直接读取视频流，使用Pytorch的<strong>torchvision.io.read_video()</strong>接口直接加载视频，发现加载了半天没反应，自己拍了个两秒的视频，发现代码写的没毛病，加载太慢大概是一下两个原因：</p>
<ul>
<li>torchvision.io.read_video()封装的是ffmpeg的接口，我怀疑是它性能不行（章口就来啊，我可没求证，错了别打我~~）</li>
<li>电脑不行</li>
</ul>
<p>所以，我不直接加载视频了，换了个思路，打算制作自己的训练集和测试集。我也不知道为啥，脑子当时抽抽了，非要把间隔为15s的数据和间隔为1min的数据对应起来，所以我就把间隔为15s的数据四次求一次平均值，作为1min内的数据，这样就可以对应起来了，又用opencv的接口加载视频，每隔1min截一张图，其实根本没必要，因为第一问和第二问真没啥关系。（后来第四天发现被第一问的高同学的数据带跑偏了，我不用每隔一分钟截一张图，直接就按VIS_R06_12.his文件中的时间戳间隔15s截图就行）说的有点多了，其实就是用截的图做训练样本，能见度数据MOR做训练样本的标签。</p>
</li>
<li><p><strong>第三天（9.19）</strong>：早上醒来，发现8小时的视频只截出来466张图，不对啊，应该是480张才对，看了答疑论坛，才发现视频中居然有段视频丢失了，我靠，官方真会玩，这里还给留个彩蛋，大概是凌晨1点那里丢了14mins，正好对应上了，我本来想写个程序按照his中的时间戳截图的，难度太大，还要OCR监控里的时间水印，我就放弃了，没办法，直接把那一小时的视频给剪了，所以只剩下了不到7小时的有效数据。还是按照之前的思路，一共获得了近420张图片，300张训练集，120张测试集。制作自己的训练集是真的费时间，之前没用过，这里耗了将近一天的时间才做好。晚上试着开始搭神经网络，哎呀，这咋搭呀，可把我难住了，毕竟本菜鸡刚学了一个月的神经网络，脑子里只有全连接。爷青结啊！<br>肯定不能用全连接啊，一张照片1280*720，将近100W的像素点，搭多少层也是个问题，还有输出层该多少神经元呢，十万个为什么啊~~~<br>晚上搜了搜，┗|｀O′|┛ 嗷，人家都是用CNN的，没学过呀，不管了，CNN搞起来，像模像样的搭了一个1层卷积层+2层全连接的神经网络，就三点了，好不容易没bug了，然后爆显存了，我哭了</p>
</li>
<li><p><strong>第四天（9.20）</strong>：早上幸亏去了趟机房，有个研二的计算机大师哥，他点了我一句，可以用AlexNet啊，我去网上搜了搜，好像很流批的亚子，上午赶紧搭了个，原理咱也不懂，能跑就完事了，batch_size设置成3，Epoch设置成10，哇，显存也不爆了，Loss也下降了，爷青回！（我把图片Resize到了原图的1/4，要不还是会爆，终于知道为啥好显卡香了）<br>趁着神经网络训练着，高同学告诉我可以写论文了，此时搞心态的划水学长该登场了，真是不知道他干了啥，我本来想跟他说说我的思路，让他写的，最后我这块的论文还是得我写，太搞我心态了，当时真是气不过！后来还是得硬着头皮写，才发现了致命的问题！这也是我和高同学交流最多的时候，我发现数学建模大赛不是个写代码的比赛，而是个“写论文的比赛”。而我的模型因为数据集的问题，性能非常差，导致二三问没什么可写的了，真是惭愧啊，力气没用对地方。</p>
</li>
<li><p><strong>第四天半（9.21）</strong>：就是写论文了，还有改论文。</p>
</li>
</ul>
</li>
<li><p>赛后感想：</p>
<ol>
<li>队友很重要！队友很重要！队友很重要！</li>
<li>不能陷进去，写好论文很重要</li>
<li>深刻理解了：深度学习就是调包调参炼丹侠，哇哈哈哈哈</li>
</ol>
</li>
</ol>
<hr>
<p>赛是比完了，代码可没写完啊，等我完善完善，就开源。</p>
<p>主要解决以下问题：</p>
<ul>
<li>数据集分布不均匀，能见度为50的图片有240张，可以减少这些照片的数量，使用数据增强，增加其他样本的数量，从而使数据集分布的更加均匀</li>
<li>截图间隔改为15s，与his中的数据对应</li>
<li>稍微调整一下卷积核和步长，提高显卡的利用率</li>
</ul>
<hr>
<p>好像有白嫖算力的网站，等的找一找</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>3.浅层神经网络</title>
    <url>/2020082248338/</url>
    <content><![CDATA[<h1 id="神经网络概览及表示"><a href="#神经网络概览及表示" class="headerlink" title="神经网络概览及表示"></a>神经网络概览及表示</h1><p>个人认为，这节只需要搞懂两个问题：</p>
<h2 id="单个神经元的作用"><a href="#单个神经元的作用" class="headerlink" title="单个神经元的作用"></a>单个神经元的作用</h2><pre class="mermaid">graph LR
x1-->B((N))
x2-->B((N))
x3-->B((N))
B-->y</pre>

<p>对于一个这样的神经元N，他要做的计算主要是上一章的$\hat{y}=w^{T} x+b$和$a=sigmoid(z)$，并输出损失函数L的值，如下图所示：</p>
<pre class="mermaid">graph LR

A["x"]-->B[z=wx+b]
w["w"]-->B
b["b"]-->B
B-->C["a=sigmoid(z)"]
C-->D["L"]</pre>





<h2 id="层与层的信号传递"><a href="#层与层的信号传递" class="headerlink" title="层与层的信号传递"></a>层与层的信号传递</h2><p><img src="https://s1.ax1x.com/2020/08/23/d0KBrQ.png" alt="d0KBrQ.png"></p>
<p>对于这样一个简单的<strong>双层网络</strong>（输入层不被视为标准层），层与层之间是如何进行信号传输的呢？</p>
<p>对于<strong>Layer 1</strong>，使用以下公式进行计算：</p>
<script type="math/tex; mode=display">
\left.\begin{array}{r}
x \\
W^{[1]} \\
b^{[1]}
\end{array}\right\}=\quad z^{[1]}=W^{[1]} x+b^{[1]}=a^{[1]}=\sigma\left(z^{[1]}\right)</script><p>这里对参数进行说明：</p>
<ul>
<li>$x$：输入样本</li>
<li>$W^{[1]}$：参数$w$矩阵</li>
<li>$b^{[1]}$：参数$b$矩阵 </li>
</ul>
<p>对于<strong>Layer 2</strong>，上一层的输出$a^{[1]}$为这一层的输入：</p>
<script type="math/tex; mode=display">
\left.\begin{array}{r}
a^{[1]}=\sigma\left(z^{[1]}\right) \\
W^{[2]} \\
b^{[2]}
\end{array}\right\} \Longrightarrow z^{[2]}=W^{[2]} a^{[1]}+b^{[2]}=a^{[2]}=\sigma\left(z^{[2]}\right)</script><p>参数说明同上，不再赘述。此时输出结果$a^{[2]}$即为整个神经网络的输出结果。这就完成了一次神经网络的<strong>正向传播</strong>。</p>
<p>这里对这个神经网络进行简单的说明：对于外界，隐藏层<strong>Layer 1</strong>与<strong>Layer 2</strong>不可见，之所谓“隐藏”。</p>
<hr>
<p>那<strong>反向传播</strong>呢？</p>
<p>类似于这样：</p>
<pre class="mermaid">graph RL
L[dL]-->a["da"]
a-->z["dz"]
z-->x[x]
z-->w[dW]
z-->b[db]</pre>

<p>使用如下公式计算：</p>
<script type="math/tex; mode=display">
\left.\begin{array}{r}
d a^{[1]}=d \sigma\left(z^{[1]}\right) \\
d W^{[2]} \\
d b^{[2]}
\end{array}\right\} \Longleftarrow d z^{[2]}=d\left(W^{[2]} \alpha^{[1]}+b^{[2]}\right) \Longleftrightarrow d a^{[2]}=d \sigma\left(z^{[2 \mid}\right)</script><h1 id="计算一个神经网络的输出"><a href="#计算一个神经网络的输出" class="headerlink" title="计算一个神经网络的输出"></a>计算一个神经网络的输出</h1><p>这一节主要了解神经网络的输出是如何计算的。</p>
<p>由上节可知，单个神经元的计算为：</p>
<p><img src="https://s1.ax1x.com/2020/08/23/d01NwQ.png" alt="d01NwQ.png"></p>
<p>在双层神经网络中为：</p>
<p><img src="https://s1.ax1x.com/2020/08/23/d01xpt.png" alt="d01xpt.png"></p>
<p>使用for循环计算很低效，因此采用向量法计算：</p>
<p><img src="https://s1.ax1x.com/2020/08/23/d03WDS.png" alt="d03WDS.png"></p>
<p><img src="https://s1.ax1x.com/2020/08/23/d08kDO.png" alt="d08kDO.png"></p>
<h1 id="多样本向量化"><a href="#多样本向量化" class="headerlink" title="多样本向量化"></a>多样本向量化</h1><p>上节讨论了单一样本的训练，这节针对多样本训练。</p>
<p>针对单一样本，使用以下四个函数可以计算出$\hat{y}$：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
z^{[1]}=W^{[1]} x+b^{[1]} \\
a^{[1]}=\sigma\left(z^{[1]}\right) \\
z^{[2]}=W^{[2]} a^{[1]}+b^{[2]} \\
a^{[2]}=\sigma\left(z^{[2]}\right)
\end{array}</script><p>将这四个函数应用于m个样本上，就需要重复以上四个函数m次：<br><img src="https://s1.ax1x.com/2020/08/23/d0LAOJ.png" alt="d0LAOJ.png" style="zoom:80%;" /></p>
<p>注：$a^{[2](i)},(i)$是指第$i$个训练样本而$[2]$是指第二层。</p>
<p>将以上公式向量化：</p>
<script type="math/tex; mode=display">
x=\left[\begin{array}{cccc}
\vdots & \vdots & \vdots & \vdots \\
x^{(1)} & x^{(2)} & \cdots & x^{(m)} \\
\vdots & \vdots & \vdots & \vdots
\end{array}\right]</script><script type="math/tex; mode=display">
Z^{[1]}=\left[\begin{array}{cccc}
\vdots & \vdots & \vdots & \vdots \\
z^{[1](1)} & z^{[1](2)} & \cdots & z^{[1](m)} \\
\vdots & \vdots & \vdots & \vdots
\end{array}\right]</script><script type="math/tex; mode=display">
A^{[1]}=\left[\begin{array}{cccc}
\vdots & \vdots & \vdots & \vdots \\
a^{[1](1)} & a^{[1](2)} & \cdots & a^{[1](m)} \\
\vdots & \vdots & \vdots & \vdots
\end{array}\right]</script><p>同理可求得$Z^{[2]}$，$A^{[2]}$：</p>
<script type="math/tex; mode=display">
\left. \begin{array} { c } z ^ { [ 1 ] ( i ) } = W ^ { [ 1 ] ( i ) } x ^ { ( i ) } + b ^ { [ 1 ] } \\ a ^ { [ 1 ] ( i ) } = \sigma \left( z ^ { [ 1 ] ( i ) } \right) \\ z ^ { [ 2 ] ( i ) } = W ^ { [ 2 ] ( i ) } a ^ { [ 1 ] ( i ) } + b ^ { [ 2 ] } \\ a ^ { [ 2 ] ( i ) } = \sigma \left( z ^ { [ 2 ] ( i ) } \right) \end{array} \right\} \Longrightarrow \left\{ \begin{array} { l } A ^ { [ 1 ] } = \sigma \left( z ^ { [ 1 ] } \right) \\ z ^ { [ 2 ] } = W ^ { [ 2 ] } A ^ { [ 1 ] } + b ^ { [ 2 ] } \\ A ^ { [ 2 ] } = \sigma \left( z ^ { [ 2 ] } \right) \end{array} \right.</script><p>水平索引（纵列）针对训练样本，垂直索引（横列）针对神经网络的节点（一行代表一个Layer）</p>
<script type="math/tex; mode=display">
W ^ { [ 1 ] } x = \left[ \begin{array} { c c c c } \cdots & \vdots & \vdots & \vdots & \vdots \\ \cdots & x ^ { ( 1 ) } & x ^ { ( 2 ) } & x ^ { ( 3 ) } & \vdots \\ \vdots & \vdots & \vdots & \vdots \end{array} \right] = \left[ \begin{array} { c c c c } \vdots & \vdots & \vdots & \vdots \\ w ^ { ( 1 ) } x ^ { ( 1 ) } & w ^ { ( 1 ) } x ^ { ( 2 ) } & w ^ { ( 1 ) } x ^ { ( 3 ) } & \vdots \\ \vdots & \vdots & \vdots & \vdots \end{array} \right]</script><h1 id="向量化的解释"><a href="#向量化的解释" class="headerlink" title="向量化的解释"></a>向量化的解释</h1><p>先手动对几个样本进行向前传播：</p>
<script type="math/tex; mode=display">
\begin{aligned}
z^{[1](1)} &=W^{[1]} x^{(1)}+b^{[1]} \\
z^{[1](2)} &=W^{[1]} x^{(2)}+b^{[1]} \\
z^{[1](3)} &=W^{[1]} x^{(3)}+b^{[1]}
\end{aligned}</script><p>为了简便理解，先$b^{[1]}$舍去，之后可利用python的<strong>广播机制</strong>再加回来。现在$W^{[1]}$是一个矩阵，$x^{(1)}, x^{(2)}, x^{(3)}$都是列向量，矩阵乘以列向量得到列向量，表示如下：</p>
<script type="math/tex; mode=display">
W ^ { [ 1 ] } x = \left[ \begin{array} { c c c c } \cdots & \vdots & \vdots & \vdots & \vdots \\ \cdots & x ^ { ( 1 ) } & x ^ { ( 2 ) } & x ^ { ( 3 ) } & \vdots \\ \vdots & \vdots & \vdots & \vdots \end{array} \right] = \left[ \begin{array} { c c c c } \vdots & \vdots & \vdots & \vdots \\ w ^ { ( 1 ) } x ^ { ( 1 ) } & w ^ { ( 1 ) } x ^ { ( 2 ) } & w ^ { ( 1 ) } x ^ { ( 3 ) } & \vdots \\ \vdots & \vdots & \vdots & \vdots \end{array} \right] = \left[ \begin{array} { c c c c } \vdots & \vdots & \vdots & \vdots \\ z ^ { [ 1 ] ( 1 ) } & z^{[1](2)} & z ^ { [ 1 ] ( 3 ) } & \vdots \\ \vdots & \vdots & \vdots & \vdots \end{array} \right]=Z^{[1]}</script><p>吴恩达老师很细心的用不同的颜色表示不同的样本向量，及其对应的输出。所以从上式中可以看出，当加入更多样本时，只需向矩阵$X$中加入更多列。</p>
<h1 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h1><p>单个神经元中，实现非线性映射的函数。</p>
<h2 id="激活函数分类"><a href="#激活函数分类" class="headerlink" title="激活函数分类"></a>激活函数分类</h2><h3 id="sigmoid函数"><a href="#sigmoid函数" class="headerlink" title="sigmoid函数"></a>sigmoid函数</h3><script type="math/tex; mode=display">
a=\sigma(z)=\frac{1}{1+e^{-z}}</script><p><img src="https://s1.ax1x.com/2020/08/25/d6RGMd.png" alt="d6RGMd.png" style="zoom:67%;" /></p>
<p>只适用于逻辑回归模型，不常用。</p>
<h3 id="tanh函数"><a href="#tanh函数" class="headerlink" title="tanh函数"></a>tanh函数</h3><script type="math/tex; mode=display">
a=\tanh (z)=\frac{e^{z}-e^{-z}}{e^{z}+e^{-z}}</script><p><img src="https://s1.ax1x.com/2020/08/25/d65fxS.png" alt="d65fxS.png" style="zoom:67%;" /></p>
<p>比sigmoid函数性能更好，更加适用于多场景，更常用。</p>
<p><strong>sigmoid</strong>函数和<strong>tanh</strong>函数两者共同的缺点是，在$z$的绝对值特别大时，导数的梯度或者函数的斜率会变得特别小，最后就会接近于0，导致梯度下降的速度降低。</p>
<h3 id="ReLU"><a href="#ReLU" class="headerlink" title="ReLU"></a>ReLU</h3><script type="math/tex; mode=display">
a=\max (0, z)</script><p><img src="https://s1.ax1x.com/2020/08/25/d6T1KS.png" alt="d6T1KS.png" style="zoom:67%;" /></p>
<p>激活函数的默认选择，可以解决<strong>sigmoid</strong>函数和<strong>tanh</strong>函数两者共同的缺点。</p>
<h3 id="Leaky-ReLu"><a href="#Leaky-ReLu" class="headerlink" title="Leaky ReLu"></a>Leaky ReLu</h3><script type="math/tex; mode=display">
a=\max (0.01z, z)</script><p><img src="https://s1.ax1x.com/2020/08/25/d6bfx0.png" alt="d6bfx0.png" style="zoom:67%;" /></p>
<p>这个函数通常比<strong>Relu</strong>激活函数效果要好。0.01是学习函数的一个参数，也可以设置为别的。</p>
<p><strong>ReLU</strong>与<strong>Leaky ReLu</strong>共同的优点：</p>
<blockquote>
<p><em>摘自<a href="http://www.ai-start.com/dl2017/html/lesson1-week3.html#header-n152">深度学习笔记</a>，我也不是很理解这里。</em></p>
<ul>
<li>在$z$的区间变动很大的情况下，激活函数的导数或者激活函数的斜率都会远大于0，在程序实现就是一个<strong>if-else</strong>语句，而<strong>sigmoid</strong>函数需要进行浮点四则运算，在实践中，使用<strong>ReLu</strong>激活函数神经网络通常会比使用<strong>sigmoid</strong>或者<strong>tanh</strong>激活函数学习的更快。</li>
<li><strong>sigmoid</strong>和<strong>tanh</strong>函数的导数在正负饱和区的梯度都会接近于0，这会造成梯度弥散，而<strong>Relu</strong>和<strong>Leaky ReLu</strong>函数大于0部分都为常数，不会产生梯度弥散现象。(同时应该注意到的是，<strong>Relu</strong>进入负半区的时候，梯度为0，神经元此时不会训练，产生所谓的稀疏性，而<strong>Leaky ReLu</strong>不会有这问题)</li>
</ul>
</blockquote>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ol>
<li><strong>sigmoid</strong>激活函数：仅适用于二分类</li>
<li><strong>tanh</strong>激活函数：<strong>tanh</strong>是非常优秀的，几乎适合所有场合。</li>
<li><strong>ReLu</strong>激活函数：最常用的默认函数，如果不确定用哪个激活函数，就使用<strong>ReLu</strong>或者<strong>Leaky ReLu</strong>。</li>
</ol>
<h2 id="为什么需要非线性激活函数"><a href="#为什么需要非线性激活函数" class="headerlink" title="为什么需要非线性激活函数"></a>为什么需要非线性激活函数</h2><p>线性激活函数会使预测值与输入呈现线性关系，而失去了多层神经网络迭代参数的意义。</p>
<p>只有机器学习中的回归问题可以用到线性函数。</p>
<h1 id="激活函数的导数"><a href="#激活函数的导数" class="headerlink" title="激活函数的导数"></a>激活函数的导数</h1><ol>
<li><p>sigmoid</p>
<script type="math/tex; mode=display">
g(z)=\frac{1}{1+e^{-z}}</script><script type="math/tex; mode=display">
g'(z)=\frac{1}{1+e^{z}}\left(1-\frac{1}{1+e^{-z}}\right)=g(z)(1-g(z))</script></li>
<li><p>tanh</p>
<script type="math/tex; mode=display">
g(z)=\tanh (z)=\frac{e^{z}-e^{-z}}{e^{z}-e^{-z}}</script><script type="math/tex; mode=display">
g'(z)=1-(\tanh (z))^{2}</script></li>
<li><p>ReLU</p>
<script type="math/tex; mode=display">
g(z)=\max (0, z)</script><script type="math/tex; mode=display">
g'(z)=\left\{\begin{array}{ll}
0 & \text { if } z<0 \\
1 & \text { if } z>0 \\
u n d e f i n e d & \text { if } z=0
\end{array}\right.</script></li>
<li><p>Leaky ReLU</p>
<script type="math/tex; mode=display">
g(z)=\max (0.01z, z)</script><script type="math/tex; mode=display">
g'(z)=\left\{\begin{array}{ll}
0.01 & \text { if } z<0 \\
1 & \text { if } z>0 \\
u n d e f i n e d & \text { if } z=0
\end{array}\right.</script></li>
</ol>
<h1 id="神经网络的梯度下降"><a href="#神经网络的梯度下降" class="headerlink" title="神经网络的梯度下降"></a>神经网络的梯度下降</h1><p><img src="https://s1.ax1x.com/2020/08/26/dWErTS.png" alt="dWErTS.png" style="zoom:67%;" /></p>
<h1 id="随机初始化"><a href="#随机初始化" class="headerlink" title="随机初始化"></a>随机初始化</h1><p>不能把参数或权重都设置为0，否则反向传播会失效，因为每层的神经元计算的函数将会一模一样。</p>
<p>可以把$b$初始化为0，因为只要随机初始化$W$就会有不同的隐藏单元计算不同的函数。</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
  </entry>
  <entry>
    <title>2.神经网络基础</title>
    <url>/202008174340/</url>
    <content><![CDATA[<h1 id="二分类问题（Binary-Classification）"><a href="#二分类问题（Binary-Classification）" class="headerlink" title="二分类问题（Binary Classification）"></a>二分类问题（Binary Classification）</h1><p>逻辑回归要解决的问题，什么是二分类问题？即目标问题的答案空间非此即彼，是离散的，这有点像我们平常做的判断题，非对即错。就像吴恩达老师提出的问题：训练一个分类器，对图片进行判断，是猫就输出1，否则输出0</p>
<h1 id="逻辑回归（Logistic-Regression）"><a href="#逻辑回归（Logistic-Regression）" class="headerlink" title="逻辑回归（Logistic Regression）"></a>逻辑回归（Logistic Regression）</h1><p>给定$x$，求$\hat{y}=P(y=1|x)$（已知$x$，$y=1$的概率$P$，对实际值$y$的预测）</p>
<script type="math/tex; mode=display">
\hat{y}=w^{T} x+b</script><p>这是一个很好的<strong>线性回归模型</strong>，但是为了使$\hat{y}$落在[0,1]中，引入了sigmoid函数：</p>
<script type="math/tex; mode=display">
\sigma (z)=\frac{1}{1+e^{-z}}</script><p>此时逻辑回归模型为：</p>
<script type="math/tex; mode=display">
\hat{y}=\sigma (\omega^{T} x+b)=\frac{1}{1+e^-({\omega^{T} x+b})}</script><blockquote>
<p><a href="https://baike.baidu.com/item/Sigmoid%E5%87%BD%E6%95%B0/7981407?fr=aladdin">sigmoid函数</a></p>
</blockquote>
<p>sigmoid函数有很多优点：</p>
<ul>
<li>值域为(0,1)</li>
<li>平滑、易于求导</li>
</ul>
<h1 id="逻辑回归的代价函数（Logistic-Regression-Cost-Function）"><a href="#逻辑回归的代价函数（Logistic-Regression-Cost-Function）" class="headerlink" title="逻辑回归的代价函数（Logistic Regression Cost Function）"></a>逻辑回归的代价函数（Logistic Regression Cost Function）</h1><p>为了训练模型习得参数$\omega$和$b$</p>
<p>给定m个训练样本$\left \{ (x^{(1)},y^{(1)}),…,(x^{(m)},y^{(m)}) \right \}$，使得$\hat{y} \approx y$，从而在训练集中找到参数$w$和$b$</p>
<h2 id="损失函数（Loss-function）"><a href="#损失函数（Loss-function）" class="headerlink" title="损失函数（Loss function）"></a>损失函数（Loss function）</h2><p>为了衡量算法的精确度，$L(\hat{y},y)$</p>
<p>怎么衡量？</p>
<p>预测值与实际值的距离（差值）越小，说明算法越精确。一般用$\hat{y}与y$的平方差或平方差的一半表示，但在逻辑回归中不这么做。为啥不这么做呢，是因为如果用平方差或平方差的一半表示距离，则梯度下降法一般不能找到全局最优解，所以在逻辑回归中提出另一个损失函数：</p>
<script type="math/tex; mode=display">
L(\hat{y},y)=-ylog(\hat{y})-(1-y)log(1-\hat{y})</script><p>为啥使用这个函数呢？</p>
<p>因为$y=1$时，$L(\hat{y},y)=-log(\hat{y})$，为了使$L$尽可能小，则$\hat{y}$会无限大，又因为$\hat{y}\in [0,1]$，所以$\hat{y}\rightarrow 1$</p>
<p>同理$y=0$时，$L(\hat{y},y)=-log(1-\hat{y})$，为了使$L$尽可能小，则$\hat{y}$会无限小，又因为$\hat{y}\in [0,1]$，所以$\hat{y}\rightarrow 0$</p>
<h2 id="代价函数（Cost-Function）"><a href="#代价函数（Cost-Function）" class="headerlink" title="代价函数（Cost Function）"></a>代价函数（Cost Function）</h2><p>损失函数针对单一训练样本，代价函数（成本函数）针对所有样本</p>
<script type="math/tex; mode=display">
J(w, b)=\frac{1}{m} \sum_{i=1}^{m} L\left(\hat{y}^{(i)}, y^{(i)}\right)=\frac{1}{m} \sum_{i=1}^{m}\left(-y^{(i)} \log \hat{y}^{(i)}-\left(1-y^{(i)}\right) \log \left(1-\hat{y}^{(i)}\right)\right)</script><p>在训练逻辑回归模型时候，我们需要找到合适的$\omega$和$b$，来让代价函数$J$的总代价降到最低。</p>
<h1 id="梯度下降（Gradient-Descent）"><a href="#梯度下降（Gradient-Descent）" class="headerlink" title="梯度下降（Gradient Descent）"></a>梯度下降（Gradient Descent）</h1><blockquote>
<p><a href="https://www.cnblogs.com/pinard/p/5970503.html">梯度下降（Gradient Descent）小结</a><br><a href="https://zhuanlan.zhihu.com/p/24913912">梯度下降算法详解</a></p>
</blockquote>
<p>通过梯度下降可以找到三维曲面上任一点到最小值的路径，梯度下降适用于凸函数，如果函数非凸，则会找到通向局部最优解的多条路径。</p>
<p>在二元函数中，梯度没有方向一说，此时梯度等价于导数。</p>
<p>有了代价函数$J(w, b)$，利用梯度下降就能在训练集中学习训练参数$w$和$b$：</p>
<script type="math/tex; mode=display">
w:=w-\alpha \frac{\partial J(w, b)}{\partial w}</script><script type="math/tex; mode=display">
b:=b-\alpha \frac{\partial J(w, b)}{\partial b}</script><p>在这里$\alpha$表示学习率，其实就是用来控制梯度下降时的步长。$\alpha$是一个超参数，通过人工标定，而不是计算得出，$\alpha$既不能太大也不能太小，太大可能会超过最优解；太小下降得会很慢、效率低，所以找到合适的学习率很关键。</p>
<h1 id="逻辑回归中的梯度下降（Logistic-Regression-Gradient-Descent）"><a href="#逻辑回归中的梯度下降（Logistic-Regression-Gradient-Descent）" class="headerlink" title="逻辑回归中的梯度下降（Logistic Regression Gradient Descent）"></a>逻辑回归中的梯度下降（Logistic Regression Gradient Descent）</h1><blockquote>
<p>链式法则</p>
</blockquote>
<p>假设样本只有两个特征$x_{1}$和$x_{2}$，为了计算$z$，我们需要输入参数$w_{1}$、$w_{1}$和$b$，除此之外还有特征值和。因此的计算公式为：</p>
<script type="math/tex; mode=display">
z=w_{1} x_{1}+w_{2} x_{2}+b</script><p>只考虑<strong>单个样本</strong>的情况，单个样本的代价函数定义如下：</p>
<script type="math/tex; mode=display">
L(a, y)=-(y \log (a)+(1-y) \log (1-a))</script><p><img src="https://s1.ax1x.com/2020/08/19/dQKch6.png" alt="dQKch6.png" style="zoom:50%;" /></p>
<p>完成导数计算后，使用变量$dw_{1}$、$dw_{1}$和$db$就可以完成对单个样本参数$w_{1}$、$w_{1}$和$b$的更新：</p>
<script type="math/tex; mode=display">
w_{1}:=w_{1}-\alpha dw_{1}</script><script type="math/tex; mode=display">
w_{2}:=w_{2}-\alpha dw_{2}</script><script type="math/tex; mode=display">
b:=b-\alpha db</script><h1 id="m-个样本的梯度下降-Gradient-Descent-on-m-Examples"><a href="#m-个样本的梯度下降-Gradient-Descent-on-m-Examples" class="headerlink" title="m 个样本的梯度下降(Gradient Descent on m Examples)"></a>m 个样本的梯度下降(Gradient Descent on m Examples)</h1><p>利用上节推导的公式应用于m个样本，重新回忆代价函数：</p>
<script type="math/tex; mode=display">
J(w, b)=\frac{1}{m} \sum_{i=1}^{m} L\left(\hat{y}^{(i)}, y^{(i)}\right)=\frac{1}{m} \sum_{i=1}^{m}\left(-y^{(i)} \log \hat{y}^{(i)}-\left(1-y^{(i)}\right) \log \left(1-\hat{y}^{(i)}\right)\right)</script><p>伪代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">J &#x3D; 0; dw1 &#x3D; 0; dw2 &#x3D; 0; b &#x3D; 0;</span><br><span class="line">for i &#x3D; 1 to m:</span><br><span class="line">	z(i) &#x3D; wx(i) + b;</span><br><span class="line">	a(i) &#x3D; sigmoid(z(i));</span><br><span class="line">	J +&#x3D; -[y(i) * log(a(i)) + (1 - y(i)) * log(1 - a(i));</span><br><span class="line">	dz(i) &#x3D; a(i) - y(i);</span><br><span class="line">	dw1 +&#x3D; x1(i) * dz(i);</span><br><span class="line">    dw2 +&#x3D; x2(i) * dz(i);</span><br><span class="line">    db +&#x3D; dz(i);</span><br><span class="line">J &#x2F;&#x3D; m; dw1 &#x2F;&#x3D; m; dw2 &#x2F;&#x3D; m; db &#x2F;&#x3D; m;</span><br><span class="line">w &#x3D; w - alpha * dw;</span><br><span class="line">b &#x3D; b - alpha * db;</span><br></pre></td></tr></table></figure>
<p>for循环在深度学习领域中不建议使用，因为数据集很大，循环遍历效率很低，下一节提出了向量化的概念，可以提高程序的运行效率。</p>
<h1 id="向量化（Vectorization）"><a href="#向量化（Vectorization）" class="headerlink" title="向量化（Vectorization）"></a>向量化（Vectorization）</h1><p>大规模的深度学习使用了<strong>GPU</strong>或者图像处理单元实现，<strong>GPU</strong>更加擅长<a href="https://baike.baidu.com/item/SIMD/3412835?fr=aladdin">SIMD</a>计算</p>
<p>避免使用for循环，尽量使用Numpy内建函数，提高程序运行效率</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">a = np.random.rand(<span class="number">1000000</span>)</span><br><span class="line">b = np.random.rand(<span class="number">1000000</span>)</span><br><span class="line"></span><br><span class="line">tic = time()</span><br><span class="line">c = np.dot(a,b)</span><br><span class="line">toc = time()</span><br><span class="line"></span><br><span class="line">print(c)</span><br><span class="line">print(<span class="string">&quot;Vectorization : &quot;</span> + <span class="built_in">str</span>(<span class="number">1000</span>*(toc - tic)) + <span class="string">&quot;ms&quot;</span>)</span><br><span class="line"></span><br><span class="line">tic = time()</span><br><span class="line">c = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">    c += a[i]*b[i]</span><br><span class="line">toc = time()</span><br><span class="line"></span><br><span class="line">print(c)</span><br><span class="line">print(<span class="string">&quot;For Loop : &quot;</span> + <span class="built_in">str</span>(<span class="number">1000</span>*(toc - tic)) + <span class="string">&quot;ms&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">250070.50127872356</span><br><span class="line">Vectorization : 5.739450454711914ms</span><br><span class="line">250070.50127871914</span><br><span class="line">For Loop : 735.069751739502ms</span><br></pre></td></tr></table></figure>
<p><strong>向量化的效率是for循环的150倍！</strong></p>
<p>使用向量化可以将上一节的伪代码进行优化：</p>
<p><img src="https://s1.ax1x.com/2020/08/19/dlcqsO.png" alt="dlcqsO.png" style="zoom: 50%;" /></p>
<h1 id="向量化逻辑回归-Vectorizing-Logistic-Regression"><a href="#向量化逻辑回归-Vectorizing-Logistic-Regression" class="headerlink" title="向量化逻辑回归(Vectorizing Logistic Regression)"></a>向量化逻辑回归(Vectorizing Logistic Regression)</h1><p>大写字母表示向量，小写字母表示元素。</p>
<script type="math/tex; mode=display">
X=\begin{bmatrix}
\vdots & \vdots & \vdots & \vdots & \vdots\\ 
 x^{1}& x^{2} & x^{3} & \cdots  & x^{5}\\ 
 \vdots & \vdots & \vdots & \vdots & \vdots
\end{bmatrix},(n_{x},m)</script><script type="math/tex; mode=display">
Z=w^{T}X+b</script><script type="math/tex; mode=display">
A=sigmoid(Z)</script><p>转换为python代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Z = np.dot(w.T, X) + b //python广播，可以将一个实数自动转换为一维矩阵，累加到之前的矩阵中</span><br><span class="line">A = sigmoid(Z)</span><br></pre></td></tr></table></figure>
<p>这是逻辑回归向前传播的过程。</p>
<h1 id="向量化logistic回归的梯度输出（Vectorizing-Logistic-Regression’s-Gradient）"><a href="#向量化logistic回归的梯度输出（Vectorizing-Logistic-Regression’s-Gradient）" class="headerlink" title="向量化logistic回归的梯度输出（Vectorizing Logistic Regression’s Gradient）"></a>向量化logistic回归的梯度输出（Vectorizing Logistic Regression’s Gradient）</h1><script type="math/tex; mode=display">
\because dZ=\left[d z^{(1)}, d z^{(2)} \ldots d z^{(m)}\right]$，$A=\left[a^{(1)}, a^{(2)} \ldots a^{(m)}\right]$，$Y=\left[y^{(1)} y^{(2)} \ldots y^{(m)}\right]</script><script type="math/tex; mode=display">
\therefore dZ=A-Y=\left[a^{(1)}-y^{(1)} a^{(2)}-y^{(2)} \ldots a^{(m)}-y^{(m)}\right]</script><hr>
<script type="math/tex; mode=display">
\begin{array}{l}
d w=0 \\
d w += x^{(1)} * d z^{(1)} \\
d w += x^{(2)} * d z^{(2)} \\
\cdots \cdots \cdots \cdots \\
d w += x^{(m)} * d z^{(m)} \\
d w /= m
\end{array}</script><hr>
<script type="math/tex; mode=display">
\begin{array}{l}
d b=0 \\
d b += d z^{(1)} \\
d b += d z^{(2)} \\
\ldots \ldots \ldots \ldots \\
d b += d z^{(m)} \\
d b /= m
\end{array}</script><hr>
<script type="math/tex; mode=display">
\therefore d b=\frac{1}{m} \sum_{i=1}^{m} d z^{(i)}=\frac{1}{m} * n p . \operatorname{sum}(d Z)</script><script type="math/tex; mode=display">
dw=\frac{1}{m} * X * d z^{T}=\frac{1}{m} *\left(x^{(1)} d z^{(1)}+x^{(2)} d z^{(2)}+\ldots+x^{m} d z^{m}\right)=\frac{1}{m} * n p . \operatorname{sum}(dZ)</script><hr>
<p>综上所述，优化后的逻辑回归为：</p>
<script type="math/tex; mode=display">
\begin{array}{l}
Z=w^{T} X+b=n p . d o t(w . T, X)+b \\
A=\sigma(Z) \\
d Z=A-Y \\
d w=\frac{1}{m} * X * d z^{T} \\
d b=\frac{1}{m} * n p . s u m(d Z) \\
w:=w-a * d w \\
b:=b-a * d b
\end{array}</script><h1 id="（选修）logistic-损失函数的解释（Explanation-of-logistic-regression-cost-function）"><a href="#（选修）logistic-损失函数的解释（Explanation-of-logistic-regression-cost-function）" class="headerlink" title="（选修）logistic 损失函数的解释（Explanation of logistic regression cost function）"></a>（选修）logistic 损失函数的解释（Explanation of logistic regression cost function）</h1><p>查看第二节<a href="#逻辑回归（Logistic Regression）">逻辑回归（Logistic Regression）</a>重新回忆一下逻辑回归研究的问题：给定$x$，求$\hat{y}=P(y|x)$，分析以下两个条件概率：</p>
<script type="math/tex; mode=display">
\begin{array}{lll}
\text { If } & y=1: & p(y \mid x)=\hat{y} \\
\text { If } & y=0: & p(y \mid x)=1-\hat{y}
\end{array}</script><p>上述的两个条件概率公式可以合并成如下公式：</p>
<script type="math/tex; mode=display">
p(y \mid x)=\hat{y}^{y}(1-\hat{y})^{(1-y)}</script><p>对上式求对数：</p>
<script type="math/tex; mode=display">
\log p(y \mid x)=ylog\hat{y }+(1-y) \log (1-\hat{y})</script><p>为什么要求对数呢？答：降低复杂度，方便计算。</p>
<p>而上式就是损失函数的负数：$-L(\hat{y}, y)$。为什么有个负号呢？原因是当你训练学习算法时需要算法输出值的概率是最大的（以最大的概率预测这个值），然而在逻辑回归中我们需要最小化损失函数，因此最小化损失函数与最大化条件概率的对数$\log (p(y \mid x))$关联起来了，因此这就是单个训练样本的损失函数表达式。</p>
<hr>
<p>对于整个训练集中标签的概率，假设所有的训练样本服从同一分布且相互独立，也即独立同分布的，所有这些样本的联合概率就是每个样本概率的乘积:</p>
<script type="math/tex; mode=display">
P(\text { labels in training set })=\prod_{i=1}^{m} P\left(y^{(i)} \mid x^{(i)}\right)_{\circ}</script><p>如果你想做最大似然估计，需要寻找一组参数，使得给定样本的观测值概率最大，但令这个概率最大化等价于令其对数最大化，在等式两边取对数：</p>
<script type="math/tex; mode=display">
\log p \text { (labels in training set) }=\log \prod_{i=1}^{m} P\left(y^{(i)} \mid x^{(i)}\right)=\sum_{i=1}^{m} \log P\left(y^{(i)} \mid x^{(i)}\right)=\sum_{i=1}^{m}-L\left(\hat{y}^{(i)}, y^{(i)}\right)</script><script type="math/tex; mode=display">
=-\sum_{i=1}^{m} L\left(\hat{y}^{(i)}, y^{(i)}\right)  (1)</script><blockquote>
<p>最大似然估计：已知结果，反推参数</p>
</blockquote>
<p>上式就是逻辑回归的代价函数：</p>
<script type="math/tex; mode=display">
J(w, b)=\sum_{i=1}^{m} L\left(\hat{y}^{(i)}, y^{(i)}\right)</script><p>对上式进行适当缩放，加入常数因子：</p>
<script type="math/tex; mode=display">
J(w, b)=\frac{1}{m} \sum_{i=1}^{m} L\left(\hat{y}^{(i)}, y^{(i)}\right)  (2)</script><ol>
<li>(1)式中，由于训练模型时，目标是让成本函数最小化，所以不直接使用最大似然概率，<strong>要去掉负号</strong></li>
<li>(2)式中，为了方便，可以对代价函数进行适当缩放，在前面加一个额外常数因子$\frac{1}{m}$</li>
</ol>
<h1 id="错题总结"><a href="#错题总结" class="headerlink" title="错题总结"></a>错题总结</h1><h2 id="第-15-题"><a href="#第-15-题" class="headerlink" title="第 15 题"></a>第 15 题</h2><p>考虑以下两个随机数组<code>a</code>和<code>b</code>：(D)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; np.random.randn(4, 3) # a.shape &#x3D; (4, 3)</span><br><span class="line">b &#x3D; np.random.randn(3, 2) # b.shape &#x3D; (3, 2)</span><br><span class="line">c &#x3D; a * b</span><br></pre></td></tr></table></figure>
<p><code>c</code>的维度是什么？</p>
<p>A.c.shape = (4, 3)</p>
<p>B.c.shape = (3, 3)</p>
<p><del>C.c.shape = (4, 2)</del></p>
<p><strong>D.计算不成立因为这两个矩阵维度不匹配</strong></p>
<h2 id="第-18-题"><a href="#第-18-题" class="headerlink" title="第 18 题"></a>第 18 题</h2><p>请考虑以下代码段：(B)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># a.shape &#x3D; (3,4)</span><br><span class="line"># b.shape &#x3D; (4,1)</span><br><span class="line">for i in range(3):</span><br><span class="line">  for j in range(4):</span><br><span class="line">    c[i][j] &#x3D; a[i][j] + b[j]</span><br></pre></td></tr></table></figure>
<p>如何将之矢量化？</p>
<p>A.c = a + d</p>
<p><strong>B.c = a +b.T</strong></p>
<p>C.c = a.T + b.T</p>
<p><del>D.c = a.T + b</del></p>
<h2 id="第-19-题"><a href="#第-19-题" class="headerlink" title="第 19 题"></a>第 19 题</h2><p>请考虑以下代码段：(A)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; np.random.randn(3, 3)</span><br><span class="line">b &#x3D; np.random.randn(3, 1)</span><br><span class="line">c &#x3D; a * b</span><br></pre></td></tr></table></figure>
<p><code>c</code>的维度是什么？</p>
<p><strong>A.这会触发广播机制，<code>b</code>会被复制3次变成(3<em>3)，而\</em>操作是元素乘法，所以<code>c.shape = (3, 3)</code></strong></p>
<p>B.这会触发广播机制，<code>b</code>会被复制3次变成(3<em>3)，而<strong>\</strong></em>操作是矩阵乘法，所以<code>c.shape = (3, 3)</code></p>
<p><del>C.这个操作将一个3x3矩阵乘以一个3x1的向量，所以<code>c.shape = (3, 1)</code></del></p>
<p>D.这个操作会报错，因为你不能用<code>*</code>对这两个矩阵进行操作，你应该用<code>np.dot(a, b)</code></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
  </entry>
  <entry>
    <title>1.深度学习概论</title>
    <url>/2020081633184/</url>
    <content><![CDATA[<p>今天学习了吴恩达深度学习课程的P1~P6的入门课程，总结如下问题</p>
<ul>
<li>什么是神经网络？</li>
<li>什么是深度学习？</li>
<li>什么是监督学习、无监督学习？</li>
</ul>
<h1 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h1><p>就我个人理解，神经网络并没有听起来这么高大上，它只是由原来的单一映射关系升级为了层级映射关系，只有输入层与输出层对外界可见，而中间的隐藏层不可见，在多个层级之间，前一层的输出可作为下一层的输入，利用大量的数据对这种多级映射关系进行训练，以获得一个非常精准的映射函数，中间的多级运算单元可看作“神经元”，由这些神经元组成的复杂网络可看作“神经网络”。</p>
<h1 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h1><p>我认为的深度学习，是摆脱掉传统的专家系统所带来的枷锁（机器学习），利用提前构建好的<strong>神经网络</strong>对大量的数据集进行训练，从而得到一个精准的可以对海量数据进行很好的拟合的一个模型，利用这个模型可以解决目标领域中的一些简单问题。</p>
<h1 id="监督学习、无监督学习"><a href="#监督学习、无监督学习" class="headerlink" title="监督学习、无监督学习"></a>监督学习、无监督学习</h1><ul>
<li>监督学习：使用经过人为标注的数据集对模型进行训练</li>
<li>无监督学习：使用未经过人为标注的数据集对模型进行训练</li>
</ul>
<blockquote>
<p>半监督学习：监督学习与无监督学习相结合，也叫强化学习。</p>
</blockquote>
<h1 id="错题总结"><a href="#错题总结" class="headerlink" title="错题总结"></a>错题总结</h1><h2 id="第-3-题"><a href="#第-3-题" class="headerlink" title="第 3 题"></a>第 3 题</h2><p>回想一下这个机器学习迭代的图。以下哪项陈述是正确的？（选出所有正确项）（AC<strong>D</strong>）</p>
<p><img src="https://cdn.kesci.com/upload/image/q46zljt0cq.jpg?imageView2/0/w/960/h/960" alt="Image Name"></p>
<p>A.能够快速地尝试各种想法可以让深入学习的工程师更快地迭代。</p>
<p>B.更快的计算有助于加快团队迭代一个好主意所需的时间。</p>
<p>C.在大数据集上训练比在小数据集上训练更快。</p>
<p><strong>D.深度学习算法的最新进展使我们能够更快地训练好的模型（即使不改变CPU/GPU硬件）。</strong></p>
<h2 id="第-4-题"><a href="#第-4-题" class="headerlink" title="第 4 题"></a>第 4 题</h2><p>当一个有经验的深度学习工程师处理一个新问题时，他们通常可以在第一次尝试时利用以前问题的洞察力来训练一个好的模型，而不需要在不同的模型中重复多次。</p>
<p>A.对 <strong>B.不对</strong></p>
<h2 id="第-8-题"><a href="#第-8-题" class="headerlink" title="第 8 题"></a>第 8 题</h2><p>为什么RNN（递归神经网络）被用于机器翻译，比如说将英语翻译成法语？（选出所有正确项）（<del>BC</del>AC）</p>
<p><strong>A.它可以训练成一个有监督的学习问题</strong></p>
<p><del>B.它比卷积神经网络（CNN）更强大</del></p>
<p>C.当输入/输出是一个序列（例如，一个单词序列）时适用</p>
<p>D.RNN表示 想法-&gt;代码-&gt;实验-&gt;想法-&gt;… 的循环过程</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
  </entry>
  <entry>
    <title>0.深度学习课程资源</title>
    <url>/2020081510778/</url>
    <content><![CDATA[<p>吴恩达深度学习课程资源：</p>
<ol>
<li>第一课 — 神经网络与深度学习<ol>
<li>视频课：<a href="https://www.bilibili.com/video/BV164411m79z">https://www.bilibili.com/video/BV164411m79z</a></li>
<li>笔记：<a href="http://www.ai-start.com/dl2017/">http://www.ai-start.com/dl2017/</a></li>
<li>课后题：<a href="https://www.kesci.com/home/project/5e20243e2823a10036b542da">https://www.kesci.com/home/project/5e20243e2823a10036b542da</a></li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
  </entry>
  <entry>
    <title>Java上溯造型与动态绑定</title>
    <url>/2020080231118/</url>
    <content><![CDATA[<h1 id="Java基础知识"><a href="#Java基础知识" class="headerlink" title="Java基础知识"></a>Java基础知识</h1><h2 id="八种基本数据类型"><a href="#八种基本数据类型" class="headerlink" title="八种基本数据类型"></a>八种基本数据类型</h2><div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>1位</td>
</tr>
<tr>
<td>char</td>
<td>1字节</td>
</tr>
<tr>
<td>byte</td>
<td>1字节</td>
</tr>
<tr>
<td>short</td>
<td>2字节</td>
</tr>
<tr>
<td>int</td>
<td>4字节</td>
</tr>
<tr>
<td>long</td>
<td>8字节</td>
</tr>
<tr>
<td>float</td>
<td>4字节</td>
</tr>
<tr>
<td>double</td>
<td>8字节</td>
</tr>
</tbody>
</table>
</div>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li>见名知义，少用或不用特殊字符，驼峰式命名</li>
<li>声明变量尽早初始化，并尽可能靠近变量第一次使用的位置</li>
</ul>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量的使用场景多为定义一些不可改变的数值，例如：月份、时间、换算单位等。</p>
<ul>
<li>常量：通常位于方法内部，使用<strong>final</strong>关键字修饰，常量名习惯用大写<br><code>final int PI = 3.14;</code></li>
<li>类常量：通常位于类内部，类内的所有方法均可以访问，使用<strong>static final</strong>修饰<br><code>static final int PI = 3.14;</code></li>
</ul>
<p>（final类似于C/C++中的const关键字；const是Java中的一个保留字，但未使用）</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="数学运算符"><a href="#数学运算符" class="headerlink" title="数学运算符"></a>数学运算符</h3><ul>
<li>=、+、-、、/、%、自增或自减、结合运算符（+=、-=、…）</li>
<li>数学函数：<strong>Math库</strong></li>
</ul>
<h3 id="逻辑运算符与布尔运算符"><a href="#逻辑运算符与布尔运算符" class="headerlink" title="逻辑运算符与布尔运算符"></a>逻辑运算符与布尔运算符</h3><ul>
<li><strong>&amp;&amp;</strong>、<strong>||</strong>、<strong>！</strong></li>
<li><strong>==</strong>、 <strong>!=</strong>、 <strong>&gt;</strong>、 <strong>&lt;</strong>、 <strong>&gt;=</strong>、 <strong>&lt;=</strong></li>
<li>三目运算符</li>
</ul>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p><strong>&amp;</strong>(与)、 <strong>|</strong>(或)、 <strong>^</strong>(异或)、 <strong>~</strong>(非)、<strong>&gt;&gt;</strong>(右移)、<strong>&lt;&lt;</strong>(左移)、&gt;&gt;&gt;(高位补零)</p>
<ul>
<li>&amp;    一假即假</li>
<li>|     一真即真</li>
<li><strong>^     相同则假，不同则真</strong></li>
<li>~     按位取反</li>
<li>>&gt;   按位右移<strong>（高位补符号位）</strong></li>
<li>&lt;&lt;   按位左移</li>
<li><strong>>&gt;&gt; 高位补零</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0b1000_0100</span>, y = <span class="number">0b1001_1010</span>;<span class="comment">//这里的下划线只是为了方便阅读，不会起任何作用</span></span><br><span class="line">System.out.println(<span class="string">&quot;x : &quot;</span> + Integer.toBinaryString(x));</span><br><span class="line">System.out.println(<span class="string">&quot;y : &quot;</span> + Integer.toBinaryString(y));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bitAND = x &amp; y;</span><br><span class="line"><span class="keyword">int</span> bitOR = x | y;</span><br><span class="line"><span class="keyword">int</span> bitExclusiveOR = x ^ y;</span><br><span class="line"><span class="keyword">int</span> leftShift = x &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> rightShift = x &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;bitAND : &quot;</span> + Integer.toBinaryString(bitAND));</span><br><span class="line">System.out.println(<span class="string">&quot;bitOR : &quot;</span> + Integer.toBinaryString(bitOR));</span><br><span class="line">System.out.println(<span class="string">&quot;bitExclusiveOR : &quot;</span> + Integer.toBinaryString(bitExclusiveOR));</span><br><span class="line">System.out.println(<span class="string">&quot;leftShift : &quot;</span> + Integer.toBinaryString(leftShift));</span><br><span class="line">System.out.println(<span class="string">&quot;rightShift : &quot;</span> + Integer.toBinaryString(rightShift));</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="增强型for循环"><a href="#增强型for循环" class="headerlink" title="增强型for循环"></a>增强型for循环</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] len = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : len) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><h3 id="do…while循环"><a href="#do…while循环" class="headerlink" title="do…while循环"></a>do…while循环</h3><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><h3 id="if…else"><a href="#if…else" class="headerlink" title="if…else"></a>if…else</h3><h3 id="if…else-if…else"><a href="#if…else-if…else" class="headerlink" title="if…else if…else"></a>if…else if…else</h3><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>118.杨辉三角</title>
    <url>/2020071434917/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个非负整数 <em>numRows，</em>生成杨辉三角的前 <em>numRows</em> 行。</p>
<p><img src="https://s1.ax1x.com/2020/07/14/UUA7VA.gif" alt="UUA7VA.gif"></p>
<p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote>
<p><a href="https://leetcode-cn.com/u/wengcanzi/">wengcanzi</a></p>
</blockquote>
<h3 id="C"><a href="#C" class="headerlink" title="C:"></a>C:</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an array of arrays of size *returnSize.</span></span><br><span class="line"><span class="comment"> * The sizes of the arrays are returned as *returnColumnSizes array.</span></span><br><span class="line"><span class="comment"> * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>** <span class="title">generate</span><span class="params">(<span class="keyword">int</span> numRows, <span class="keyword">int</span>* returnSize, <span class="keyword">int</span>** returnColumnSizes)</span></span>&#123;</span><br><span class="line">    *returnSize = numRows;</span><br><span class="line">    <span class="keyword">int</span>** res = (<span class="keyword">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*)*numRows);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; numRows; i++)&#123;</span><br><span class="line">        (*returnColumnSizes)[i] = i+<span class="number">1</span>;<span class="comment">//returnColumnSizes储存杨辉三角每一行元素的个数</span></span><br><span class="line">        res[i] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(i+<span class="number">1</span>));</span><br><span class="line">        res[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        res[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; i; j++)&#123;</span><br><span class="line">            res[i][j] = res[i<span class="number">-1</span>][j] + res[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><blockquote>
<p><a href="https://leetcode-cn.com/problems/pascals-triangle/solution/qu-qiao-jie-fa-cuo-yi-wei-zai-zhu-ge-xiang-jia-28m/">取巧解法：错一位再逐个相加</a></p>
</blockquote>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python:"></a>Python:</h3>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span>(<span class="params">self, numRows: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> numRows == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = [[<span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(res) &lt; numRows:</span><br><span class="line">            newRow = [a+b <span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>([<span class="number">0</span>]+res[-<span class="number">1</span>], res[-<span class="number">1</span>]+[<span class="number">0</span>])]</span><br><span class="line">            res.append(newRow)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>119.杨辉三角 II</title>
    <url>/202007149168/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个非负索引 <em>k</em>，其中 <em>k</em> ≤ 33，返回杨辉三角的第 <em>k</em> 行。</p>
<p><img src="https://s1.ax1x.com/2020/07/14/UUA7VA.gif" alt="UUA7VA.gif"></p>
<p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: [1,3,3,1]</span><br></pre></td></tr></table></figure>
<p><strong>进阶：</strong></p>
<p>你可以优化你的算法到 <em>O</em>(<em>k</em>) 空间复杂度吗？</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>跟118题思路一样</p>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python:"></a>Python:</h3>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRow</span>(<span class="params">self, rowIndex: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        res = [<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(res)-<span class="number">1</span> &lt; rowIndex:</span><br><span class="line">            res = [a+b <span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>([<span class="number">0</span>]+res, res+[<span class="number">0</span>])]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>121.买卖股票的最佳时机</title>
    <url>/2020071435904/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>DP(dynamic programming)，即动态规划</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="C"><a href="#C" class="headerlink" title="C:"></a>C:</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>* prices, <span class="keyword">int</span> pricesSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pricesSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>, maxp = <span class="number">0</span>; <span class="comment">//maxp为最大利润，temp为每天利润</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; pricesSize; i++) &#123;</span><br><span class="line">        min = min &gt; prices[i] ? prices[i] : min;</span><br><span class="line">        temp = prices[i] - min;</span><br><span class="line">        maxp = temp &gt; maxp ? temp : maxp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python:"></a>Python:</h3>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(prices):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        minp = prices[<span class="number">0</span>]</span><br><span class="line">        temp = <span class="number">0</span></span><br><span class="line">        maxp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            minp = price <span class="keyword">if</span> minp &gt; price <span class="keyword">else</span> minp</span><br><span class="line">            temp = price - minp</span><br><span class="line">            maxp = temp <span class="keyword">if</span> maxp &lt; temp <span class="keyword">else</span> maxp</span><br><span class="line">        <span class="keyword">return</span> maxp</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>dynamic-programming</tag>
      </tags>
  </entry>
  <entry>
    <title>88.合并两个有序数组</title>
    <url>/2020071218592/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个有序整数数组 <em>nums1</em> 和 <em>nums2</em>，将 <em>nums2</em> 合并到 <em>nums1</em> 中<em>，</em>使得 <em>num1</em> 成为一个有序数组。</p>
<p><strong>说明:</strong></p>
<ul>
<li>初始化 <em>nums1</em> 和 <em>nums2</em> 的元素数量分别为 <em>m</em> 和 <em>n</em>。</li>
<li>你可以假设 <em>nums1</em> 有足够的空间（空间大小大于或等于 <em>m + n</em>）来保存 <em>nums2</em> 中的元素。</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3</span><br><span class="line">nums2 &#x3D; [2,5,6],       n &#x3D; 3</span><br><span class="line"></span><br><span class="line">输出: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>双指针：</p>
<ol>
<li><p>i指向nums1的末尾，j指向nums2的末尾；</p>
</li>
<li><p>同时向前遍历，将较大的数放在nums1的末尾，然后i指针向前移动</p>
</li>
<li><p>检查nums2是否合并完毕，将剩余元素依次置入num1中</p>
</li>
</ol>
<h3 id="C"><a href="#C" class="headerlink" title="C:"></a>C:</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>* nums1, <span class="keyword">int</span> nums1Size, <span class="keyword">int</span> m, <span class="keyword">int</span>* nums2, <span class="keyword">int</span> nums2Size, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = m + n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = m - <span class="number">1</span>, j = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        nums1[k--] = nums1[i] &gt; nums2[j] ? nums1[i--] : nums2[j--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        nums1[k--] = nums2[j--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>又该整活了</p>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python:"></a>Python:</h3>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], m: <span class="built_in">int</span>, nums2: List[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m, <span class="built_in">len</span>(nums1)):</span><br><span class="line">            nums1[i] = nums2[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        nums1.sort()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>如何刷leetcode</title>
    <url>/2020071150360/</url>
    <content><![CDATA[<ol>
<li>Python的骚方法太多了，看一看图个乐，不要太在意。更不要看那些一行的代码，那不是给人看的！要注重的是算法本身，先把基本功打扎实了，解题方法可以按照标签来。</li>
<li>贪心、分治、动态规划</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>26.删除排序数组中的重复项</title>
    <url>/2020071128724/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个<strong>排序数组</strong>，你需要在<strong><a href="http://baike.baidu.com/item/原地算法">原地</a></strong>删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在<strong><a href="https://baike.baidu.com/item/原地算法">原地</a>修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定数组 nums &#x3D; [1,1,2], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums &#x3D; [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以<strong>“引用”</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len &#x3D; removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>快慢双指针</p>
<p>i为快指针；j为慢指针</p>
<p>慢指针用来存储值，快指针用来遍历整个数组。</p>
<p>当慢指针所指的值等于快指针所指向的值时，说明值发生了重复，则快指针向后移动；</p>
<p>当慢指针所指的值不等于快指针所指向的值时，值不重复，则用快指针所指向的值覆盖掉慢指针后边的值；</p>
<p>最终，慢指针表明不重复的数组长度</p>
<p>(此法精妙效率高，但仅针对已排序的数组)</p>
<h3 id="C"><a href="#C" class="headerlink" title="C:"></a>C:</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (numsSize &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> numsSize;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; numsSize; i++)</span><br><span class="line">        <span class="keyword">if</span> (nums[j] != nums[i])</span><br><span class="line">            nums[++j] = nums[i];</span><br><span class="line">    <span class="keyword">return</span> ++j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>对每个元素统计出现次数<strong>times</strong>，并将这个元素移除<strong>times-1</strong>次</p>
<p>（for循环嵌套，效率有点低啊）</p>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python:"></a>Python:</h3>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            times = nums.count(num)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(times - <span class="number">1</span>):</span><br><span class="line">                nums.remove(num)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>27.移除元素</title>
    <url>/2020071150510/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个数组 <em>nums</em> 和一个值 <em>val</em>，你需要<strong><a href="https://baike.baidu.com/item/原地算法">原地</a></strong>移除所有数值等于 <em>val</em> 的元素，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在<strong><a href="https://baike.baidu.com/item/原地算法">原地</a>修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums &#x3D; [3,2,2,3], val &#x3D; 3,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</span><br><span class="line"></span><br><span class="line">注意这五个元素可为任意顺序。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以<strong>“引用”</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span><br><span class="line">int len &#x3D; removeElement(nums, val);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>与26题非常相似</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>将所要移除的val用慢指针后面的元素替代即可</p>
<h3 id="C"><a href="#C" class="headerlink" title="C:"></a>C:</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; numsSize; i++)</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != val)</span><br><span class="line">            nums[j++] = nums[i];</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>统计val在nums中出现的次数<strong>times</strong>，并将其移除<strong>times</strong>次。</p>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python:"></a>Python:</h3>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        times = nums.count(val)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(times):</span><br><span class="line">            nums.remove(val)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>35.搜索插入位置</title>
    <url>/2020071130535/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<p><strong>示例 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>直接遍历，当不在数组范围内时，返回0或数组长度；在数组范围内时，返回索引值</p>
<h3 id="C"><a href="#C" class="headerlink" title="C:"></a>C:</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target &lt; nums[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (target &gt; nums[numsSize - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> numsSize;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">        <span class="keyword">if</span> (target == nums[i])</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[i] &amp;&amp; target &lt; nums[i + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>二分法</p>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python:"></a>Python:</h3>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            mid = (low + high) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">                high = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">return</span> low</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>binary-search</tag>
      </tags>
  </entry>
  <entry>
    <title>66.加一</title>
    <url>/2020071157516/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个由<strong>整数</strong>组成的<strong>非空</strong>数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储<strong>单个</strong>数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: [1,2,4]</span><br><span class="line">解释: 输入数组表示数字 123。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [4,3,2,1]</span><br><span class="line">输出: [4,3,2,2]</span><br><span class="line">解释: 输入数组表示数字 4321。</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>操作数组元素，模拟加法</p>
<ol>
<li>个位小于9时，直接加一，返回即可</li>
<li>个位等于9时，就该进位了，所以将其置为0</li>
<li>循环1、2步</li>
<li>当执行完毕后，程序仍未返回值，则是最特殊的情况，即各位都是9：</li>
<li>此时，需要重新申请空间，最高位为1，其余为0</li>
</ol>
<h3 id="C"><a href="#C" class="headerlink" title="C:"></a>C:</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">plusOne</span><span class="params">(<span class="keyword">int</span>* digits, <span class="keyword">int</span> digitsSize, <span class="keyword">int</span>* returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = digitsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (digits[i] &lt; <span class="number">9</span>) &#123;</span><br><span class="line">            digits[i]++;</span><br><span class="line">            *returnSize = digitsSize;</span><br><span class="line">            <span class="keyword">return</span> digits;</span><br><span class="line">        &#125;</span><br><span class="line">        digits[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>* aaa = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>((digitsSize + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    aaa[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; (digitsSize + <span class="number">1</span>); i++)</span><br><span class="line">        aaa[i] = <span class="number">0</span>;</span><br><span class="line">    *returnSize = digitsSize + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> aaa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>没其他tag了，有没有啥骚方法呢？</p>
<p>把数组变成整数，加个一，再变成数组，行不行呢？</p>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python:"></a>Python:</h3>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span>(<span class="params">self, digits: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        nums_str = <span class="built_in">str</span>(digits)[<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line">        nums_int = <span class="built_in">int</span>(nums_str.replace(<span class="string">&quot;, &quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">        nums_int += <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> nums_int &gt; <span class="number">0</span>:</span><br><span class="line">            num = nums_int % <span class="number">10</span></span><br><span class="line">            res.append(num)</span><br><span class="line">            nums_int = nums_int // <span class="number">10</span></span><br><span class="line">        res.reverse()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>1.数组、矩阵和广义表</title>
    <url>/2020070642666/</url>
    <content><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>在内存中的一块连续的存储空间，是最常用的数据结构</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>支持随机访问</li>
<li>查找元素效率高：O(1)</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li>增加、删除元素效率低：O(n)</li>
</ol>
<h2 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h2><ol>
<li><p>遍历</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>双指针</p>
</li>
<li><p>快慢指针</p>
</li>
</ol>
<h1 id="矩阵（二维数组）"><a href="#矩阵（二维数组）" class="headerlink" title="矩阵（二维数组）"></a>矩阵（二维数组）</h1><p>形式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[a₀₀, a₀₁, a₀₂, ... , a₀n]</span><br><span class="line"> [a₁₀, a₁₁, a₁₂, ... , a₁n]</span><br><span class="line"> ...</span><br><span class="line"> [an₀, an₁, an₂, ... , ann]]</span><br></pre></td></tr></table></figure>
<p>优缺点同上</p>
<h2 id="常见操作-1"><a href="#常见操作-1" class="headerlink" title="常见操作"></a>常见操作</h2><ol>
<li><p>矩阵转置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function transforms the A matrix into the B matrix.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tranmat</span><span class="params">(<span class="keyword">int</span> A[][maxSize], <span class="keyword">int</span> B[][maxSize], <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            B[j][i] = A[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>矩阵相加</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function adds the A matrix to the B matrix and returns the C matrix.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addmat</span><span class="params">(<span class="keyword">int</span> C[][maxSize], <span class="keyword">int</span> A[][maxSize], <span class="keyword">int</span> B[][maxSize], <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            C[i][j] = A[i][j] + B[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>矩阵相乘</p>
<p>矩阵相乘的前提是A的行数 = B的列数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function multiples the A matrix by the B matrix and returns the C matrix.</span></span><br><span class="line"><span class="comment"> * A : m*n, B : n*k</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multmat</span><span class="params">(<span class="keyword">int</span> C[][maxSize], <span class="keyword">int</span> A[][maxSize], <span class="keyword">int</span> B[][maxSize], <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            C[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; n; h++) &#123;</span><br><span class="line">                C[i][j] += A[i][h] + B[h][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="特殊矩阵和稀疏矩阵"><a href="#特殊矩阵和稀疏矩阵" class="headerlink" title="特殊矩阵和稀疏矩阵"></a>特殊矩阵和稀疏矩阵</h2><ol>
<li>对称矩阵<br>aij = aji</li>
<li>三角矩阵<ul>
<li>上三角阵</li>
<li>下三角阵</li>
</ul>
</li>
<li>对角矩阵<br>主对角线及其上下两条线上存在数据，其他全为C</li>
<li>稀疏矩阵<br>非零元素占少数，0占大多数的矩阵。</li>
</ol>
<h1 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h1><p>表内元素可以是原子或广义表的一种线性表的扩展元素。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>1.两数之和</title>
    <url>/2020070652823/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="思路1："><a href="#思路1：" class="headerlink" title="思路1："></a>思路1：</h2><p>for循环嵌套，时间复杂度较高：O(n²)</p>
<h3 id="C"><a href="#C" class="headerlink" title="C:"></a>C:</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span>* result = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">2</span>);</span><br><span class="line">    *returnSize = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; numsSize; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                result[<span class="number">0</span>] = i;</span><br><span class="line">                result[<span class="number">1</span>] = j;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python:"></a>Python:</h3>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        lens = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(lens - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, lens):</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] == target:</span><br><span class="line">                    res.append(i)</span><br><span class="line">                    res.append(j)</span><br><span class="line">                    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>hash-table</tag>
      </tags>
  </entry>
  <entry>
    <title>103.二叉树的锯齿形层次遍历</title>
    <url>/2020070553249/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<p>例如：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回锯齿形层次遍历如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>简单的二叉树层次遍历；</p>
<p>加一个flag标志，将奇数层的节点列表反转即可。</p>
<h4 id="Python："><a href="#Python：" class="headerlink" title="Python："></a>Python：</h4>   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line">        q = Queue()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        q.put(root)</span><br><span class="line">        level = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">            n = q.qsize()</span><br><span class="line">            level_list = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                cur = q.get()</span><br><span class="line">                level_list.append(cur.val)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> cur.left != <span class="literal">None</span>:</span><br><span class="line">                    q.put(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right != <span class="literal">None</span>:</span><br><span class="line">                    q.put(cur.right)</span><br><span class="line">            <span class="keyword">if</span> level % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                level_list.reverse()</span><br><span class="line">            print(<span class="built_in">str</span>(level) + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(level_list))</span><br><span class="line">            level += <span class="number">1</span></span><br><span class="line">            res.append(level_list)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/202007010/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>20.有效的括号</title>
    <url>/2020063063451/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
</ol>
<p>注意空字符串可被认为是有效字符串。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;()&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;(]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p><strong>示例 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;([)]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p><strong>示例 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用数组模拟栈操作，遇到  <strong>( { [</strong>  时入栈，遇到  <strong>) } ]</strong>  时出栈（当且仅当待入栈符号与栈顶元素相差1或2时，才能出栈，否则仍入栈），遍历整个字符串后，栈空则匹配成功；否则失败。</p>
<h3 id="C代码"><a href="#C代码" class="headerlink" title="C代码"></a>C代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>* str = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(s) + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//一次性申请s字符串所占空间，+1是因为&#x27;\0&#x27;</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (s[i] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span> || s[i] == <span class="string">&#x27;&#123;&#x27;</span> || s[i] == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">            str[++top] = s[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == str[top] + <span class="number">1</span> || s[i] == str[top] + <span class="number">2</span>)</span><br><span class="line">            <span class="comment">//&#x27;(&#x27;与&#x27;)&#x27;的ASCII值差1，&#x27;[&#x27;与&#x27;]&#x27;，&#x27;&#123;&#x27;与&#x27;&#125;&#x27;的ASCII值差2</span></span><br><span class="line">            top--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>当字符串中存在已匹配的字符串时，就用空字符串替代；如果字符串最后为空，则全部匹配；否则失败。</p>
<h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="string">&#x27;()&#x27;</span> <span class="keyword">in</span> s <span class="keyword">or</span> <span class="string">&#x27;[]&#x27;</span> <span class="keyword">in</span> s <span class="keyword">or</span> <span class="string">&#x27;&#123;&#125;&#x27;</span><span class="keyword">in</span> s:</span><br><span class="line">            s = s.replace(<span class="string">&#x27;()&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            s = s.replace(<span class="string">&#x27;[]&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            s = s.replace(<span class="string">&#x27;&#123;&#125;&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> s == <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>stack</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode</title>
    <url>/2020061718503/</url>
    <content><![CDATA[<h1 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h1><p>由于经常使用VSCode刷C语言的题，<del>这两天又在写30天自制操作系统</del>，实在受不了VSCode默认的C代码风格，用了一个Prettier -Code formatter插件也不是很满意，在网上找到了使用Clang-format格式化，这是自带的。</p>
<p>Clang-format有多种风格，我最喜欢<strong>WebKit</strong>：</p>
<p><img src="https://s1.ax1x.com/2020/06/17/NABuiq.jpg" alt="NABuiq.jpg"></p>
<p>啊，舒服了~~</p>
<p>设置方式：</p>
<p>进入VSCode设置，搜索clang-format：</p>
<p><img src="https://s1.ax1x.com/2020/06/17/NABcTA.png" alt="NABcTA.png"></p>
<h1 id="实用插件"><a href="#实用插件" class="headerlink" title="实用插件"></a>实用插件</h1><ul>
<li>One Dark Pro</li>
<li>C/C++</li>
<li>indent-rainbow</li>
<li>Code Runner</li>
</ul>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>常用排序算法</title>
    <url>/2020040629759/</url>
    <content><![CDATA[<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">性能分析</th>
<th>特点</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">直接插入</td>
<td style="text-align:left">时间：- 最好：O(n)，- 最差：O(n^2)；空间：O(1)</td>
<td>适合元素基本有序的场景</td>
<td>稳定</td>
</tr>
<tr>
<td style="text-align:left">折半插入</td>
<td style="text-align:left">时间：- 最好：O(nlogn)，- 最差：O(n^2)；空间：O(1)</td>
<td>适合元素较多的场景</td>
<td>稳定</td>
</tr>
<tr>
<td style="text-align:left">希尔排序</td>
<td style="text-align:left">时间：- 最好：O(n^1.5)，- 最差：O(n^2)；空间：O(1)</td>
<td></td>
<td>不稳定</td>
</tr>
<tr>
<td style="text-align:left">冒泡排序</td>
<td style="text-align:left">时间：- 最好：O(n)，- 最差：O(n^2)；空间：O(1)</td>
<td>适合元素基本有序的场景</td>
<td>稳定</td>
</tr>
<tr>
<td style="text-align:left">快速排序</td>
<td style="text-align:left">时间：- 最好：O(nlogn)， - 最差：O(n^2)；空间：O(logn)</td>
<td>序列越无序，效率越高；反之，效率越低</td>
<td>不稳定</td>
</tr>
<tr>
<td style="text-align:left">选择排序</td>
<td style="text-align:left">时间：O(n^2)；空间：O(1)</td>
<td></td>
<td>不稳定</td>
</tr>
<tr>
<td style="text-align:left">堆排序</td>
<td style="text-align:left">时间：O(nlogn)；空间：O(1)</td>
<td>适合元素较多的场景</td>
<td>不稳定</td>
</tr>
<tr>
<td style="text-align:left">归并排序</td>
<td style="text-align:left">时间：O(nlogn)；空间：O(n)</td>
<td></td>
<td>稳定</td>
</tr>
</tbody>
</table>
</div>
<h1 id="1-插入类排序"><a href="#1-插入类排序" class="headerlink" title="1.插入类排序"></a>1.插入类排序</h1><h2 id="1-1-直接插入排序"><a href="#1-1-直接插入排序" class="headerlink" title="1.1 直接插入排序"></a>1.1 直接插入排序</h2><p>算法思想：</p>
<ol>
<li>逐个扫描，从后向前依次进行比较，</li>
<li>插入合适位置</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inserSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> arrSize)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//插入排序</span></span><br><span class="line">    <span class="keyword">int</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; arrSize; ++i) <span class="comment">//默认第一个元素有序，从第二个元素开始</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp = arr[i]; <span class="comment">//将待插入的关键字存储在temp中</span></span><br><span class="line">        j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; arr[j]) <span class="comment">//从待插入的关键字向前扫描，将大于temp的元素向后移一位</span></span><br><span class="line">        &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = temp; <span class="comment">//将待插入的关键字插入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-2-折半插入排序"><a href="#1-2-折半插入排序" class="headerlink" title="1.2 折半插入排序"></a>1.2 折半插入排序</h2><p>算法思想：</p>
<ol>
<li>引入上下标，非遍历，</li>
<li>每次访问上下标中间的数，进行前后比较，插入</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binaryInsertSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> arrSize)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//折半插入排序</span></span><br><span class="line">    <span class="keyword">int</span> i, low, high, mid;</span><br><span class="line">    low = <span class="number">0</span>, high = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; arrSize; ++i) <span class="comment">//默认第一个元素有序，从第二个元素开始</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (low + high) / <span class="number">2</span>;     <span class="comment">//mid向下取整</span></span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &gt; arr[i])      <span class="comment">//arr[mid]大于待插入元素时，说明要向低半区插入</span></span><br><span class="line">                high = mid - <span class="number">1</span>;         <span class="comment">//更新high</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; arr[i]) <span class="comment">//arr[mid]小于待插入元素时，说明要向高半区插入</span></span><br><span class="line">                low = mid + <span class="number">1</span>;          <span class="comment">//更新low</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//low &gt; high时，跳出循环，开始插入元素</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[i]; <span class="comment">//将待插入的关键字存储在temp中</span></span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= mid &amp;&amp; temp &lt; arr[j])<span class="comment">//从待插入的关键字向前扫描，将大于temp的元素向后移一位</span></span><br><span class="line">        &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = temp; <span class="comment">//将待插入的关键字插入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-3-希尔排序"><a href="#1-3-希尔排序" class="headerlink" title="1.3 希尔排序"></a>1.3 希尔排序</h2><p>算法思路：</p>
<ol>
<li>以固定增量将待排序列分成n组</li>
<li>进行组内排序；</li>
<li>选取更小的增量重复进行，直到增量为1</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> arrSize)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//希尔排序</span></span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; arrSize / <span class="number">3</span>)</span><br><span class="line">        h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = h; i &lt; arrSize; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &gt;= h &amp;&amp; (arr[j] &lt; arr[j - h]); j -= h)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j - h];</span><br><span class="line">                arr[j - h] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-交换类排序"><a href="#2-交换类排序" class="headerlink" title="2.交换类排序"></a>2.交换类排序</h1><h2 id="2-1-冒泡排序"><a href="#2-1-冒泡排序" class="headerlink" title="2.1 冒泡排序"></a>2.1 冒泡排序</h2><p>算法思路：</p>
<ol>
<li>将待排序列中的两个相邻元素进行比较，</li>
<li>每次都将较大(小)元素置前，以完成降(升)序排序</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> arrSize)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//冒泡排序</span></span><br><span class="line">    <span class="keyword">int</span> i, j, temp, flag;</span><br><span class="line">    <span class="keyword">for</span> (i = arrSize - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="number">0</span>; <span class="comment">//标记本趟是否发生交换</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j - <span class="number">1</span>] &gt; arr[j])</span><br><span class="line">            &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">                arr[j - <span class="number">1</span>] = temp;</span><br><span class="line">                flag = <span class="number">1</span>; <span class="comment">//发生交换，flag = 1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) <span class="comment">//如果没有发生交换，说明序列有序</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-快速排序"><a href="#2-2-快速排序" class="headerlink" title="2.2 快速排序"></a>2.2 快速排序</h2><p>算法思想：</p>
<ol>
<li>引入头尾指针，以第一个元素为“轴”；</li>
<li>尾指针向前扫描，遇到比轴小的数时，放在头指针处；</li>
<li>变换扫描方向，头指针向后扫描，遇到比轴大的数时，放在尾指针处；</li>
<li>重复此过程，直到头尾指针相遇，即完成一次排序；</li>
<li>递归对轴的左右两部分分别进行此过程即可</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSortHelper</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//对arr[low]到arr[high]进行排序</span></span><br><span class="line">    <span class="keyword">int</span> temp;              <span class="comment">//temp用于存储“轴”的值</span></span><br><span class="line">    <span class="keyword">int</span> i = low, j = high; <span class="comment">//i为头指针，j为尾指针</span></span><br><span class="line">    <span class="keyword">if</span> (low &lt; high)        <span class="comment">//低位小于高位时，开始交换</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp = arr[low];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">        &#123;<span class="comment">//将数组中小于temp的元素放在temp左边，大于temp的元素放在temp右边</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; i &amp;&amp; arr[j] &gt;= temp) <span class="comment">//从右向左扫描，找到一个小于temp的元素</span></span><br><span class="line">                --j;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[i] = arr[j]; <span class="comment">//将元素放在temp左边</span></span><br><span class="line">                ++i;             <span class="comment">//头指针右移</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt; temp) <span class="comment">//从左向右扫描，找到一个大于temp的元素</span></span><br><span class="line">                ++i;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[j] = arr[i]; <span class="comment">//将元素放在temp右边</span></span><br><span class="line">                --j;             <span class="comment">//尾指针右移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = temp;                     <span class="comment">//将temp放在最终位置</span></span><br><span class="line">        quickSortHelper(arr, low, i - <span class="number">1</span>);  <span class="comment">//递归排序temp左边</span></span><br><span class="line">        quickSortHelper(arr, i + <span class="number">1</span>, high); <span class="comment">//递归排序temp右边</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> arrSize)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//快速排序</span></span><br><span class="line">    quickSortHelper(arr, <span class="number">0</span>, arrSize - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-选择类排序"><a href="#3-选择类排序" class="headerlink" title="3.选择类排序"></a>3.选择类排序</h1><h2 id="3-1-简单选择排序"><a href="#3-1-简单选择排序" class="headerlink" title="3.1 简单选择排序"></a>3.1 简单选择排序</h2><p>算法思想：</p>
<ol>
<li>找出无序序列中的最小关键字；</li>
<li>与第一个关键字进行位置交换；</li>
<li>循环此过程以遍历整个序列</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> arrSize)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//简单选择排序</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arrSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        k = i;</span><br><span class="line">        <span class="comment">//从无序序列中挑出最小的关键字</span></span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; arrSize; ++j)</span><br><span class="line">            <span class="keyword">if</span> (arr[k] &gt; arr[j])</span><br><span class="line">                k = j;</span><br><span class="line">        <span class="comment">//将最小关键字与无序序列的第一个关键字交换</span></span><br><span class="line">        temp = arr[i];</span><br><span class="line">        arr[i] = arr[k];</span><br><span class="line">        arr[k] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-堆排序"><a href="#3-2-堆排序" class="headerlink" title="3.2 堆排序"></a>3.2 堆排序</h2><p>算法思想：</p>
<ol>
<li>建堆；<ol>
<li>大根堆：升序排序</li>
<li>小根堆：降序排序</li>
</ol>
</li>
<li>删除根节点；</li>
<li>重建堆</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> i, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//建堆</span></span><br><span class="line">    <span class="comment">//标记左右孩子、最大节点的序号</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> largest = i;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[largest])</span><br><span class="line">        largest = left;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[largest])</span><br><span class="line">        largest = right;</span><br><span class="line">    <span class="keyword">if</span> (largest != i)</span><br><span class="line">    &#123; <span class="comment">//父节点不是最大节点时进行调整</span></span><br><span class="line">        swap(arr, i, largest);</span><br><span class="line">        heapify(arr, largest, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> arrSize)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//堆排序</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = arrSize / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) <span class="comment">//建堆</span></span><br><span class="line">        heapify(arr, i, arrSize);</span><br><span class="line">    <span class="keyword">for</span> (i = arrSize - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(arr, <span class="number">0</span>, i);    <span class="comment">//最后一个节点与根节点交换</span></span><br><span class="line">        heapify(arr, <span class="number">0</span>, i); <span class="comment">//剩余节点重新建堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4. 归并排序"></a>4. 归并排序</h1><p>算法思想：</p>
<ol>
<li>将待排序列看作一元组;</li>
<li>两两归并，排序为二元组;</li>
<li>以此类推，直至全部有序</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high, <span class="keyword">int</span> *help)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//使arr[low]到arr[mid]与arr[mid]到arr[high]有序</span></span><br><span class="line">    <span class="keyword">int</span> i = low, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid || j &lt;= high) <span class="comment">//循环直到所有元素排序完毕</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &lt;= high &amp;&amp; (arr[i] &gt;= arr[j] || i &gt; mid))</span><br><span class="line">        &#123; <span class="comment">//m[i] &gt;= m[j]或者前半段已完全排序,而后半段未完全排序的情况</span></span><br><span class="line">            help[i - low + j - mid - <span class="number">1</span>] = arr[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i &lt;= mid || j &gt; high)</span><br><span class="line">        &#123; <span class="comment">//m[i] &lt; m[j]或后半段已完全排序而前半段未完全排序的情况</span></span><br><span class="line">            help[i - low + j - mid - <span class="number">1</span>] = arr[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = low; i &lt;= high; i++) <span class="comment">//将排序好的值赋值给原数组</span></span><br><span class="line">        arr[i] = help[i - low];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSortHelper</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> *help)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//递归对左右部分进行归并排序，这里体现了二路归并排序</span></span><br><span class="line">        mergeSortHelper(arr, low, mid, help);</span><br><span class="line">        mergeSortHelper(arr, mid + <span class="number">1</span>, high, help);</span><br><span class="line">        <span class="comment">//使arr数组的前后两部分有序</span></span><br><span class="line">        merge(arr, low, mid, high, help);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> arrSize)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//归并排序</span></span><br><span class="line">    <span class="comment">//辅助数组，提供额外空间</span></span><br><span class="line">    <span class="keyword">int</span> help[arrSize];</span><br><span class="line">    mergeSortHelper(arr, <span class="number">0</span>, arrSize - <span class="number">1</span>, help);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>Java上溯造型与动态绑定</title>
    <url>/2020040131117/</url>
    <content><![CDATA[<h2 id="1-上溯造型"><a href="#1-上溯造型" class="headerlink" title="1.上溯造型"></a>1.上溯造型</h2><h3 id="1-1-什么是上溯造型"><a href="#1-1-什么是上溯造型" class="headerlink" title="1.1 什么是上溯造型"></a>1.1 什么是上溯造型</h3><p>以代码为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Instrument</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;play()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Instrument i)</span></span>&#123;</span><br><span class="line">        i.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">extends</span> <span class="title">Instrument</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Wind flute = <span class="keyword">new</span> Wind();</span><br><span class="line">        <span class="comment">//一个Wind对象也是一个Instrument对象</span></span><br><span class="line">        <span class="comment">//从Wind类型的句柄flute转换为Instrument类型，这就是造型上溯</span></span><br><span class="line">        Instrument.tune(flute);         <span class="comment">//Upcasting</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>上溯造型：将子类句柄转化为父类类型</strong></p>
<p>此时类的衍生关系可表示为：</p>
<p><img src="https://i.loli.net/2020/04/03/fCQaNA95tvJGmhz.png" alt="image.png" style="zoom: 67%;" /></p>
<h3 id="1-2-为什么要使用上溯造型"><a href="#1-2-为什么要使用上溯造型" class="headerlink" title="1.2 为什么要使用上溯造型"></a>1.2 为什么要使用上溯造型</h3><h4 id="1-2-1-不使用上溯造型"><a href="#1-2-1-不使用上溯造型" class="headerlink" title="1.2.1 不使用上溯造型"></a>1.2.1 不使用上溯造型</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Note2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Note2</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; value = val; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Note2</span><br><span class="line">            middleC = <span class="keyword">new</span> Note2(<span class="number">0</span>),</span><br><span class="line">            cSharp = <span class="keyword">new</span> Note2(<span class="number">1</span>),</span><br><span class="line">            cFlat = <span class="keyword">new</span> Note2(<span class="number">2</span>);</span><br><span class="line">&#125; <span class="comment">// Etc.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Instrument2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note2 n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Instrument2.play()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wind2</span> <span class="keyword">extends</span> <span class="title">Instrument2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note2 n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Wind2.play()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stringed2</span> <span class="keyword">extends</span> <span class="title">Instrument2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note2 n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Stringed2.play()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brass2</span> <span class="keyword">extends</span> <span class="title">Instrument2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note2 n)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Brass2.play()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Wind2 i)</span> </span>&#123;</span><br><span class="line">        i.play(Note2.middleC);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Stringed2 i)</span> </span>&#123;</span><br><span class="line">        i.play(Note2.middleC);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Brass2 i)</span> </span>&#123;</span><br><span class="line">        i.play(Note2.middleC);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Wind2 flute = <span class="keyword">new</span> Wind2();</span><br><span class="line">        Stringed2 violin = <span class="keyword">new</span> Stringed2();</span><br><span class="line">        Brass2 frenchHorn = <span class="keyword">new</span> Brass2();</span><br><span class="line">        tune(flute); <span class="comment">// No upcasting</span></span><br><span class="line">        tune(violin);</span><br><span class="line">        tune(frenchHorn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过观察，我们可以发现：不使用上溯造型时，我们需要为不同的子类定制接口，并重载父类方法，但他们的功能却大致相同，这使得我们的工作量巨大</p>
<h4 id="1-2-2-使用上溯造型"><a href="#1-2-2-使用上溯造型" class="headerlink" title="1.2.2 使用上溯造型"></a>1.2.2 使用上溯造型</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Note</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Note</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;value = val;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Note middleC = <span class="keyword">new</span> Note(<span class="number">0</span>),</span><br><span class="line">                        cSharp = <span class="keyword">new</span> Note(<span class="number">1</span>), cFlat = <span class="keyword">new</span> Note(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Instrucment</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Instrucment.play()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">extends</span> <span class="title">Instrucment</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(Note n)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Wind.play()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Music</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tune</span><span class="params">(Instrucment i)</span></span>&#123;</span><br><span class="line">        i.play(Note.middleC);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Wind flute = <span class="keyword">new</span> Wind();</span><br><span class="line">        tune(flute);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用上溯造型，可以不管子类，而直接和父类交互，从而避免了大量重复代码，简少工作量，提高了代码的重用。</p>
<h3 id="1-3怎么上溯造型"><a href="#1-3怎么上溯造型" class="headerlink" title="1.3怎么上溯造型"></a>1.3怎么上溯造型</h3><p>正如定义所诉，不再赘述。</p>
<p><em>这里不禁有个疑问，父类是如何知道我们传入的是哪种子类对象，从而有不同的响应呢？接下来就引入动态绑定的概念：</em></p>
<p>（这里只是根据书中的解释粗浅的理解，挖个坑，以后再来填~~）</p>
<h2 id="2-动态绑定"><a href="#2-动态绑定" class="headerlink" title="2.动态绑定"></a>2.动态绑定</h2><p>绑定：将方法调用与方法主体连接在一起</p>
<ul>
<li>早期绑定：在程序运行以前执行绑定（C语言）</li>
<li>后期绑定（也叫运行期绑定、<strong>动态绑定</strong>）：提供<strong>某种机制</strong>，在运行期间判断对象的类型，调用适当的方法</li>
</ul>
<h3 id="2-1-什么是动态绑定"><a href="#2-1-什么是动态绑定" class="headerlink" title="2.1 什么是动态绑定"></a>2.1 什么是动态绑定</h3><blockquote>
<p>提供<strong>某种机制</strong>，在运行期间判断对象的类型，调用适当的方法</p>
</blockquote>
<h3 id="2-2-为什么使用动态绑定"><a href="#2-2-为什么使用动态绑定" class="headerlink" title="2.2 为什么使用动态绑定"></a>2.2 为什么使用动态绑定</h3><p>我想这里应该很清晰了，上溯造型只是为我们提供了一种简单而巧妙地方法，通过子类对象上溯父类类型，然而这并不是一个完整的过程，找到正确的父类类型后，还应该产生正确的相应，而动态绑定正是在此时发挥了作用</p>
<h3 id="2-3-怎么使用动态绑定"><a href="#2-3-怎么使用动态绑定" class="headerlink" title="2.3 怎么使用动态绑定"></a>2.3 怎么使用动态绑定</h3><p>动态绑定是由虚拟机代替我们实现的，在上溯造型并获得正确的响应后，动态绑定就体现在这一过程中，所以我们只需要理解其原理，弄清楚虚拟机是如何做到调用正确的方法即可。</p>
<p>（这个坑以后来填）</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>上溯造型</tag>
      </tags>
  </entry>
  <entry>
    <title>242.有效的字母异位词</title>
    <url>/2020040144708/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定两个字符串 <em>s</em> 和 <em>t</em> ，编写一个函数来判断 <em>t</em> 是否是 <em>s</em> 的字母异位词。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;rat&quot;, t &#x3D; &quot;car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong><br>你可以假设字符串只包含小写字母。</p>
<p><strong>进阶:</strong><br>如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-Hash表"><a href="#1-Hash表" class="headerlink" title="1.Hash表"></a>1.Hash表</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><p>将两个字符串分别映射到两个Hash表中，然后对比两个Hash表即可</p>
<h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">char</span> *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr1[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span> arr2[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arr1[i] = <span class="number">0</span>;</span><br><span class="line">        arr2[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s); i++)</span><br><span class="line">        arr1[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(t); i++)</span><br><span class="line">        arr2[t[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (arr1[i] != arr2[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-排序"><a href="#2-排序" class="headerlink" title="2.排序"></a>2.排序</h3><h4 id="2-1-思路"><a href="#2-1-思路" class="headerlink" title="2.1 思路"></a>2.1 思路</h4><p>分别将两个字符串的字符进行内排序，然后逐位比较两个字符串</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hash-table</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>733.图像渲染</title>
    <url>/2020040165238/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。</p>
<p>给你一个坐标 <code>(sr, sc)</code> 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 <code>newColor</code>，让你重新上色这幅图像。</p>
<p>为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。</p>
<p>最后返回经过上色渲染后的图像。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">image &#x3D; [[1,1,1],[1,1,0],[1,0,1]]</span><br><span class="line">sr &#x3D; 1, sc &#x3D; 1, newColor &#x3D; 2</span><br><span class="line">输出: [[2,2,2],[2,2,0],[2,0,1]]</span><br><span class="line">解析: </span><br><span class="line">在图像的正中间，(坐标(sr,sc)&#x3D;(1,1)),</span><br><span class="line">在路径上所有符合条件的像素点的颜色都被更改成2。</span><br><span class="line">注意，右下角的像素没有更改为2，</span><br><span class="line">因为它不是在上下左右四个方向上与初始点相连的像素点。</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ul>
<li><code>image</code> 和 <code>image[0]</code> 的长度在范围 <code>[1, 50]</code> 内。</li>
<li>给出的初始点将满足 <code>0 &lt;= sr &lt; image.length</code> 和 <code>0 &lt;= sc &lt; image[0].length</code>。</li>
<li><code>image[i][j]</code> 和 <code>newColor</code> 表示的颜色值在范围 <code>[0, 65535]</code>内。</li>
</ul>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归、DFS"><a href="#1-递归、DFS" class="headerlink" title="1.递归、DFS"></a>1.递归、DFS</h3><p>题目理解：将<code>image[sr][sc]</code>的上下左右四个方向的相邻像素单位转换为新值，前提是：各方向的值与<code>image[sr][sc]</code>相等</p>
<h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><ol>
<li>如果横纵坐标超出二维矩阵，终止递归</li>
<li>如果<code>image[sr][sc]</code>等于各方向的值，则令<code>image[sr][sc]</code>变为新颜色，然后递归执行这一过程</li>
</ol>
<h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an array of arrays of size *returnSize.</span></span><br><span class="line"><span class="comment"> * The sizes of the arrays are returned as *returnColumnSizes array.</span></span><br><span class="line"><span class="comment"> * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> **image, <span class="keyword">int</span> imageSize, <span class="keyword">int</span> *imageColSize, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sr &lt; <span class="number">0</span> || sr &gt;= imageSize || sc &lt; <span class="number">0</span> || sc &gt;= imageColSize[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (val == image[sr][sc])</span><br><span class="line">    &#123;</span><br><span class="line">        image[sr][sc] = newColor;</span><br><span class="line">        dfs(val, image, imageSize, imageColSize, sr, sc + <span class="number">1</span>, newColor);</span><br><span class="line">        dfs(val, image, imageSize, imageColSize, sr, sc - <span class="number">1</span>, newColor);</span><br><span class="line">        dfs(val, image, imageSize, imageColSize, sr + <span class="number">1</span>, sc, newColor);</span><br><span class="line">        dfs(val, image, imageSize, imageColSize, sr - <span class="number">1</span>, sc, newColor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> **<span class="title">floodFill</span><span class="params">(<span class="keyword">int</span> **image, <span class="keyword">int</span> imageSize, <span class="keyword">int</span> *imageColSize, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor, <span class="keyword">int</span> *returnSize, <span class="keyword">int</span> **returnColumnSizes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *returnSize = imageSize;</span><br><span class="line">    *returnColumnSizes = imageColSize;</span><br><span class="line">    <span class="keyword">if</span> (image[sr][sc] != newColor)</span><br><span class="line">        dfs(image[sr][sc], image, imageSize, imageColSize, sr, sc, newColor);</span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>depth-first-search</tag>
      </tags>
  </entry>
  <entry>
    <title>Java对象是如何创建的？</title>
    <url>/2020033138645/</url>
    <content><![CDATA[<h2 id="1-检查static关键字"><a href="#1-检查static关键字" class="headerlink" title="1.检查static关键字"></a>1.检查static关键字</h2><p>如果有static关键字修饰，即该对象为一个静态对象，那么其会被<strong>优先</strong>加载到虚拟机中执行；</p>
<h2 id="2-找到class"><a href="#2-找到class" class="headerlink" title="2.找到class"></a>2.找到class</h2><p>找到class后，会创建一个Class对象，其所有static模块都会执行，但是只在对象载入时执行一次</p>
<h2 id="3-分配内存"><a href="#3-分配内存" class="headerlink" title="3.分配内存"></a>3.分配内存</h2><p>此时，new关键字所修饰的类进程会在内存堆（Heap）中，为该类分配足够的内存空间</p>
<h2 id="4-初始化"><a href="#4-初始化" class="headerlink" title="4.初始化"></a>4.初始化</h2><p>这时，被分配的内存空间会被清零，并将不同的变量类型初始化为默认值（一般为0）</p>
<h2 id="5-执行构造器"><a href="#5-执行构造器" class="headerlink" title="5.执行构造器"></a>5.执行构造器</h2><p>最后执行构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//StaticInitialization.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bowl</span></span>&#123;</span><br><span class="line">    Bowl(<span class="keyword">int</span> maker)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bowl(&quot;</span>+maker+<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> maker)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;f(&quot;</span>+maker+<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Table</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Bowl b1 = <span class="keyword">new</span> Bowl(<span class="number">1</span>);</span><br><span class="line">    Table()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Table&quot;</span>);</span><br><span class="line">        b2.f(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> maker)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;f2(&quot;</span>+maker+<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> Bowl b2 = <span class="keyword">new</span> Bowl(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cupboard</span></span>&#123;</span><br><span class="line">    Bowl b3 = <span class="keyword">new</span> Bowl(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">static</span> Bowl b4 = <span class="keyword">new</span> Bowl(<span class="number">4</span>);</span><br><span class="line">    Cupboard()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cupboard()&quot;</span>);</span><br><span class="line">        b4.f(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">int</span> maker)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;f3(&quot;</span>+maker+<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> Bowl b5 = <span class="keyword">new</span> Bowl(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Desk</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> desk;</span><br><span class="line">    Desk()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Desk()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> Bowl b6 = <span class="keyword">new</span> Bowl(<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInitialization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating new Cupboard in main&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Cupboard();</span><br><span class="line">        <span class="comment">//t2，t3已经实现被实例化了</span></span><br><span class="line">        t2.f2(<span class="number">1</span>);</span><br><span class="line">        t3.f3(<span class="number">1</span>);</span><br><span class="line">        System.out.println(desk.desk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态对象被优先加载</span></span><br><span class="line">    <span class="keyword">static</span> Table t2 = <span class="keyword">new</span> Table();</span><br><span class="line">    <span class="keyword">static</span> Cupboard t3 = <span class="keyword">new</span> Cupboard();</span><br><span class="line">    <span class="keyword">static</span> Desk desk = <span class="keyword">new</span> Desk();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里解释一下：<strong>为什么主函数之外的代码先执行了？</strong></p>
<p>Java编译时会从main()所在的类开始编译，然后main()外的对象实例化都是静态的，所以，其会被优先加载到虚拟机中执行，执行完毕后，在进入主函数。</p>
<p>如果主函数变成这样呢：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInitialization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating new Cupboard in main&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Cupboard();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，main()函数外没有静态变量，所以直接进入主函数；</p>
<ol>
<li>输出：Creating new Cupboard in main</li>
<li>实例化一个Cupboard()对象：<ol>
<li>寻找名为Cupboard的class</li>
<li>先执行其中的static</li>
<li>再执行构造器</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo</title>
    <url>/2020032737733/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol>
<li>安装Hexo脚手架：<code>npm install -g hexo-cli</code></li>
<li>在任意目录下初始化：<code>hexo init Blog</code></li>
</ol>
<h1 id="实用插件"><a href="#实用插件" class="headerlink" title="实用插件"></a>实用插件</h1><ul>
<li><p>hexagon</p>
<ul>
<li><p>hexo的包管理工具</p>
</li>
<li><p>安装：<code>npm install -g hexagon-cli</code></p>
</li>
<li><p>查看初始化后的hexo的所有插件和主题：<code>hexa -l</code></p>
</li>
</ul>
</li>
<li><p>hexo-auto-category</p>
<ul>
<li>自动解析文章目录，方便博文归类整理</li>
<li>安装：<code>npm install hexo-auto-category --save</code></li>
</ul>
</li>
<li><p>hexo-wordcount</p>
<ul>
<li>自动统计文章字数</li>
</ul>
</li>
<li><p>hexo-symbols-count-time</p>
<ul>
<li>自动统计阅读时长</li>
</ul>
</li>
<li>hexo-renderer-kramed<ul>
<li>Latex渲染引擎</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>108.将有序数组转换为二叉搜索树</title>
    <url>/2020032117850/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定有序数组: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     &#x2F; \</span><br><span class="line">   -3   9</span><br><span class="line">   &#x2F;   &#x2F;</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><ol>
<li>类似于二分查找的过程，向下取整，构建二叉搜索树</li>
</ol>
<p><strong>注意：使用中序遍历构建的二叉搜索树形态不唯一</strong></p>
<h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct TreeNode *<span class="title">help</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">root</span> =</span> (struct TreeNode *)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">    <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;<span class="comment">//参考评论，防止溢出</span></span><br><span class="line">    root-&gt;val = nums[mid];</span><br><span class="line">    root-&gt;left = help(nums, l, mid - <span class="number">1</span>);</span><br><span class="line">    root-&gt;right = help(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">struct TreeNode *<span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> help(nums, <span class="number">0</span>, numsSize - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>depth-first-search</tag>
      </tags>
  </entry>
  <entry>
    <title>669.修剪二叉搜索树</title>
    <url>/2020032161487/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个二叉搜索树，同时给定最小边界<code>L</code> 和最大边界 <code>R</code>。通过修剪二叉搜索树，使得所有节点的值在<code>[L, R]</code>中 (R&gt;=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  0   2</span><br><span class="line"></span><br><span class="line">  L &#x3D; 1</span><br><span class="line">  R &#x3D; 2</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line">    1</span><br><span class="line">      \</span><br><span class="line">       2</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  0   4</span><br><span class="line">   \</span><br><span class="line">    2</span><br><span class="line">   &#x2F;</span><br><span class="line">  1</span><br><span class="line"></span><br><span class="line">  L &#x3D; 1</span><br><span class="line">  R &#x3D; 3</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line">      3</span><br><span class="line">     &#x2F; </span><br><span class="line">   2   </span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br></pre></td></tr></table></figure>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><p>完全参考<a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/solution/xiu-jian-er-cha-sou-suo-shu-by-leetcode/">官方题解</a>，这个方法太巧妙了，学习了！</p>
<blockquote>
<p><strong>思路</strong></p>
<p>令 trim(node) 作为该节点上的子树的理想答案。我们可以递归地构建该答案。</p>
<p><strong>算法</strong></p>
<p>当 node.val &gt; R，那么修剪后的二叉树必定出现在节点的左边。</p>
<p>类似地，当node.val &lt; L，那么修剪后的二叉树出现在节点的右边。否则，我们将会修剪树的两边。</p>
</blockquote>
<h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode *<span class="title">trimBST</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &lt; L)</span><br><span class="line">        <span class="keyword">return</span> trimBST(root-&gt;right, L, R);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &gt; R)</span><br><span class="line">        <span class="keyword">return</span> trimBST(root-&gt;left, L, R);</span><br><span class="line">    root-&gt;left = trimBST(root-&gt;left, L, R);</span><br><span class="line">    root-&gt;right = trimBST(root-&gt;right, L, R);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>938.二叉搜索树的范围和</title>
    <url>/2020031957722/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定二叉搜索树的根结点 <code>root</code>，返回 <code>L</code> 和 <code>R</code>（含）之间的所有结点的值的和。</p>
<p>二叉搜索树保证具有唯一的值。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [10,5,15,3,7,null,18], L &#x3D; 7, R &#x3D; 15</span><br><span class="line">输出：32</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [10,5,15,3,7,13,18,1,null,6], L &#x3D; 6, R &#x3D; 10</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li>树中的结点数量最多为 <code>10000</code> 个。</li>
<li>最终的答案保证小于 <code>2^31</code>。</li>
</ol>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><p>思路非常简单，递归判断左右子树，符合要求就将值并入sum，最后返回sum</p>
<h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rangeSumBST</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &gt;= L &amp;&amp; root-&gt;val &lt;= R)</span><br><span class="line">        sum += root-&gt;val;</span><br><span class="line">    <span class="keyword">int</span> l = rangeSumBST(root-&gt;left, L, R);</span><br><span class="line">    <span class="keyword">int</span> r = rangeSumBST(root-&gt;right, L, R);</span><br><span class="line">    sum = sum + l + r;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>965.单值二叉树</title>
    <url>/2020031923916/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>如果二叉树每个节点都具有相同的值，那么该二叉树就是<em>单值</em>二叉树。</p>
<p>只有给定的树是单值二叉树时，才返回 <code>true</code>；否则返回 <code>false</code>。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://i.loli.net/2020/03/19/OpILqw2D4Gizg8b.png" alt="binarysearchtree_improved.png" style="zoom:33%;" /></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,1,1,1,1,null,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://i.loli.net/2020/03/19/Kwfm71GPi9W6nMy.png" alt="screen-shot-2018-12-25-at-50050-pm.png" style="zoom:33%;" /></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[2,2,2,5,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li>给定树的节点数范围是 <code>[1, 100]</code>。</li>
<li>每个节点的值都是整数，范围为 <code>[0, 99]</code> 。</li>
</ol>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><ol>
<li>空树为单值二叉树</li>
<li>不是空树时，递归判断根节点的值与孩子节点是否相等</li>
<li>左右子树都相等时，返回true，否则返回false</li>
</ol>
<h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">help</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == val)</span><br><span class="line">        <span class="keyword">return</span> help(root-&gt;left, val) &amp;&amp; help(root-&gt;right, val);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isUnivalTree</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> single = root-&gt;val;</span><br><span class="line">    <span class="keyword">return</span> help(root-&gt;left, single) &amp;&amp; help(root-&gt;right, single);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>993.二叉树的堂兄弟节点</title>
    <url>/2020031916967/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>在二叉树中，根节点位于深度 <code>0</code> 处，每个深度为 <code>k</code> 的节点的子节点位于深度 <code>k+1</code> 处。</p>
<p>如果二叉树的两个节点深度相同，但<strong>父节点不同</strong>，则它们是一对<em>堂兄弟节点</em>。</p>
<p>我们给出了具有唯一值的二叉树的根节点 <code>root</code>，以及树中两个不同节点的值 <code>x</code> 和 <code>y</code>。</p>
<p>只有与值 <code>x</code> 和 <code>y</code> 对应的节点是堂兄弟节点时，才返回 <code>true</code>。否则，返回 <code>false</code>。</p>
<p><strong>示例 1：</strong><br><img src="https://i.loli.net/2020/03/19/XJyPZTOWcQK4AB2.png" alt="1.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3,4], x &#x3D; 4, y &#x3D; 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong><br><img src="https://i.loli.net/2020/03/19/1chzTqvHgXKRwfM.png" alt="2.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3,null,4,null,5], x &#x3D; 5, y &#x3D; 4</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<p><img src="https://i.loli.net/2020/03/19/ejY36O5HBMqkL8x.png" alt="3.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3,null,4], x &#x3D; 2, y &#x3D; 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li>二叉树的节点数介于 <code>2</code> 到 <code>100</code> 之间。</li>
<li>每个节点的值都是唯一的、范围为 <code>1</code> 到 <code>100</code> 的整数。</li>
</ol>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><p>关键信息：堂兄弟节点的定义：<strong>深度相同，父节点不同</strong></p>
<ol>
<li>使用辅助函数，求x和y的深度及其父节点</li>
<li>由于辅助函数执行完毕后，会释放函数内部变量的内存空间，参考了评论中一位大神的题解，可以使用结构体存储深度和父节点</li>
<li>递归调用help()函数即可</li>
</ol>
<h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//深度相同，父节点不同</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> deepth;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">father</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"><span class="comment">//求深度和父节点</span></span><br><span class="line">help(struct TreeNode *root, <span class="keyword">int</span> val, <span class="keyword">int</span> deepth, struct TreeNode *father, struct Node *node)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == val)</span><br><span class="line">    &#123;</span><br><span class="line">        node-&gt;father = father;</span><br><span class="line">        node-&gt;deepth = deepth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        help(root-&gt;left, val, deepth + <span class="number">1</span>, root, node);</span><br><span class="line">        help(root-&gt;right, val, deepth + <span class="number">1</span>, root, node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isCousins</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">node1</span> =</span> (struct Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">node2</span> =</span> (struct Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">    node1-&gt;deepth = <span class="number">0</span>;</span><br><span class="line">    node1-&gt;father = <span class="literal">NULL</span>;</span><br><span class="line">    node2-&gt;deepth = <span class="number">0</span>;</span><br><span class="line">    node2-&gt;father = <span class="literal">NULL</span>;</span><br><span class="line">    help(root, x, <span class="number">0</span>, <span class="literal">NULL</span>, node1);</span><br><span class="line">    help(root, y, <span class="number">0</span>, <span class="literal">NULL</span>, node2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, node1-&gt;deepth);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, node2-&gt;deepth);</span><br><span class="line">    <span class="keyword">return</span> node1-&gt;deepth == node2-&gt;deepth &amp;&amp; node1-&gt;father != node2-&gt;father;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>672.二叉树中第二小的节点</title>
    <url>/2020031843759/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 <code>2</code> 或 <code>0</code>。如果一个节点有两个子节点的话，那么这个节点的值不大于它的子节点的值。 </p>
<p>给出这样的一个二叉树，你需要输出所有节点中的<strong>第二小的值。</strong>如果第二小的值不存在的话，输出 -1 <strong>。</strong></p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    5   7</span><br><span class="line"></span><br><span class="line">输出: 5</span><br><span class="line">说明: 最小的值是 2 ，第二小的值是 5 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"></span><br><span class="line">输出: -1</span><br><span class="line">说明: 最小的值是 2, 但是不存在第二小的值。</span><br></pre></td></tr></table></figure>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><p>关键条件：根节点 &lt;= 孩子节点。由此可得根节点为最小的节点。</p>
<p>如果两个孩子节点都大于根节点，则不向下递归，返回较小的值；</p>
<p>否则：即存在根节点 == 孩子节点的情况</p>
<ul>
<li>如果左孩子等于根节点，则在此处的孩子节点不存在比不存在第二小的节点，那么继续向下递归，寻找此子树中比根节点大的值，并返回这个值，并与右孩子比较</li>
<li>如果右孩子等于根节点，同上</li>
<li>如果有一个孩子大于根节点，则返回这个值，等于根节点的子树继续递归，不存在则返回 -1</li>
</ul>
<h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">help</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> min)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &gt; min)</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    <span class="keyword">int</span> l = help(root-&gt;left, min);</span><br><span class="line">    <span class="keyword">int</span> r = help(root-&gt;right, min);</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">return</span> l &gt; r ? r : l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findSecondMinimumValue</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> help(root, root-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>700.二叉搜索树中的搜索</title>
    <url>/202003166604/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p>
<p>例如，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定二叉搜索树:</span><br><span class="line"></span><br><span class="line">        4</span><br><span class="line">       &#x2F; \</span><br><span class="line">      2   7</span><br><span class="line">     &#x2F; \</span><br><span class="line">    1   3</span><br><span class="line"></span><br><span class="line">和值: 2</span><br></pre></td></tr></table></figure>
<p>你应该返回如下子树:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  2     </span><br><span class="line"> &#x2F; \   </span><br><span class="line">1   3</span><br></pre></td></tr></table></figure>
<p>在上述示例中，如果要找的值是 <code>5</code>，但因为没有节点值为 <code>5</code>，我们应该返回 <code>NULL</code>。</p>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-二叉搜索树的遍历"><a href="#1-二叉搜索树的遍历" class="headerlink" title="1.二叉搜索树的遍历"></a>1.二叉搜索树的遍历</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><ol>
<li>根节点的值大于val时，根节点指向左孩子；</li>
<li>根节点的值小于val时，根节点指向右孩子；</li>
<li>否则返回根节点</li>
</ol>
<h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode *<span class="title">searchBST</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; val)</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; val)</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>872.叶子相似的树</title>
    <url>/2020031660530/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>请考虑一颗二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 <em>叶值序列</em> 。</p>
<p><img src="https://i.loli.net/2020/03/16/l6cBuoOSaj1Eg5L.png" alt="binarysearchtree_improved.png" style="zoom:50%;" /></p>
<p>举个例子，如上图所示，给定一颗叶值序列为 <code>(6, 7, 4, 9, 8)</code> 的树。</p>
<p>如果有两颗二叉树的叶值序列是相同，那么我们就认为它们是 <em>叶相似</em> 的。</p>
<p>如果给定的两个头结点分别为 <code>root1</code> 和 <code>root2</code> 的树是叶相似的，则返回 <code>true</code>；否则返回 <code>false</code> 。</p>
<p><strong>提示：</strong></p>
<ul>
<li>给定的两颗树可能会有 <code>1</code> 到 <code>100</code> 个结点。</li>
</ul>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><ol>
<li>如果root的左右子树都为空，就将此节点加入到数组中</li>
<li>递归调用上述过程</li>
<li>对比两个数组内容</li>
</ol>
<h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 100</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getLeaf</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *arr, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">        arr[(*returnSize)++] = root-&gt;val;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        getLeaf(root-&gt;left, arr, returnSize);</span><br><span class="line">        getLeaf(root-&gt;right, arr, returnSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">leafSimilar</span><span class="params">(struct TreeNode *root1, struct TreeNode *root2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr1[maxSize];</span><br><span class="line">    <span class="keyword">int</span> len1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> arr2[maxSize];</span><br><span class="line">    <span class="keyword">int</span> len2 = <span class="number">0</span>;</span><br><span class="line">    getLeaf(root1, arr1, &amp;len1);</span><br><span class="line">    getLeaf(root2, arr2, &amp;len2);</span><br><span class="line">    <span class="keyword">if</span> (len1 != len2)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++)</span><br><span class="line">        <span class="keyword">if</span> (arr1[i] != arr2[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>depth-first-search</tag>
      </tags>
  </entry>
  <entry>
    <title>897.递增顺序查找树</title>
    <url>/2020031636925/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个树，<strong>按中序遍历</strong>重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。</p>
<p><strong>示例 ：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[5,3,6,2,4,null,8,1,null,null,null,7,9]</span><br><span class="line"></span><br><span class="line">       5</span><br><span class="line">      &#x2F; \</span><br><span class="line">    3    6</span><br><span class="line">   &#x2F; \    \</span><br><span class="line">  2   4    8</span><br><span class="line"> &#x2F;        &#x2F; \ </span><br><span class="line">1        7   9</span><br><span class="line"></span><br><span class="line">输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]</span><br><span class="line"></span><br><span class="line"> 1</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">    \</span><br><span class="line">     3</span><br><span class="line">      \</span><br><span class="line">       4</span><br><span class="line">        \</span><br><span class="line">         5</span><br><span class="line">          \</span><br><span class="line">           6</span><br><span class="line">            \</span><br><span class="line">             7</span><br><span class="line">              \</span><br><span class="line">               8</span><br><span class="line">                \</span><br><span class="line">                 9  </span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li>给定树中的结点数介于 1 和 100 之间。</li>
<li>每个结点都有一个从 0 到 1000 范围内的唯一整数值。</li>
</ol>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><p>参考了<a href="https://leetcode-cn.com/u/rebellious_robot/">rebellious_robot</a>的题解</p>
<ol>
<li><strong>声明一个父节点指针，协助递归过程</strong></li>
<li>向左递归访问，如果孩子节点为空，则返回父节点</li>
<li>令孩子节点的左孩子为空</li>
<li>孩子节点的右孩子则为：递归访问<strong>父节点</strong>的右孩子</li>
</ol>
<p><strong>父节点的作用是为了递归遍历右子树的，如果没有这个父节点，那么在递归函数的一次完整的执行过程中，无法访问递归右子树。</strong></p>
<h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct TreeNode *<span class="title">help</span><span class="params">(struct TreeNode *child, struct TreeNode *father)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> father;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">cur</span> =</span> help(child-&gt;left, child);</span><br><span class="line">    child-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    child-&gt;right = help(child-&gt;right, father);</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">struct TreeNode *<span class="title">increasingBST</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> help(root, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-迭代-构建新树"><a href="#2-迭代-构建新树" class="headerlink" title="2.迭代+构建新树"></a>2.迭代+构建新树</h3><h4 id="2-1-思路"><a href="#2-1-思路" class="headerlink" title="2.1 思路"></a>2.1 思路</h4><ol>
<li>中序遍历，遍历结果存储在数组中</li>
<li>借助数组，创建一颗新树</li>
</ol>
<h4 id="2-2-代码"><a href="#2-2-代码" class="headerlink" title="2.2 代码"></a>2.2 代码</h4>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct TreeNode *<span class="title">increasingBST</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">stack</span>[100], *<span class="title">p</span> =</span> root;</span><br><span class="line">    <span class="keyword">int</span> stackTop = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> arrTop = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (stackTop != <span class="number">-1</span> || p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">stack</span>[++stackTop] = p;</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        p = <span class="built_in">stack</span>[stackTop--];</span><br><span class="line">        arr[++arrTop] = p-&gt;val;</span><br><span class="line">        p = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">res</span> =</span> (struct TreeNode *)<span class="built_in">malloc</span>(<span class="number">1</span> * <span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">    res-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    res-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    res-&gt;val = arr[<span class="number">0</span>];</span><br><span class="line">    p = res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= arrTop; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">cur</span> =</span> (struct TreeNode *)<span class="built_in">malloc</span>(<span class="number">1</span> * <span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">        cur-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        cur-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        cur-&gt;val = arr[i];</span><br><span class="line">        p-&gt;right = cur;</span><br><span class="line">        p = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>depth-first-search</tag>
      </tags>
  </entry>
  <entry>
    <title>501.二叉搜索树中的众数</title>
    <url>/2020031517526/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p>
<p>假定 BST 有如下定义：</p>
<ul>
<li>结点左子树中所含结点的值小于等于当前结点的值</li>
<li>结点右子树中所含结点的值大于等于当前结点的值</li>
<li>左子树和右子树都是二叉搜索树</li>
</ul>
<p>例如：<br>给定 BST <code>[1,null,2,2]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> &#x2F;</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p><code>返回[2]</code>.</p>
<p><strong>提示</strong>：如果众数超过1个，不需考虑输出顺序</p>
<p><strong>进阶：</strong>你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-迭代-遍历"><a href="#1-迭代-遍历" class="headerlink" title="1.迭代+遍历"></a>1.迭代+遍历</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><ol>
<li>迭代法获得递增序列</li>
<li>for循环寻找递增序列中的众数</li>
</ol>
<h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 10000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">findMode</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> arr[maxSize];</span><br><span class="line">    <span class="keyword">int</span> arrTop = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">stack</span>[<span class="title">maxSize</span>], *<span class="title">p</span> =</span> root;</span><br><span class="line">    <span class="keyword">int</span> stackTop = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (stackTop != <span class="number">-1</span> || p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">stack</span>[++stackTop] = p;</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        p = <span class="built_in">stack</span>[stackTop--];</span><br><span class="line">        arr[++arrTop] = p-&gt;val;</span><br><span class="line">        p = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在有序数组中找众数</span></span><br><span class="line">    <span class="keyword">int</span> *res = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(maxSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> mode = arr[<span class="number">0</span>]; <span class="comment">//当前数字</span></span><br><span class="line">    <span class="keyword">int</span> mode_num = <span class="number">0</span>;  <span class="comment">//当前数字的数量</span></span><br><span class="line">    <span class="keyword">int</span> nums = <span class="number">0</span>;      <span class="comment">//众数的数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= arrTop; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == mode) <span class="comment">//如果等于当前数字，</span></span><br><span class="line">            mode_num++;     <span class="comment">//当前数字数量加一</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            mode_num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (mode_num &gt; nums) <span class="comment">//如果当前数字的数量&gt;众数的数量</span></span><br><span class="line">        &#123;</span><br><span class="line">            res[<span class="number">0</span>] = arr[i]; <span class="comment">//从头开始添加众数</span></span><br><span class="line">            *returnSize = <span class="number">1</span>;</span><br><span class="line">            nums = mode_num; <span class="comment">//更新众数的数量</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mode_num == nums)</span><br><span class="line">            res[(*returnSize)++] = arr[i];</span><br><span class="line">        mode = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>617.合并二叉树</title>
    <url>/202003148682/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则<strong>不为</strong> NULL 的节点将直接作为新二叉树的节点。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">	Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         &#x2F; \                       &#x2F; \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       &#x2F;                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">输出: </span><br><span class="line">合并后的树:</span><br><span class="line">	     3</span><br><span class="line">	    &#x2F; \</span><br><span class="line">	   4   5</span><br><span class="line">	  &#x2F; \   \ </span><br><span class="line">	 5   4   7</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong> 合并必须从两个树的根节点开始。</p>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><p>当t1的左子树（右子树）与t2的左子树（右子树）都不为空时，递归地将t2树合并到t1树中</p>
<h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(struct TreeNode *t1, struct TreeNode *t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t1-&gt;val += t2-&gt;val;</span><br><span class="line">    <span class="keyword">if</span> (t1-&gt;left &amp;&amp; t2-&gt;left)</span><br><span class="line">        visit(t1-&gt;left, t2-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (!t1-&gt;left &amp;&amp; t2-&gt;left)</span><br><span class="line">        t1-&gt;left = t2-&gt;left;</span><br><span class="line">    <span class="keyword">if</span> (t1-&gt;right &amp;&amp; t2-&gt;right)</span><br><span class="line">        visit(t1-&gt;right, t2-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (!t1-&gt;right &amp;&amp; t2-&gt;right)</span><br><span class="line">        t1-&gt;right = t2-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">struct TreeNode *<span class="title">mergeTrees</span><span class="params">(struct TreeNode *t1, struct TreeNode *t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t1 == <span class="literal">NULL</span> &amp;&amp; t2 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1 != <span class="literal">NULL</span> &amp;&amp; t2 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    <span class="keyword">if</span> (t1 == <span class="literal">NULL</span> &amp;&amp; t2 != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> t2;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">p</span> =</span> t1;</span><br><span class="line">    visit(p, t2);</span><br><span class="line">    <span class="keyword">return</span> t1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>653.两数之和 IV - 输入 BST</title>
    <url>/2020031417472/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。</p>
<p><strong>案例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  3   6</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">2   4   7</span><br><span class="line"></span><br><span class="line">Target &#x3D; 9</span><br><span class="line"></span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>
<p><strong>案例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  3   6</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">2   4   7</span><br><span class="line"></span><br><span class="line">Target &#x3D; 28</span><br><span class="line"></span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-中序遍历-for嵌套"><a href="#1-中序遍历-for嵌套" class="headerlink" title="1.中序遍历+for嵌套"></a>1.中序遍历+for嵌套</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><ol>
<li>使用中序遍历得到一个递增数组</li>
<li>遍历递增数组</li>
</ol>
<h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 10000</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findTarget</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> arr[maxSize];</span><br><span class="line">    <span class="keyword">int</span> arrTop = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">stack</span>[<span class="title">maxSize</span>], *<span class="title">p</span> =</span> root;</span><br><span class="line">    <span class="keyword">int</span> stackTop = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (stackTop != <span class="number">-1</span> || p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">stack</span>[++stackTop] = p;</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        p = <span class="built_in">stack</span>[stackTop--];</span><br><span class="line">        arr[++arrTop] = p-&gt;val;</span><br><span class="line">        p = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrTop; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= arrTop; j++)</span><br><span class="line">            <span class="keyword">if</span> (arr[i] + arr[j] == k)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>687.最长同值路径</title>
    <url>/2020031462948/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。</p>
<p><strong>注意</strong>：两个节点之间的路径长度由它们之间的边数表示。</p>
<p><strong>示例 1:</strong></p>
<p>输入:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   5</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">1   1   5</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<p>输入:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   5</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">4   4   5</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong> 给定的二叉树不超过10000个结点。 树的高度不超过1000。</p>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><p>此题与<a href="https://www.wangtaocs.top/2020/03/12/543.二叉树的直径">543.二叉树的直径</a>和<a href="https://www.wangtaocs.top/2020/03/13/563.二叉树的坡度">563.二叉树的坡度</a>的思路非常相似</p>
<p>1.在递归过程中，左右子树中，与当前根节点值相等的节点数目的和的最大值</p>
<h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//左右子树中，与根节点值相等的节点数目的和的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">help</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> leftLen = help(root-&gt;left, num);</span><br><span class="line">    <span class="keyword">int</span> rightLen = help(root-&gt;right, num);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;val == root-&gt;val)<span class="comment">//向左遍历与根节点相等的子节点</span></span><br><span class="line">        l = <span class="number">1</span> + leftLen;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right != <span class="literal">NULL</span> &amp;&amp; root-&gt;right-&gt;val == root-&gt;val)<span class="comment">//向左遍历与根节点相等的子节点</span></span><br><span class="line">        r = <span class="number">1</span> + rightLen;</span><br><span class="line">    *num = *num &lt; (l + r) ? (l + r) : *num;</span><br><span class="line">    <span class="keyword">return</span> l &gt; r ? l : r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestUnivaluePath</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span> || (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    help(root, &amp;res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>recursion</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>538.把二叉搜索树转换为累加树</title>
    <url>/2020031359946/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。</p>
<p><strong>例如：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 原始二叉搜索树:</span><br><span class="line">              5</span><br><span class="line">            &#x2F;   \</span><br><span class="line">           2     13</span><br><span class="line"></span><br><span class="line">输出: 转换为累加树:</span><br><span class="line">             18</span><br><span class="line">            &#x2F;   \</span><br><span class="line">          20     13</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>本题和 1038: <a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同</p>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><ol>
<li>二叉搜索树的中序遍历是递增数列，则<strong>逆</strong>中序遍历则是递减序列</li>
<li>声明一个累加值res = 0；</li>
<li>利用这一性质，对其进行逆中序遍历，开始使用累加值更新节点值</li>
<li>在遍历左子树前，要更新res的值</li>
</ol>
<h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorderReverse</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    inorderReverse(root-&gt;right, res);</span><br><span class="line">   	root-&gt;val += *res;<span class="comment">//更新root节点的值</span></span><br><span class="line">    *res = root-&gt;val;<span class="comment">//更新res的值</span></span><br><span class="line">    inorderReverse(root-&gt;left, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode *<span class="title">convertBST</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    inorderReverse(root, &amp;res);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺便把1038题也做了 :)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>563.二叉树的坡度</title>
    <url>/202003139306/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个二叉树，计算<strong>整个树</strong>的坡度。</p>
<p>一个树的<strong>节点的坡度</strong>定义即为，该节点左子树的结点之和和右子树结点之和的<strong>差的绝对值</strong>。空结点的的坡度是0。</p>
<p><strong>整个树</strong>的坡度就是其所有节点的坡度之和。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">         1</span><br><span class="line">       &#x2F;   \</span><br><span class="line">      2     3</span><br><span class="line">输出: 1</span><br><span class="line">解释: </span><br><span class="line">结点的坡度 2 : 0</span><br><span class="line">结点的坡度 3 : 0</span><br><span class="line">结点的坡度 1 : |2-3| &#x3D; 1</span><br><span class="line">树的坡度 : 0 + 0 + 1 &#x3D; 1</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ol>
<li>任何子树的结点的和不会超过32位整数的范围。</li>
<li>坡度的值不会超过32位整数的范围。</li>
</ol>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><p>此题与<a href="https://www.wangtaocs.top/2020/03/12/543.二叉树的直径">543.二叉树的直径</a>的思路非常相似</p>
<ol>
<li>使用递归，求得左右子树的节点之和，该节点的坡度即为左右子树的节点之和的差的绝对值，整棵树的坡度即为所有节点的坡度和</li>
</ol>
<p><strong>注意：</strong></p>
<ol>
<li>子树的节点和还包括根节点。</li>
<li>无孩子的结点的的坡度是0。</li>
</ol>
<h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumOfTree</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    <span class="keyword">int</span> l = sumOfTree(root-&gt;left, sum);</span><br><span class="line">    <span class="keyword">int</span> r = sumOfTree(root-&gt;right, sum);</span><br><span class="line">    *sum += <span class="built_in">abs</span>(l - r);</span><br><span class="line">    <span class="keyword">return</span> l + r + root-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findTilt</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span> || (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    sumOfTree(root, &amp;res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>recursion</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>572.另一个树的子树</title>
    <url>/2020031335055/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定两个非空二叉树 <strong>s</strong> 和 <strong>t</strong>，检验 <strong>s</strong> 中是否包含和 <strong>t</strong> 具有相同结构和节点值的子树。<strong>s</strong> 的一个子树包括 <strong>s</strong> 的一个节点和这个节点的所有子孙。<strong>s</strong> 也可以看做它自身的一棵子树。</p>
<p><strong>示例 1:</strong><br>给定的树 s:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   5</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure>
<p>给定的树 t：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  4 </span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure>
<p>返回 <strong>true</strong>，因为 t 与 s 的一个子树拥有相同的结构和节点值。</p>
<p><strong>示例 2:</strong><br>给定的树 s：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   5</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br><span class="line">   &#x2F;</span><br><span class="line">  0</span><br></pre></td></tr></table></figure>
<p>给定的树 t：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  4</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure>
<p>返回 <strong>false</strong>。</p>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><ol>
<li><p>什么叫子树？</p>
<p>答：树B是树A的子集。即A与B相等；或B是A的左子树或右子树的子树。</p>
</li>
</ol>
<h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(struct TreeNode *s, struct TreeNode *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span> &amp;&amp; t == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> (s &amp;&amp; t) &amp;&amp; s-&gt;val == t-&gt;val &amp;&amp; isSame(s-&gt;left, t-&gt;left) &amp;&amp; isSame(s-&gt;right, t-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(struct TreeNode *s, struct TreeNode *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span> &amp;&amp; t == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span> &amp;&amp; t != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSame(s, t) || isSubtree(s-&gt;left, t) || isSubtree(s-&gt;right, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>530.二叉搜索树的最小绝对差</title>
    <url>/2020031232248/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     3</span><br><span class="line">    &#x2F;</span><br><span class="line">   2</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>树中至少有 2 个节点。</li>
<li>本题与 783 <a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/">https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/</a> 相同</li>
</ul>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-中序遍历-数组遍历"><a href="#1-中序遍历-数组遍历" class="headerlink" title="1.中序遍历+数组遍历"></a>1.中序遍历+数组遍历</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><ol>
<li>使用中序遍历二叉搜索树，得到一个不严格的递增序列</li>
<li>遍历这个递增序列，找到最小差值</li>
</ol>
<h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 10000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[maxSize];</span><br><span class="line">    <span class="keyword">int</span> arrTop = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">stack</span>[<span class="title">maxSize</span>], *<span class="title">p</span> =</span> root;</span><br><span class="line">    <span class="keyword">int</span> stackTop = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (stackTop != <span class="number">-1</span> || p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">stack</span>[++stackTop] = p;</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        p = <span class="built_in">stack</span>[stackTop--];</span><br><span class="line">        arr[++arrTop] = p-&gt;val;</span><br><span class="line">        p = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = arr[<span class="number">1</span>] - arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= arrTop; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i] - arr[i - <span class="number">1</span>];</span><br><span class="line">        res = res &gt; temp ? temp : res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然和783题一样，那就顺便做了，嘿嘿嘿😄</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>543.二叉树的直径</title>
    <url>/2020031261814/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。</p>
<p><strong>示例 :</strong><br>给定二叉树</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line"> &#x2F; \     </span><br><span class="line">4   5    </span><br></pre></td></tr></table></figure>
<p>返回 <strong>3</strong>, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p>
<p><strong>注意：</strong>两结点之间的路径长度是以它们之间边的数目表示。</p>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><ol>
<li><p>使用递归，求得左右子树的最大深度，直径即为左右子树的最大深度之和，由此得到了第一版代码：</p>
<p>遇到测试用例：<strong>[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]</strong></p>
</li>
</ol>
<p><img src="https://i.loli.net/2020/03/12/Dex32TKBlkfazpQ.png" alt="Snipaste_2020-03-12_22-21-10.png"> </p>
<ol>
<li>由此测试用例意识到，二叉树的直径是：在递归的过程中，左右子树的最大深度之和的<strong>最大值</strong>，由此得到第二版代码：</li>
</ol>
<h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4><p>第一版：</p>
   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> l = maxDepth(root-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> r = maxDepth(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> (l &gt; r ? l : r) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> maxDepth(root-&gt;left) + maxDepth(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第二版：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> l = maxDepth(root-&gt;left, res);</span><br><span class="line">    <span class="keyword">int</span> r = maxDepth(root-&gt;right, res);</span><br><span class="line">    *res = *res &lt; (l + r) ? (l + r) : *res;</span><br><span class="line">    <span class="keyword">return</span> (l &gt; r ? l : r) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span> || (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    maxDepth(root, &amp;res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>recursion</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>226.反转二叉树</title>
    <url>/2020031118801/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>翻转一棵二叉树。</p>
<p><strong>示例：</strong></p>
<p>输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>
<p><strong>备注:</strong><br>这个问题是受到 <a href="https://twitter.com/mxcl">Max Howell </a>的 <a href="https://twitter.com/mxcl/status/608682016205344768">原问题</a> 启发的 ：</p>
<blockquote>
<p>谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</p>
</blockquote>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><ol>
<li>声明一个辅助指针用于交换当前节点的左右孩子</li>
<li>递归反转左右孩子的孩子节点</li>
</ol>
<h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode *<span class="title">invertTree</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">p</span>;</span></span><br><span class="line">    p = root-&gt;left;</span><br><span class="line">    root-&gt;left = root-&gt;right;</span><br><span class="line">    root-&gt;right = p;</span><br><span class="line">    invertTree(root-&gt;left);</span><br><span class="line">    invertTree(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>235.二叉搜索树的最近公共祖先</title>
    <url>/2020031131088/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><a href="https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<p>例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]</p>
<p><img src="https://i.loli.net/2020/03/11/p6gGR9iUweEfkbL.png" alt="binarysearchtree_improved.png"></p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li>
</ul>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><p>利用<strong>二叉搜索树</strong>的性质</p>
<p>当p和q的值都小于根结点时，就去左树中找；</p>
<p>当p和q的值都大于根结点时，就去右树中找；</p>
<p>否则，返回根节点。</p>
<h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct TreeNode *<span class="title">lowestCommonAncestor</span><span class="params">(struct TreeNode *root, struct TreeNode *p, struct TreeNode *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>404.左叶子之和</title>
    <url>/2020031127616/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>计算给定二叉树的所有左叶子之和。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</span><br></pre></td></tr></table></figure>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><p>什么叫左叶子？</p>
<p>答：左孩子节点不为空且左孩子没有孩子节点。</p>
<p>递归判断左右子树，返回所有左叶子之和。</p>
<h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//左叶子：</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">        res += root-&gt;left-&gt;val;</span><br><span class="line">    <span class="keyword">return</span> res + sumOfLeftLeaves(root-&gt;left) + sumOfLeftLeaves(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>437.路径总和 III</title>
    <url>/2020031136949/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个二叉树，它的每个结点都存放着一个整数值。</p>
<p>找出路径和等于给定数值的路径总数。</p>
<p>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<p>二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1], sum &#x3D; 8</span><br><span class="line"></span><br><span class="line">      10</span><br><span class="line">     &#x2F;  \</span><br><span class="line">    5   -3</span><br><span class="line">   &#x2F; \    \</span><br><span class="line">  3   2   11</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">3  -2   1</span><br><span class="line"></span><br><span class="line">返回 3。和等于 8 的路径有:</span><br><span class="line"></span><br><span class="line">1.  5 -&gt; 3</span><br><span class="line">2.  5 -&gt; 2 -&gt; 1</span><br><span class="line">3.  -3 -&gt; 11</span><br></pre></td></tr></table></figure>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-双重递归"><a href="#1-双重递归" class="headerlink" title="1.双重递归"></a>1.双重递归</h3><blockquote>
<p>完全参考leetcode用户<a href="https://leetcode-cn.com/u/feng-huo-qian-qin-lu/">烽火前秦路</a>的题解</p>
</blockquote>
<p>使用两层递归：</p>
<p>第一层：</p>
<ul>
<li>help()函数：遍历从顶点开始和为sum的路径数</li>
</ul>
<p>第二层：</p>
<ul>
<li>pathSum()函数：通过调用help()函数，遍历根节点，并递归遍历左右子树中所有和为sum的路径数</li>
</ul>
<h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">help</span><span class="params">(struct TreeNode *p, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;val == sum)</span><br><span class="line">        res++;</span><br><span class="line">    res += help(p-&gt;left, sum - p-&gt;val);</span><br><span class="line">    res += help(p-&gt;right, sum - p-&gt;val);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = help(root, sum);</span><br><span class="line">    <span class="keyword">return</span> cnt + pathSum(root-&gt;left, sum) + pathSum(root-&gt;right, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>101.对称二叉树</title>
    <url>/2020031046824/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>
<p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>如果你可以运用递归和迭代两种方法解决这个问题，会很加分。</p>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><p>什么是对称二叉树：</p>
<ol>
<li>根节点的左右孩子相等</li>
<li>左孩子的左子树 == 右孩子的右子树 &amp;&amp; 左孩子的右子树 == 右孩子的左子树</li>
<li>递归第二个条件</li>
</ol>
<h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">visit</span><span class="params">(struct TreeNode *nodel, struct TreeNode *noder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nodel == <span class="literal">NULL</span> &amp;&amp; noder == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (nodel == <span class="literal">NULL</span> || noder == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (nodel-&gt;val == noder-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> visit(nodel-&gt;left, noder-&gt;right) &amp;&amp; visit(nodel-&gt;right, noder-&gt;left);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> visit(root-&gt;left, root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>depth-first-search</tag>
        <tag>breadth-first-search</tag>
      </tags>
  </entry>
  <entry>
    <title>98.验证二叉搜索树</title>
    <url>/2020031019332/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<ul>
<li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li>
<li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-中序遍历（非递归）"><a href="#1-中序遍历（非递归）" class="headerlink" title="1.中序遍历（非递归）"></a>1.中序遍历（非递归）</h3><ul>
<li>使用中序遍历二叉树</li>
<li>用一个变量记录最小值</li>
<li>当指针p所指的值大于最小值时，更新最小值，否则返回false；</li>
</ul>
<h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 1000</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">stack</span>[<span class="title">maxSize</span>], *<span class="title">p</span> =</span> root;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//flag是为了处理 -2147483648</span></span><br><span class="line">    <span class="keyword">int</span> a = -__INT_MAX__ - <span class="number">1</span>, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (top != <span class="number">-1</span> || p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">stack</span>[++top] = p;</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        p = <span class="built_in">stack</span>[top--];</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val &gt; a || flag == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a = p-&gt;val;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        p = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>depth-first-search</tag>
      </tags>
  </entry>
  <entry>
    <title>96.不同的二叉搜索树</title>
    <url>/2020030955253/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个整数 <em>n</em>，求以 1 … <em>n</em> 为节点组成的二叉搜索树有多少种？</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">给定 n &#x3D; 3, 一共有 5 种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-应用卡塔兰数"><a href="#1-应用卡塔兰数" class="headerlink" title="1. 应用卡塔兰数"></a>1. 应用<a href="https://baike.baidu.com/item/catalan/7605685?fr=aladdin">卡塔兰数</a></h3><ul>
<li><p>卡特兰数的通项式：<script type="math/tex">A_{n}=\frac{1}{n+1} C_{2 n}^{n}=C_{2 n}^{n}-C_{2 n}^{n-1}</script></p>
</li>
<li><p>卡特兰数的递推式：<script type="math/tex">A_{n+1}=\sum_{i=0}^{n} a A_{i} A_{n-i}</script></p>
</li>
</ul>
<p>因为通项式中的数太大会造成，所以采用递推式进行计算</p>
<h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        res = res * <span class="number">2</span> * (<span class="number">2</span> * i + <span class="number">1</span>) / (i + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>dynamic-programming</tag>
      </tags>
  </entry>
  <entry>
    <title>621.任务调度器</title>
    <url>/2020030815003/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。</p>
<p>然而，两个<strong>相同种类</strong>的任务之间必须有长度为 <strong>n</strong> 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p>
<p>你需要计算完成所有任务所需要的<strong>最短时间</strong>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: tasks &#x3D; [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n &#x3D; 2</span><br><span class="line">输出: 8</span><br><span class="line">执行顺序: A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B.</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong></p>
<ol>
<li>任务的总个数为 [1, 10000]。</li>
<li>n 的取值范围为 [0, 100]。</li>
</ol>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>设计：完全参考了<a href="https://leetcode-cn.com/problems/task-scheduler/solution/ren-wu-diao-du-qi-by-leetcode/">官解的方法三</a></li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><p><del>我不是很理解，这里就把官解贴在这里吧</del>🙃</p>
<blockquote>
<p>在前两种方法中，我们了解到应当尽早安排出现次数较多的任务。我们假设 A 为出现次数最多的任务，假设其出现了 p 次，考虑到冷却时间，那么执行完所有任务的时间至少为 (p - 1) <em> (n + 1) + 1。我们把这个过程形象化地用图 1 表现出，可以发现，CPU 产生了 (p - 1) </em> n 个空闲时间，只有 p 个时间是在工作的。</p>
<p><img src="https://i.loli.net/2020/03/08/VHNaA2oPFLmXRIZ.png" alt="621_Task_Scheduler_new.png"></p>
<p>因此我们应当考虑把剩余的任务安排到这些空闲时间里，我们仍然按照这些任务的出现次序，从大到小进行安排，会有下面三种情况：</p>
<ul>
<li><p>某个任务和 A 出现的次数相同，例如图 2 中的任务 B。此时我们只能让 B 占据 p - 1 个空闲时间，而在非空闲时间里额外安排一个时间给 B 执行；</p>
</li>
<li><p>某个任务比 A 出现的次数少 1，例如图 2 中的任务 C。此时我们可以让 C 占据 p - 1 个空闲时间，就可以全部执行完；</p>
</li>
<li><p>某个任务比 A 出现的次数少 2 或更多，例如图 2 中的任务 D。此时我们可以按照列优先的顺序，将 D 填入空闲时间中。因为 D 出现的次数少于 p - 1，因此无论从哪个位置开始按照列优先的顺序放置，都可以保证相邻的两个 D 之间满足冷却时间的要求。</p>
</li>
</ul>
<p>在将所有的任务安排完成后，如果仍然有剩余的空闲时间，那么答案即为（任务的总数 + 剩余的空闲时间）；如果在安排某一个任务时，遇到了剩余的空闲时间不够的情况，那么答案一定就等于任务的总数。这是因为我们可以将空闲时间增加虚拟的一列，继续安排任务。如果不考虑这些虚拟的列，在原本空闲时间对应的那些列中的任务是可以按照要求顺序执行的，而增加了这些虚拟的列后，两个相邻的相同任务的间隔不可能减少，并且虚拟的列中的任务也满足冷却时间的要求，因此仍然顺序执行并跳过虚拟的列中剩余的“空闲时间”一定是可行的。</p>
</blockquote>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">int</span> *)a - *(<span class="keyword">int</span> *)b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="keyword">char</span> *tasks, <span class="keyword">int</span> tasksSize, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">map</span>, <span class="number">0</span>, <span class="number">26</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasksSize; i++)</span><br><span class="line">        <span class="built_in">map</span>[tasks[i] - <span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">    qsort(<span class="built_in">map</span>, <span class="number">26</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), cmp);</span><br><span class="line">    <span class="keyword">int</span> max_val = <span class="built_in">map</span>[<span class="number">25</span>] - <span class="number">1</span>, idle_slots = max_val * n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">24</span>; i &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">map</span>[i] &gt; <span class="number">0</span>; i--)</span><br><span class="line">        idle_slots -= min(<span class="built_in">map</span>[i], max_val);</span><br><span class="line">    <span class="keyword">return</span> idle_slots &gt; <span class="number">0</span> ? idle_slots + tasksSize : tasksSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>design</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title>641.设计循环双端队列</title>
    <url>/2020030855960/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>设计实现双端队列。<br>你的实现需要支持以下操作：</p>
<ul>
<li>MyCircularDeque(k)：构造函数,双端队列的大小为k。</li>
<li>insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true。</li>
<li>insertLast()：将一个元素添加到双端队列尾部。如果操作成功返回 true。</li>
<li>deleteFront()：从双端队列头部删除一个元素。 如果操作成功返回 true。</li>
<li>deleteLast()：从双端队列尾部删除一个元素。如果操作成功返回 true。</li>
<li>getFront()：从双端队列头部获得一个元素。如果双端队列为空，返回 -1。</li>
<li>getRear()：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1。</li>
<li>isEmpty()：检查双端队列是否为空。</li>
<li>isFull()：检查双端队列是否满了。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyCircularDeque circularDeque &#x3D; new MycircularDeque(3); &#x2F;&#x2F; 设置容量大小为3</span><br><span class="line">circularDeque.insertLast(1);			        &#x2F;&#x2F; 返回 true</span><br><span class="line">circularDeque.insertLast(2);			        &#x2F;&#x2F; 返回 true</span><br><span class="line">circularDeque.insertFront(3);			        &#x2F;&#x2F; 返回 true</span><br><span class="line">circularDeque.insertFront(4);			        &#x2F;&#x2F; 已经满了，返回 false</span><br><span class="line">circularDeque.getRear();  				&#x2F;&#x2F; 返回 2</span><br><span class="line">circularDeque.isFull();				        &#x2F;&#x2F; 返回 true</span><br><span class="line">circularDeque.deleteLast();			        &#x2F;&#x2F; 返回 true</span><br><span class="line">circularDeque.insertFront(4);			        &#x2F;&#x2F; 返回 true</span><br><span class="line">circularDeque.getFront();				&#x2F;&#x2F; 返回 4</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>所有值的范围为 [1, 1000]</li>
<li>操作次数的范围为 [1, 1000]</li>
<li>请不要使用内置的双端队列库。</li>
</ul>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>队列</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol>
<li>注意循环队列要对队列长度取余</li>
<li>多申请一个空间用于判断队列是否已满</li>
</ol>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125; MyCircularDeque;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. Set the size of the deque to be k. */</span></span><br><span class="line"></span><br><span class="line"><span class="function">MyCircularDeque *<span class="title">myCircularDequeCreate</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyCircularDeque *obj = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyCircularDeque) * (k + <span class="number">1</span>));</span><br><span class="line">    obj-&gt;data = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (k + <span class="number">1</span>));</span><br><span class="line">    obj-&gt;front = <span class="number">0</span>;</span><br><span class="line">    obj-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    obj-&gt;length = k + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数声明，才能调用</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCircularDequeIsFull</span><span class="params">(MyCircularDeque *obj)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCircularDequeIsEmpty</span><span class="params">(MyCircularDeque *obj)</span></span>;</span><br><span class="line"><span class="comment">/** Adds an item at the front of Deque. Return true if the operation is successful. */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCircularDequeInsertFront</span><span class="params">(MyCircularDeque *obj, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (myCircularDequeIsFull(obj))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = (obj-&gt;front + obj-&gt;length - <span class="number">1</span>) % obj-&gt;length;</span><br><span class="line">    obj-&gt;data[pos] = value;</span><br><span class="line">    obj-&gt;front = pos;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Adds an item at the rear of Deque. Return true if the operation is successful. */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCircularDequeInsertLast</span><span class="params">(MyCircularDeque *obj, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (myCircularDequeIsFull(obj))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    obj-&gt;data[obj-&gt;rear] = value;</span><br><span class="line">    obj-&gt;rear = (obj-&gt;rear + <span class="number">1</span>) % obj-&gt;length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Deletes an item from the front of Deque. Return true if the operation is successful. */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCircularDequeDeleteFront</span><span class="params">(MyCircularDeque *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (myCircularDequeIsEmpty(obj))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    obj-&gt;front = (obj-&gt;front + <span class="number">1</span>) % obj-&gt;length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Deletes an item from the rear of Deque. Return true if the operation is successful. */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCircularDequeDeleteLast</span><span class="params">(MyCircularDeque *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (myCircularDequeIsEmpty(obj))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    obj-&gt;rear = (obj-&gt;rear - <span class="number">1</span> + obj-&gt;length) % obj-&gt;length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get the front item from the deque. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myCircularDequeGetFront</span><span class="params">(MyCircularDeque *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (myCircularDequeIsEmpty(obj))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;data[obj-&gt;front];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get the last item from the deque. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myCircularDequeGetRear</span><span class="params">(MyCircularDeque *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (myCircularDequeIsEmpty(obj))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = (obj-&gt;rear + obj-&gt;length - <span class="number">1</span>) % obj-&gt;length;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;data[pos];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Checks whether the circular deque is empty or not. */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCircularDequeIsEmpty</span><span class="params">(MyCircularDeque *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;front == obj-&gt;rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Checks whether the circular deque is full or not. */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCircularDequeIsFull</span><span class="params">(MyCircularDeque *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;front == (obj-&gt;rear + <span class="number">1</span>) % obj-&gt;length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myCircularDequeFree</span><span class="params">(MyCircularDeque *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyCircularDeque struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyCircularDeque* obj = myCircularDequeCreate(k);</span></span><br><span class="line"><span class="comment"> * bool param_1 = myCircularDequeInsertFront(obj, value);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * bool param_2 = myCircularDequeInsertLast(obj, value);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * bool param_3 = myCircularDequeDeleteFront(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * bool param_4 = myCircularDequeDeleteLast(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_5 = myCircularDequeGetFront(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_6 = myCircularDequeGetRear(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * bool param_7 = myCircularDequeIsEmpty(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * bool param_8 = myCircularDequeIsFull(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * myCircularDequeFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>design</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title>933.最近的请求次数</title>
    <url>/2020030819288/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>写一个 <code>RecentCounter</code> 类来计算最近的请求。</p>
<p>它只有一个方法：<code>ping(int t)</code>，其中 <code>t</code> 代表以毫秒为单位的某个时间。</p>
<p>返回从 3000 毫秒前到现在的 <code>ping</code> 数。</p>
<p>任何处于 <code>[t - 3000, t]</code> 时间范围之内的 <code>ping</code> 都将会被计算在内，包括当前（指 <code>t</code> 时刻）的 <code>ping</code>。</p>
<p>保证每次对 <code>ping</code> 的调用都使用比之前更大的 <code>t</code> 值。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：inputs &#x3D; [&quot;RecentCounter&quot;,&quot;ping&quot;,&quot;ping&quot;,&quot;ping&quot;,&quot;ping&quot;], inputs &#x3D; [[],[1],[100],[3001],[3002]]</span><br><span class="line">输出：[null,1,2,3,3] </span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li>每个测试用例最多调用 <code>10000</code> 次 <code>ping</code>。</li>
<li>每个测试用例会使用严格递增的 <code>t</code> 值来调用 <code>ping</code>。</li>
<li>每次调用 <code>ping</code> 都有 <code>1 &lt;= t &lt;= 10^9</code>。</li>
</ol>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>队列</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol>
<li>扫描数组，逐一进队</li>
<li>当队头元素 &lt; 队尾元素时，出队</li>
<li>返回当前队伍长度</li>
</ol>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 100000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *<span class="built_in">queue</span>;</span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line"></span><br><span class="line">&#125; RecentCounter;</span><br><span class="line"></span><br><span class="line"><span class="function">RecentCounter *<span class="title">recentCounterCreate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RecentCounter *rt = (RecentCounter *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(RecentCounter));</span><br><span class="line">    rt-&gt;<span class="built_in">queue</span> = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(maxSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">memset</span>(rt-&gt;<span class="built_in">queue</span>, <span class="number">-1</span>, maxSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    rt-&gt;front = <span class="number">0</span>;</span><br><span class="line">    rt-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recentCounterPing</span><span class="params">(RecentCounter *obj, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj-&gt;rear = (obj-&gt;rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">    obj-&gt;<span class="built_in">queue</span>[obj-&gt;rear] = t;</span><br><span class="line">    <span class="keyword">while</span> (obj-&gt;<span class="built_in">queue</span>[obj-&gt;front + <span class="number">1</span>] &lt; t - <span class="number">3000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        obj-&gt;front = (obj-&gt;front + <span class="number">1</span>) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;rear - obj-&gt;front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recentCounterFree</span><span class="params">(RecentCounter *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(obj-&gt;<span class="built_in">queue</span>);</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RecentCounter struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RecentCounter* obj = recentCounterCreate();</span></span><br><span class="line"><span class="comment"> * int param_1 = recentCounterPing(obj, t);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * recentCounterFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title>1017.负二进制转换</title>
    <url>/2020030519586/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给出数字 <code>N</code>，返回由若干 <code>&quot;0&quot;</code> 和 <code>&quot;1&quot;</code>组成的字符串，该字符串为 <code>N</code> 的<strong>负二进制（<code>base -2</code>）</strong>表示。</p>
<p>除非字符串就是 <code>&quot;0&quot;</code>，否则返回的字符串中不能含有前导零。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：2</span><br><span class="line">输出：&quot;110&quot;</span><br><span class="line">解释：(-2) ^ 2 + (-2) ^ 1 &#x3D; 2</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：&quot;111&quot;</span><br><span class="line">解释：(-2) ^ 2 + (-2) ^ 1 + (-2) ^ 0 &#x3D; 3</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：4</span><br><span class="line">输出：&quot;100&quot;</span><br><span class="line">解释：(-2) ^ 2 &#x3D; 4</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>0 &lt;= N &lt;= 10^9</code></li>
</ol>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>栈+二进制转化的变形</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><p>这道题是<strong>负二进制转换</strong></p>
<p>我们先回忆一下二进制转换：</p>
<ol>
<li>对给定的整数<strong>N</strong>进行短除，将余数压入栈中，</li>
<li>当最后除数为一时，停止短除，并将最后的一压入栈中，</li>
<li>最后将栈反转过来即可。</li>
</ol>
<p>参考这一过程，我们可以基本捋清楚负二进制转换的过程：</p>
<ol>
<li>对给定的整数<strong>N</strong>进行短除，将余数压入栈中，但是，我们会发现：余数可能为<strong>-1</strong>，所以我们对这个余数进行特殊处理，令其为一，此时的<code>N = (N - 1) / -2</code></li>
<li>二三步不变</li>
</ol>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize __INT16_MAX__</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">baseNeg2</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span>[maxSize];</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (N != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mod = N % <span class="number">-2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mod &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mod = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">stack</span>[++top] = mod;</span><br><span class="line">            N = (N - <span class="number">1</span>) / <span class="number">-2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">stack</span>[++top] = mod;</span><br><span class="line">            N = N / <span class="number">-2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stack</span>[++top] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *res = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(maxSize * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (top != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res[i++] = <span class="built_in">stack</span>[top--] + <span class="string">&#x27;0&#x27;</span>;<span class="comment">//将数字转换为字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    res[i++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>dynamic-programming</tag>
        <tag>stack</tag>
        <tag>ordered-map</tag>
      </tags>
  </entry>
  <entry>
    <title>739.每日温度</title>
    <url>/2020030521712/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>根据每日 <code>气温</code> 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 <code>0</code> 来代替。</p>
<p>例如，给定一个列表 <code>temperatures = [73, 74, 75, 71, 69, 72, 76, 73]</code>，你的输出应该是 <code>[1, 1, 4, 2, 1, 1, 0, 0]</code>。</p>
<p><strong>提示：</strong><code>气温</code> 列表长度的范围是 <code>[1, 30000]</code>。每个气温的值的均为华氏度，都是在 <code>[30, 100]</code> 范围内的整数。</p>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>暴力法：循环遍历，不再赘述</li>
<li>栈</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><p>这道题使用栈的解法：参考<a href="https://leetcode-cn.com/u/jalan/">江不知</a>的评论</p>
<ol>
<li>声明一个<strong>存放索引</strong>的辅助栈</li>
<li>先将<code>T[0]</code>压入栈中</li>
<li>从<code>T[1]</code>开始遍历<ol>
<li>当辅助栈不为空时，辅助栈中的索引对应的元素小于待入栈元素时，令<code>res[栈顶索引] = i - 栈顶索引</code>，并出栈</li>
<li>否则，辅助栈中的索引对应的元素大于待入栈元素，入栈即可</li>
</ol>
</li>
<li>当辅助栈不为空时，说明：之后都不会升高，在该位置用 <code>0</code> 来代替。</li>
</ol>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">dailyTemperatures</span><span class="params">(<span class="keyword">int</span> *T, <span class="keyword">int</span> TSize, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *res = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(TSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span>[TSize];</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>[++top] = i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; TSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (top != <span class="number">-1</span> &amp;&amp; T[<span class="built_in">stack</span>[top]] &lt; T[i])</span><br><span class="line">        &#123;</span><br><span class="line">            res[<span class="built_in">stack</span>[top]] = i - <span class="built_in">stack</span>[top];</span><br><span class="line">            top--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">stack</span>[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (top != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res[<span class="built_in">stack</span>[top]] = <span class="number">0</span>;</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = TSize;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个解法就很巧妙了，时空复杂度为O(n)，比暴力法要好一点，然而我只想到了暴力法……</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hash-table</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>456.132模式</title>
    <url>/2020030452735/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个整数序列：a1, a2, …, an，一个132模式的子序列 a<strong>i</strong>, a<strong>j</strong>, a<strong>k</strong> 被定义为：当 <strong>i</strong> &lt; <strong>j</strong> &lt; <strong>k</strong> 时，a<strong>i</strong> &lt; a<strong>k</strong> &lt; a<strong>j</strong>。设计一个算法，当给定有 n 个数字的序列时，验证这个序列中是否含有132模式的子序列。</p>
<p><strong>注意：</strong>n 的值小于15000。</p>
<p><strong>示例1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">输出: False</span><br><span class="line"></span><br><span class="line">解释: 序列中不存在132模式的子序列。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3, 1, 4, 2]</span><br><span class="line"></span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">解释: 序列中有 1 个132模式的子序列： [1, 4, 2].</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [-1, 3, 2, 0]</span><br><span class="line"></span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">解释: 序列中有 3 个132模式的的子序列: [-1, 3, 2], [-1, 3, 0] 和 [-1, 2, 0].</span><br></pre></td></tr></table></figure>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>栈的应用</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><p>参考<a href="https://leetcode-cn.com/problems/132-pattern/solution/132mo-shi-by-leetcode-2/">官解</a></p>
<ol>
<li>为了便于分析，我们约定：<ul>
<li>“1”：小</li>
<li>“3”：大</li>
<li>“2”：中</li>
</ul>
</li>
<li>首先考虑<code>小 &lt; 大</code>的情况，我们可以维护一个前缀最小值的数组<code>min[]</code>，这样，<code>小 &lt; 大</code>便是最优解</li>
<li>其次考虑<code>大 &gt; 中</code>的情况，我们需要申请一个栈，从后向前遍历数组，<ol>
<li>当<code>nums[j] &gt; min[j]</code>时，将<code>nums[j]</code>进栈</li>
<li>如果栈不为空，并且<code>nums[j] &gt; stack[top]</code>时，我们就找到了我们需要的<code>中</code>，返回<code>true</code>；</li>
<li>如果栈不为空，但是<code>min[j] &gt;= stack[top]</code>时，我们就需要一直出栈，直到找到我们所需要的<code>中</code></li>
</ol>
</li>
<li>如果遍历完整个数组，都没有找到，则返回<code>false</code></li>
</ol>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find132pattern</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize &lt; <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//min[]</span></span><br><span class="line">    <span class="keyword">int</span> min[numsSize];</span><br><span class="line">    min[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; numsSize; i++)</span><br><span class="line">        min[i] = min[i - <span class="number">1</span>] &lt; nums[i] ? min[i - <span class="number">1</span>] : nums[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span>[numsSize];</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = numsSize - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &gt; min[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (top != <span class="number">-1</span> &amp;&amp; min[j] &gt;= <span class="built_in">stack</span>[top])</span><br><span class="line">                top--;</span><br><span class="line">            <span class="keyword">if</span> (top != <span class="number">-1</span> &amp;&amp; nums[j] &gt; <span class="built_in">stack</span>[top])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">stack</span>[++top] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>503.下一个更大元素 II</title>
    <url>/2020030431329/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,1]</span><br><span class="line">输出: [2,-1,2]</span><br><span class="line">解释: 第一个 1 的下一个更大的数是 2；</span><br><span class="line">数字 2 找不到下一个更大的数； </span><br><span class="line">第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong> 输入数组的长度不会超过 10000。</p>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>for循环遍历</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><p>和其第一题一样，我还是没有使用stack</p>
<ol>
<li>构造一个可以：不管从什么位置开始，都可以遍历整个数组的for循环</li>
<li>使用循环嵌套遍历整个数组</li>
<li>能找到下一个更大的数，则赋值；否则，令其值为 -1</li>
</ol>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">nextGreaterElements</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> *res = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(numsSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = (i + <span class="number">1</span>) % numsSize; j != i; j = (j + <span class="number">1</span>) % numsSize)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                res[(*returnSize)++] = nums[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res[i] != nums[j])</span><br><span class="line">            res[(*returnSize)++] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>331.验证二叉树的前序序列化</title>
    <url>/2020030311311/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 <code>#</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     _9_</span><br><span class="line">    &#x2F;   \</span><br><span class="line">   3     2</span><br><span class="line">  &#x2F; \   &#x2F; \</span><br><span class="line"> 4   1  #  6</span><br><span class="line">&#x2F; \ &#x2F; \   &#x2F; \</span><br><span class="line"># # # #   # #</span><br></pre></td></tr></table></figure>
<p>例如，上面的二叉树可以被序列化为字符串 <code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code>，其中 <code>#</code> 代表一个空节点。</p>
<p>给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。</p>
<p>每个以逗号分隔的字符或为一个整数或为一个表示 <code>null</code> 指针的 <code>&#39;#&#39;</code> 。</p>
<p>你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 <code>&quot;1,,3&quot;</code> 。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;1,#&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;9,#,#,1&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>栈、字符串切割</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol>
<li>将字符串以<code>,</code>切割</li>
<li>将子字符串逐一进栈</li>
<li>当栈顶元素与次栈顶元素都为<code>#</code>时，连出三次栈，并将<code>#</code>压入栈中</li>
<li>在遍历字符串的过程中，如果栈恰好为空，且<strong>子字符串为空</strong>时，说明符合要求，返回true；</li>
<li>在遍历字符串的过程中，如果栈恰好为空，且<strong>子字符串不为空</strong>时，说明不符合要求，返回false；</li>
</ol>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 1024</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *data[maxSize];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125; <span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidSerialization</span><span class="params">(<span class="keyword">char</span> *preorder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preorder[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; preorder[<span class="number">1</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (preorder[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; preorder[<span class="number">1</span>] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">stack</span> *st = (<span class="built_in">stack</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">stack</span>));</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; maxSize; i++)</span><br><span class="line">        st-&gt;data[i] = <span class="literal">NULL</span>;</span><br><span class="line">    st-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//切割字符串</span></span><br><span class="line">    <span class="keyword">char</span> *str = preorder;</span><br><span class="line">    <span class="keyword">char</span> delim[<span class="number">2</span>] = <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> *token = <span class="literal">NULL</span>;</span><br><span class="line">    token = strtok(str, delim);</span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="keyword">char</span> ship[<span class="number">2</span>] = <span class="string">&quot;#&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (token != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        st-&gt;data[++st-&gt;top] = token;</span><br><span class="line">        token = strtok(<span class="literal">NULL</span>, delim);</span><br><span class="line">        <span class="keyword">while</span> (st-&gt;data[st-&gt;top][<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; st-&gt;data[st-&gt;top - <span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            st-&gt;data[st-&gt;top--] = <span class="literal">NULL</span>;</span><br><span class="line">            st-&gt;data[st-&gt;top--] = <span class="literal">NULL</span>;</span><br><span class="line">            st-&gt;data[st-&gt;top--] = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span> (st-&gt;top == <span class="number">-1</span> &amp;&amp; token != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (st-&gt;top == <span class="number">-1</span> &amp;&amp; token == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            st-&gt;data[++st-&gt;top] = ship;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>144.二叉树的前序遍历</title>
    <url>/2020030224235/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，返回它的 <em>前序</em> 遍历。</p>
<p> <strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [1,2,3]</span><br></pre></td></tr></table></figure>
<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><ul>
<li>递归</li>
<li>迭代</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这里主要说一下迭代法：</p>
<ol>
<li>先序遍历的顺序：根节点 -&gt; 左孩子 -&gt; 右孩子</li>
<li>首先需要声明一个辅助栈，</li>
<li>先访问根节点，并将其val存到数组中</li>
<li>接下来该访问左孩子，由于栈是<strong>FILO</strong>，所以遍历时要先让右孩子入栈，才能让左孩子先出栈</li>
<li>循环这个过程，直至遍历全部节点</li>
</ol>
<h3 id="C代码"><a href="#C代码" class="headerlink" title="C代码"></a>C代码</h3><ol>
<li><p>递归</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *arr, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[(*returnSize)++] = root-&gt;val;</span><br><span class="line">        visit(root-&gt;left, arr, returnSize);</span><br><span class="line">        visit(root-&gt;right, arr, returnSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">preorderTraversal</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">1000</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    visit(root, arr, returnSize);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 1000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">preorderTraversal</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(maxSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">stack</span>[<span class="title">maxSize</span>], *<span class="title">p</span> =</span> root;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">stack</span>[++top] = p;</span><br><span class="line">    <span class="keyword">while</span> (top != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = <span class="built_in">stack</span>[top--];</span><br><span class="line">        arr[(*returnSize)++] = p-&gt;val;</span><br><span class="line">        <span class="comment">//stack is FILO,so the preOrder push the rchild into the stack first</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">stack</span>[++top] = p-&gt;right;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">stack</span>[++top] = p-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            res.append(root.val)</span><br><span class="line">            helper(root.left)</span><br><span class="line">            helper(root.right)</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>145.二叉树的后序遍历</title>
    <url>/2020030262169/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，返回它的 <em>后序</em> 遍历。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [3,2,1]</span><br></pre></td></tr></table></figure>
<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><ul>
<li>递归</li>
<li>迭代</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这里主要说一下迭代法：</p>
<ol>
<li>先序遍历的顺序：左孩子 -&gt; 右孩子 -&gt; 根节点；</li>
<li>我们可以与先序遍历对比一下：<ul>
<li>先序遍历的顺序：根节点 -&gt; 左孩子 -&gt; 右孩子</li>
<li>先序遍历的顺序：左孩子 -&gt; 右孩子 -&gt; 根节点</li>
</ul>
</li>
<li>我们可以发现：<strong>后序遍历是先序遍历的逆序序列</strong>，利用这一性质，我们进行后续遍历操作</li>
<li>这里我们需要两个辅助栈</li>
<li>首先，我们按照先序遍历的方式遍历整颗二叉树，并将遍历结果存入栈1中；</li>
<li>然后，再将栈1中的结果全部出栈，并存入数组中即可。</li>
</ol>
<h3 id="C代码"><a href="#C代码" class="headerlink" title="C代码"></a>C代码</h3><ol>
<li><p>递归</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *arr, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root)</span><br><span class="line">    &#123;</span><br><span class="line">        visit(root-&gt;left, arr, returnSize);</span><br><span class="line">        arr[(*returnSize)++] = root-&gt;val;</span><br><span class="line">        visit(root-&gt;right, arr, returnSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">inorderTraversal</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">1000</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    visit(root, arr, returnSize);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 1000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">postorderTraversal</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(maxSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">Stack1</span>[<span class="title">maxSize</span>];</span></span><br><span class="line">    <span class="keyword">int</span> top1 = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">Stack2</span>[<span class="title">maxSize</span>];</span></span><br><span class="line">    <span class="keyword">int</span> top2 = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    Stack1[++top1] = root;</span><br><span class="line">    <span class="keyword">while</span> (top1 != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = Stack1[top1--];</span><br><span class="line">        Stack2[++top2] = p;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            Stack1[++top1] = p-&gt;left;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            Stack1[++top1] = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//the stack2 push is the postOrderNonRecursion</span></span><br><span class="line">    <span class="keyword">while</span> (top2 != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = Stack2[top2--];</span><br><span class="line">        arr[(*returnSize)++] = p-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            helper(root.left)</span><br><span class="line">            helper(root.right)</span><br><span class="line">            res.append(root.val)</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>150.逆波兰表达式求值</title>
    <url>/2020030212598/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>根据<a href="https://baike.baidu.com/item/逆波兰式/128437">逆波兰表示法</a>，求表达式的值。</p>
<p>有效的运算符包括 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>
<p><strong>说明：</strong></p>
<ul>
<li>整数除法只保留整数部分。</li>
<li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]</span><br><span class="line">输出: 9</span><br><span class="line">解释: ((2 + 1) * 3) &#x3D; 9</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;&#x2F;&quot;, &quot;+&quot;]</span><br><span class="line">输出: 6</span><br><span class="line">解释: (4 + (13 &#x2F; 5)) &#x3D; 6</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;&#x2F;&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]</span><br><span class="line">输出: 22</span><br><span class="line">解释: </span><br><span class="line">  ((10 * (6 &#x2F; ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">&#x3D; ((10 * (6 &#x2F; (12 * -11))) + 17) + 5</span><br><span class="line">&#x3D; ((10 * (6 &#x2F; -132)) + 17) + 5</span><br><span class="line">&#x3D; ((10 * 0) + 17) + 5</span><br><span class="line">&#x3D; (0 + 17) + 5</span><br><span class="line">&#x3D; 17 + 5</span><br><span class="line">&#x3D; 22</span><br></pre></td></tr></table></figure>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>栈的简单应用</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol>
<li>注意将字符串负数转化为整数类型时，注意特殊处理</li>
<li>遇到操作符时，连出两次栈，并将计算结果入栈</li>
<li>否则，遇到字符串数字，转化为整数类型后，入栈</li>
<li>最后栈顶元素即为结果</li>
</ol>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125; <span class="built_in">stack</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stoi</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="built_in">strlen</span>(str); i++)</span><br><span class="line">            res = res * <span class="number">10</span> + (str[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> - res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); i++)</span><br><span class="line">        res = res * <span class="number">10</span> + (str[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="keyword">char</span> **tokens, <span class="keyword">int</span> tokensSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span> *st = (<span class="built_in">stack</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">stack</span>));</span><br><span class="line">    st-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(tokensSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    st-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tokensSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tokens[i][<span class="number">0</span>] == <span class="string">&#x27;+&#x27;</span> &amp;&amp; tokens[i][<span class="number">1</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            b = st-&gt;data[st-&gt;top--];</span><br><span class="line">            a = st-&gt;data[st-&gt;top--];</span><br><span class="line">            st-&gt;data[++st-&gt;top] = a + b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tokens[i][<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span> &amp;&amp; tokens[i][<span class="number">1</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            b = st-&gt;data[st-&gt;top--];</span><br><span class="line">            a = st-&gt;data[st-&gt;top--];</span><br><span class="line">            st-&gt;data[++st-&gt;top] = a - b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tokens[i][<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; tokens[i][<span class="number">1</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            b = st-&gt;data[st-&gt;top--];</span><br><span class="line">            a = st-&gt;data[st-&gt;top--];</span><br><span class="line">            st-&gt;data[++st-&gt;top] = a * b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tokens[i][<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span> &amp;&amp; tokens[i][<span class="number">1</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            b = st-&gt;data[st-&gt;top--];</span><br><span class="line">            a = st-&gt;data[st-&gt;top--];</span><br><span class="line">            st-&gt;data[++st-&gt;top] = a / b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            st-&gt;data[++st-&gt;top] = stoi(tokens[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st-&gt;data[st-&gt;top];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码有点复杂了，将就着看😜</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>173.二叉搜索树迭代器</title>
    <url>/2020030230537/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。</p>
<p>调用 <code>next()</code> 将返回二叉搜索树中的下一个最小的数。</p>
<p><strong>示例：</strong></p>
<p><img src="https://i.loli.net/2020/03/02/Zj1g8fKkXOe4PLD.png" alt="bst-tree.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BSTIterator iterator &#x3D; new BSTIterator(root);</span><br><span class="line">iterator.next();    &#x2F;&#x2F; 返回 3</span><br><span class="line">iterator.next();    &#x2F;&#x2F; 返回 7</span><br><span class="line">iterator.hasNext(); &#x2F;&#x2F; 返回 true</span><br><span class="line">iterator.next();    &#x2F;&#x2F; 返回 9</span><br><span class="line">iterator.hasNext(); &#x2F;&#x2F; 返回 true</span><br><span class="line">iterator.next();    &#x2F;&#x2F; 返回 15</span><br><span class="line">iterator.hasNext(); &#x2F;&#x2F; 返回 true</span><br><span class="line">iterator.next();    &#x2F;&#x2F; 返回 20</span><br><span class="line">iterator.hasNext(); &#x2F;&#x2F; 返回 false</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>next()</code> 和 <code>hasNext()</code> 操作的时间复杂度是 O(1)，并使用 O(<em>h</em>) 内存，其中 <em>h</em> 是树的高度。</li>
<li>你可以假设 <code>next()</code> 调用总是有效的，也就是说，当调用 <code>next()</code> 时，BST 中至少存在一个下一个最小的数。</li>
</ul>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>二叉搜索树的遍历问题、二叉树的中序遍历</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol>
<li>将给定的二叉搜索树进行中序遍历，可以得到一个升序数组</li>
<li>遍历数组即可。</li>
</ol>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize __INT16_MAX__</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">&#125; BSTIterator;</span><br><span class="line"></span><br><span class="line"><span class="function">BSTIterator *<span class="title">bSTIteratorCreate</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    BSTIterator *bsti = (BSTIterator *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTIterator));</span><br><span class="line">    bsti-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(maxSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    bsti-&gt;top = <span class="number">0</span>;</span><br><span class="line">    bsti-&gt;index = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">p</span> =</span> root, *<span class="built_in">stack</span>[maxSize];</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (top != <span class="number">-1</span> || p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">stack</span>[++top] = p;</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        p = <span class="built_in">stack</span>[top--];</span><br><span class="line">        bsti-&gt;data[bsti-&gt;top++] = p-&gt;val;</span><br><span class="line">        p = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bsti;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** @return the next smallest number */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bSTIteratorNext</span><span class="params">(BSTIterator *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;data[obj-&gt;index++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** @return whether we have a next smallest number */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bSTIteratorHasNext</span><span class="params">(BSTIterator *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;index &lt; obj-&gt;top)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bSTIteratorFree</span><span class="params">(BSTIterator *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BSTIterator struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * BSTIterator* obj = bSTIteratorCreate(root);</span></span><br><span class="line"><span class="comment"> * int param_1 = bSTIteratorNext(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * bool param_2 = bSTIteratorHasNext(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * bSTIteratorFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>stack</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title>94.二叉树的中序遍历</title>
    <url>/202003025409/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，返回它的<em>中序</em> 遍历。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">输出: [1,3,2]</span><br></pre></td></tr></table></figure>
<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><ul>
<li>递归</li>
<li>迭代</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这里主要说一下迭代法：</p>
<ol>
<li>中序遍历的顺序：左孩子 -&gt; 根节点 -&gt; 右孩子</li>
<li>首先需要声明一个辅助栈，</li>
<li>先访问左孩子，由于这是一个类似递归的过程，所以要一直沿着左孩子的方向一直向左下遍历，并将节点压入栈中；</li>
<li>找到整颗二叉树中最左下的孩子后，将其val存到数组中</li>
<li>接下来该访问根节点，继续出栈，即可得到根节点</li>
<li>然后在访问根节点的右孩子</li>
<li>循环这个过程，直至遍历全部节点</li>
</ol>
<h3 id="C代码"><a href="#C代码" class="headerlink" title="C代码"></a>C代码</h3><ol>
<li><p>递归</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *arr, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root)&#123;</span><br><span class="line">        visit(root-&gt;left, arr, returnSize);</span><br><span class="line">        arr[(*returnSize)++] = root-&gt;val;</span><br><span class="line">        visit(root-&gt;right, arr, returnSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">inorderTraversal</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">1000</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    visit(root, arr, returnSize);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 1000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">inorderTraversal</span><span class="params">(struct TreeNode* root, <span class="keyword">int</span>* returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span>* arr = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(maxSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">stack</span>[<span class="title">maxSize</span>], *<span class="title">p</span> =</span> root;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//the Stack may be empty in the process,</span></span><br><span class="line">    <span class="comment">//so the condition that p != NULL can keep the loop continue</span></span><br><span class="line">    <span class="keyword">while</span> (top != <span class="number">-1</span> || p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">stack</span>[++top] = p;</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        p = <span class="built_in">stack</span>[top--];</span><br><span class="line">        arr[(*returnSize)++] = p-&gt;val;</span><br><span class="line">        p = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            helper(root.left)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            helper(root.right)</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>不知道为什么辅助函数写到函数外边就不可以，是力扣官方的编译器问题吗？奇奇怪怪🙃</p>
</li>
</ol>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言递归的那点事</title>
    <url>/2020030112979/</url>
    <content><![CDATA[<h1 id="浅析递归"><a href="#浅析递归" class="headerlink" title="浅析递归"></a>浅析递归</h1><p>​    递归是一种绝大多数语言都支持的编程方式。但是我本人并不建议使用。</p>
<h2 id="1-是什么？"><a href="#1-是什么？" class="headerlink" title="1.是什么？"></a>1.是什么？</h2><h3 id="1-1-释义"><a href="#1-1-释义" class="headerlink" title="1.1 释义"></a>1.1 释义</h3><p>​    允许函数循环调用自己的过程</p>
<h3 id="1-2-原理"><a href="#1-2-原理" class="headerlink" title="1.2 原理"></a>1.2 原理</h3><ol>
<li>每级函数调用都有自己的变量</li>
<li>每次函数调用都会返回一次</li>
<li>递归函数中位于递归调用之前的语句顺序执行</li>
<li>递归函数中位于递归调用之后的语句逆序执行</li>
<li>每级递归都有自己的变量，但并不会拷贝函数代码</li>
<li><strong>递归函数必须有让递归调用停止的语句，否则将无限递归</strong></li>
</ol>
<h2 id="2-为什么？"><a href="#2-为什么？" class="headerlink" title="2.为什么？"></a>2.为什么？</h2><h3 id="2-1-优点"><a href="#2-1-优点" class="headerlink" title="2.1 优点"></a>2.1 优点</h3><p>​    递归的代码简洁优雅。繁杂的执行过程交由操作系统辅助解决。</p>
<h3 id="2-2-缺点"><a href="#2-2-缺点" class="headerlink" title="2.2 缺点"></a>2.2 缺点</h3><p>​    相较于其优点，缺点更加显而易见，由于函数每次递归调用自己时，操作系统都要为其保留函数的运行现场（俗称系统栈），这种系统级的开销会浪费较多的资源，因而代码的效率并不高。而且还不方便人们的阅读，难以理解。</p>
<h2 id="3-怎么做？"><a href="#3-怎么做？" class="headerlink" title="3.怎么做？"></a>3.怎么做？</h2><p>Talk is cheap,show you the code.</p>
<h3 id="3-1-普通递归"><a href="#3-1-普通递归" class="headerlink" title="3.1 普通递归"></a>3.1 普通递归</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    ——《C Primer Plus》p595</span></span><br><span class="line"><span class="comment">    函数执行过程：</span></span><br><span class="line"><span class="comment">    1.主函数调用up_and_down(), 并传递参数 1 ;</span></span><br><span class="line"><span class="comment">    2.开始执行up_and_down(), 接受参数 1 ;</span></span><br><span class="line"><span class="comment">    3.(#1)输出参数 n == 1 , 以及参数 n == 1 的地址</span></span><br><span class="line"><span class="comment">    4.进行if判断, n == 1 &lt; 4, 再次调用up_and_down(), 并传递参数 2,与此同时，保留函数第一次执行的运行现场;</span></span><br><span class="line"><span class="comment">    5.进行第一次递归:</span></span><br><span class="line"><span class="comment">        1.(#1)输出参数 n == 2 , 以及参数 n == 2 的地址</span></span><br><span class="line"><span class="comment">        2.进行if判断, n == 2 &lt; 4, 再次调用up_and_down(), 并传递参数 3,与此同时，保留函数第二次执行的运行现场;</span></span><br><span class="line"><span class="comment">        3.进行第二次递归:</span></span><br><span class="line"><span class="comment">            1.(#1)输出参数 n == 3 , 以及参数 n == 3 的地址</span></span><br><span class="line"><span class="comment">            2.进行if判断, n == 3 &lt; 4, 再次调用up_and_down(), 并传递参数 4,与此同时，保留函数第三次执行的运行现场;</span></span><br><span class="line"><span class="comment">            3.进行第三次递归:</span></span><br><span class="line"><span class="comment">                1.(#1)输出参数 n == 4 , 以及参数 n == 4 的地址</span></span><br><span class="line"><span class="comment">                2.进行if判断, n == 4 &lt; 4, 不满足if条件，不执行if内的语句</span></span><br><span class="line"><span class="comment">                3.(#2)输出参数 n == 4 , 以及参数 n == 4 的地址</span></span><br><span class="line"><span class="comment">            4.回归第三次的执行现场</span></span><br><span class="line"><span class="comment">            5.(#2)输出参数 n == 3 , 以及参数 n == 3 的地址</span></span><br><span class="line"><span class="comment">        4.回归第二次的执行现场</span></span><br><span class="line"><span class="comment">        5.(#2)输出参数 n == 2 , 以及参数 n == 2 的地址</span></span><br><span class="line"><span class="comment">    4.回归第一次的执行现场</span></span><br><span class="line"><span class="comment">    5.(#2)输出参数 n == 1 , 以及参数 n == 1 的地址</span></span><br><span class="line"><span class="comment">    6.up_and_down()执行完毕, 回归main()</span></span><br><span class="line"><span class="comment">    7.return 0.</span></span><br><span class="line"><span class="comment">    8.main()执行完毕</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up_and_down</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    up_and_down(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up_and_down</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Level %d: n location %p\n&quot;</span>, n, &amp;n); <span class="comment">//#1</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">4</span>)</span><br><span class="line">        up_and_down(n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;LEVEL %d: n location %p\n&quot;</span>, n, &amp;n); <span class="comment">//#2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-尾递归"><a href="#3-2-尾递归" class="headerlink" title="3.2 尾递归"></a>3.2 尾递归</h3><p>递归调用在主函数的return语句之前。尾递归形式简单，相当于循环。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">rfact</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This program calculates factorials.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a value in the range 0-12 (q to quit):\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No negative numbers, please.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; <span class="number">12</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Keep input under 13.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recursion: %d factorial = %ld\n&quot;</span>, num, fact(num));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recursion: %d factorial = %ld\n&quot;</span>, num, rfact(num));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter a value in the range 0-12 (q to quit):\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Bye.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> ans;</span><br><span class="line">    <span class="keyword">for</span> (ans = <span class="number">1</span>; n &gt; <span class="number">1</span>; n--)</span><br><span class="line">    &#123;</span><br><span class="line">        ans *= n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">rfact</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> ans;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">        ans = n * rfact(n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>71.简化路径</title>
    <url>/2020030133986/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>以 Unix 风格给出一个文件的<strong>绝对路径</strong>，你需要简化它。或者换句话说，将其转换为规范路径。</p>
<p>在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：<a href="https://blog.csdn.net/u011327334/article/details/50355600">Linux / Unix中的绝对路径 vs 相对路径</a></p>
<p>请注意，返回的规范路径必须始终以斜杠 <code>/</code> 开头，并且两个目录名之间必须只有一个斜杠 <code>/</code>。最后一个目录名（如果存在）<strong>不能</strong>以 <code>/</code> 结尾。此外，规范路径必须是表示绝对路径的<strong>最短</strong>字符串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;&#x2F;home&#x2F;&quot;</span><br><span class="line">输出：&quot;&#x2F;home&quot;</span><br><span class="line">解释：注意，最后一个目录名后面没有斜杠。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;&#x2F;..&#x2F;&quot;</span><br><span class="line">输出：&quot;&#x2F;&quot;</span><br><span class="line">解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;&#x2F;home&#x2F;&#x2F;foo&#x2F;&quot;</span><br><span class="line">输出：&quot;&#x2F;home&#x2F;foo&quot;</span><br><span class="line">解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;&#x2F;a&#x2F;.&#x2F;b&#x2F;..&#x2F;..&#x2F;c&#x2F;&quot;</span><br><span class="line">输出：&quot;&#x2F;c&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;&#x2F;a&#x2F;..&#x2F;..&#x2F;b&#x2F;..&#x2F;c&#x2F;&#x2F;.&#x2F;&#x2F;&quot;</span><br><span class="line">输出：&quot;&#x2F;c&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 6：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;&#x2F;a&#x2F;&#x2F;b&#x2F;&#x2F;&#x2F;&#x2F;c&#x2F;d&#x2F;&#x2F;.&#x2F;.&#x2F;&#x2F;..&quot;</span><br><span class="line">输出：&quot;&#x2F;a&#x2F;b&#x2F;c&quot;</span><br></pre></td></tr></table></figure>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><ul>
<li>字符串遍历、栈的应用</li>
<li>字符串切割、栈的应用</li>
</ul>
<h3 id="个人分析"><a href="#个人分析" class="headerlink" title="个人分析"></a>个人分析</h3><p>法一：</p>
<ol>
<li>逐个遍历字符串</li>
<li>遇到<code>.</code>不变</li>
<li>遇到<code>..</code>出栈</li>
<li>遇到<code>/</code>或其他字符时进栈</li>
</ol>
<p>​    这是我第一次想出来的算法，后来遇到了这个测试用例：<code>&quot;/...&quot;</code>,其期望答案居然还是：<code>&quot;/...&quot;</code>。靠，我太难了！😥看了题解之后，发现C语言也有字符串切割的函数，就在<code>string.h</code>这个库里，我心一横，换方法了！</p>
<p>法二：</p>
<ol>
<li>使用<code>strtok()</code>函数，将字符串进行切割</li>
<li>因为每次切割返回的都是指针，所以我声明了一个指针数组</li>
<li>将切割出的子字符串的指针压入指针数组中</li>
<li>然后遍历指针数组</li>
<li>组合出最终的字符串</li>
</ol>
<h3 id="C代码"><a href="#C代码" class="headerlink" title="C代码"></a>C代码</h3><p>法一：</p>
   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">simplifyPath</span><span class="params">(<span class="keyword">char</span> *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(path);</span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">stack</span> = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">stack</span>[++top] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (path[i] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; path[i + <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                top = top == <span class="number">0</span> ? <span class="number">0</span> : top - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (<span class="built_in">stack</span>[top] != <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (path[i] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (path[i] == <span class="string">&#x27;/&#x27;</span> &amp;&amp; <span class="built_in">stack</span>[top] == <span class="string">&#x27;/&#x27;</span>)<span class="comment">//防止连续的&#x27;/&#x27;</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">stack</span>[++top] = path[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span>[top] == <span class="string">&#x27;/&#x27;</span> &amp;&amp; top &gt; <span class="number">0</span>)</span><br><span class="line">        top--;</span><br><span class="line">    <span class="built_in">stack</span>[++top] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, <span class="built_in">stack</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>法二：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.按照 / 切割字符串</span></span><br><span class="line"><span class="comment">2.遇到 . continue</span></span><br><span class="line"><span class="comment">3.遇到 .. 出栈</span></span><br><span class="line"><span class="comment">4.遇到 字母 进栈，并且进一个 /</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 1024</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *data[maxSize];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125; <span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">simplifyPath</span><span class="params">(<span class="keyword">char</span> *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span> *st = (<span class="built_in">stack</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">stack</span>));</span><br><span class="line">    <span class="comment">//初始化指针数组，这点很重要</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">for</span> (u = <span class="number">0</span>; u &lt; maxSize; u++)</span><br><span class="line">        st-&gt;data[u] = <span class="literal">NULL</span>;</span><br><span class="line">    st-&gt;top = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *str = path;</span><br><span class="line">    <span class="keyword">char</span> delim[<span class="number">2</span>] = <span class="string">&quot;/&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> *token = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//切割字符串</span></span><br><span class="line">    token = strtok(str, delim);</span><br><span class="line">    st-&gt;data[++st-&gt;top] = delim;</span><br><span class="line">    <span class="comment">// . 无操作</span></span><br><span class="line">    <span class="comment">// .. 连出两次栈</span></span><br><span class="line">    <span class="keyword">while</span> (token != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (token[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; token[<span class="number">1</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (token[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; token[<span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; token[<span class="number">2</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> (st-&gt;top &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                st-&gt;data[st-&gt;top--] = <span class="literal">NULL</span>;</span><br><span class="line">                st-&gt;data[st-&gt;top--] = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                st-&gt;top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            st-&gt;data[++st-&gt;top] = token;</span><br><span class="line">            st-&gt;data[++st-&gt;top] = delim;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到下一个子字符串的指针</span></span><br><span class="line">        token = strtok(<span class="literal">NULL</span>, delim);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历指针数组所对应的字符串，将其组合成想要的字符串</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">char</span> *res = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(maxSize * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; st-&gt;data[i] != <span class="literal">NULL</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="built_in">strlen</span>(st-&gt;data[i]); j++)</span><br><span class="line">            res[++k] = st-&gt;data[i][j];</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>)</span><br><span class="line">        res[++k] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    res[k] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码写的稀烂，枯了😥</p>
<h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><blockquote>
<p><a href="https://leetcode-cn.com/u/anki_life/">anki_life</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">simplifyPath</span>(<span class="params">self, path: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> path.split(<span class="string">&#x27;/&#x27;</span>):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;..&#x27;</span>]:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">elif</span> i == <span class="string">&#x27;..&#x27;</span> <span class="keyword">and</span> stack:</span><br><span class="line">                stack.pop()</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/&quot;</span> + <span class="string">&quot;/&quot;</span>.join(stack)</span><br></pre></td></tr></table></figure>
<p>不是我写的，真™优美，凎！</p>
<h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><p>使用了新的库函数：<code>strtok()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strtok</span><span class="params">(<span class="keyword">char</span> *__restrict__ _Str, <span class="keyword">const</span> <span class="keyword">char</span> *__restrict__ _Delim)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>char *<strong>restrict</strong> _Str: 待切割的字符串</li>
<li>const char *<strong>restrict</strong> _Delim：包含分隔符的 C 字符串</li>
</ul>
<p>使用<code>strtok()</code>：</p>
<blockquote>
<p>菜鸟教程</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">char</span> str[<span class="number">80</span>] = <span class="string">&quot;This is - www.runoob.com - website&quot;</span>;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> s[<span class="number">2</span>] = <span class="string">&quot;-&quot;</span>;</span><br><span class="line">   <span class="keyword">char</span> *token;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 获取第一个子字符串 */</span></span><br><span class="line">   token = strtok(str, s);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 继续获取其他的子字符串 */</span></span><br><span class="line">   <span class="keyword">while</span>( token != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">      <span class="built_in">printf</span>( <span class="string">&quot;%s\n&quot;</span>, token );</span><br><span class="line">    </span><br><span class="line">      token = strtok(<span class="literal">NULL</span>, s);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>stack</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>496.下一个更大元素 I</title>
    <url>/2020022716162/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个<strong>没有重复元素</strong>的数组 <code>nums1</code> 和 <code>nums2</code> ，其中<code>nums1</code> 是 <code>nums2</code> 的子集。找到 <code>nums1</code> 中每个元素在 <code>nums2</code> 中的下一个比其大的值。</p>
<p><code>nums1</code> 中数字 <strong>x</strong> 的下一个更大元素是指 <strong>x</strong> 在 <code>nums2</code> 中对应位置的右边的第一个比 <strong>x</strong> 大的元素。如果不存在，对应位置输出-1。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2].</span><br><span class="line">输出: [-1,3,-1]</span><br><span class="line">解释:</span><br><span class="line">    对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。</span><br><span class="line">    对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。</span><br><span class="line">    对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums1 &#x3D; [2,4], nums2 &#x3D; [1,2,3,4].</span><br><span class="line">输出: [3,-1]</span><br><span class="line">解释:</span><br><span class="line">    对于num1中的数字2，第二个数组中的下一个较大数字是3。</span><br><span class="line">    对于num1中的数字4，第二个数组中没有下一个更大的数字，因此输出 -1。</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ol>
<li><code>nums1</code>和<code>nums2</code>中所有元素是唯一的。</li>
<li><code>nums1</code>和<code>nums2</code> 的数组大小都不超过1000。</li>
</ol>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>官解：单调栈</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>个人解：for循环遍历</p>
<p>C语言没有栈和hashmap，所以我使用了for循环遍历</p>
<ol>
<li>在<code>nums2</code>中，找到<code>nums1</code>中的元素<code>nums2[j]</code></li>
<li>在<code>nums2</code>中找到<code>nums2[j]</code>后边更大的数</li>
</ol>
<h3 id="C代码"><a href="#C代码" class="headerlink" title="C代码"></a>C代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">nextGreaterElement</span><span class="params">(<span class="keyword">int</span>* nums1, <span class="keyword">int</span> nums1Size, <span class="keyword">int</span>* nums2, <span class="keyword">int</span> nums2Size, <span class="keyword">int</span>* returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *returnSize = nums1Size;</span><br><span class="line">    <span class="keyword">if</span> (nums1Size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span>* res = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(nums1Size * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nums1Size; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; nums2Size; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] == nums2[j]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (; j &lt; nums2Size; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums2[j] &gt; nums1[i]) &#123;</span><br><span class="line">                        res[i] = nums2[j];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span></span><br><span class="line">                        res[i] = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>单调栈：</p>
<ol>
<li>对num2中的每个元素求其右边第一个比它大的元素，并将结果存储在字典中；</li>
<li>以num1中元素为键，将字典中的值存储在res中返回。</li>
</ol>
<h4 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElement</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], nums2: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        stack = []</span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(stack) != <span class="number">0</span> <span class="keyword">and</span> num &gt; stack[-<span class="number">1</span>]:</span><br><span class="line">                dic[stack[-<span class="number">1</span>]] = num</span><br><span class="line">                stack.pop()</span><br><span class="line">            stack.append(num)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(stack) != <span class="number">0</span>:</span><br><span class="line">            dic[stack[-<span class="number">1</span>]] = -<span class="number">1</span></span><br><span class="line">            stack.pop()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums1:</span><br><span class="line">            res.append(dic[num])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>682.棒球比赛</title>
    <url>/2020022752952/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>你现在是棒球比赛记录员。<br>给定一个字符串列表，每个字符串可以是以下四种类型之一：</p>
<ol>
<li><code>整数</code>（一轮的得分）：直接表示您在本轮中获得的积分数。</li>
<li><code>&quot;+&quot;</code>（一轮的得分）：表示本轮获得的得分是前两轮<code>有效</code> 回合得分的总和。</li>
<li><code>&quot;D&quot;</code>（一轮的得分）：表示本轮获得的得分是前一轮<code>有效</code> 回合得分的两倍。</li>
<li><code>&quot;C&quot;</code>（一个操作，这不是一个回合的分数）：表示您获得的最后一个<code>有效</code> 回合的分数是无效的，应该被移除。</li>
</ol>
<p>每一轮的操作都是永久性的，可能会对前一轮和后一轮产生影响。<br>你需要返回你在所有回合中得分的总和。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [&quot;5&quot;,&quot;2&quot;,&quot;C&quot;,&quot;D&quot;,&quot;+&quot;]</span><br><span class="line">输出: 30</span><br><span class="line">解释: </span><br><span class="line">第1轮：你可以得到5分。总和是：5。</span><br><span class="line">第2轮：你可以得到2分。总和是：7。</span><br><span class="line">操作1：第2轮的数据无效。总和是：5。</span><br><span class="line">第3轮：你可以得到10分（第2轮的数据已被删除）。总数是：15。</span><br><span class="line">第4轮：你可以得到5 + 10 &#x3D; 15分。总数是：30。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [&quot;5&quot;,&quot;-2&quot;,&quot;4&quot;,&quot;C&quot;,&quot;D&quot;,&quot;9&quot;,&quot;+&quot;,&quot;+&quot;]</span><br><span class="line">输出: 27</span><br><span class="line">解释: </span><br><span class="line">第1轮：你可以得到5分。总和是：5。</span><br><span class="line">第2轮：你可以得到-2分。总数是：3。</span><br><span class="line">第3轮：你可以得到4分。总和是：7。</span><br><span class="line">操作1：第3轮的数据无效。总数是：3。</span><br><span class="line">第4轮：你可以得到-4分（第三轮的数据已被删除）。总和是：-1。</span><br><span class="line">第5轮：你可以得到9分。总数是：8。</span><br><span class="line">第6轮：你可以得到-4 + 9 &#x3D; 5分。总数是13。</span><br><span class="line">第7轮：你可以得到9 + 5 &#x3D; 14分。总数是27。</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>输入列表的大小将介于1和1000之间。</li>
<li>列表中的每个整数都将介于-30000和30000之间。</li>
</ul>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>遇到<strong>C</strong>：出栈</li>
<li>遇到<strong>D</strong>：栈顶元素*2，入栈</li>
<li>遇到<strong>+</strong>：栈顶两个元素求和，入栈</li>
<li>遇到数字：入栈</li>
<li>求栈中所有元素的和</li>
</ol>
<h3 id="C代码"><a href="#C代码" class="headerlink" title="C代码"></a>C代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calPoints</span><span class="params">(<span class="keyword">char</span> **ops, <span class="keyword">int</span> opsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span>[<span class="number">1000</span>], top = <span class="number">-1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; opsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (ops[i][<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">            top--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">            <span class="built_in">stack</span>[++top] = <span class="built_in">stack</span>[top] * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            <span class="built_in">stack</span>[++top] = <span class="built_in">stack</span>[top] + <span class="built_in">stack</span>[top - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">stack</span>[++top] = atoi(ops[i]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= top; i++)</span><br><span class="line">        res += <span class="built_in">stack</span>[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calPoints</span>(<span class="params">self, ops: List[<span class="built_in">str</span>]</span>) -&gt; int:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> op <span class="keyword">in</span> ops:</span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                score = <span class="built_in">int</span>(stack[-<span class="number">1</span>]) + <span class="built_in">int</span>(stack[-<span class="number">2</span>])</span><br><span class="line">                stack.append(score)</span><br><span class="line">            <span class="keyword">elif</span> op == <span class="string">&quot;D&quot;</span>:</span><br><span class="line">                stack.append(stack[-<span class="number">1</span>]*<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">elif</span> op == <span class="string">&quot;C&quot;</span>:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(<span class="built_in">int</span>(op))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(stack)</span><br></pre></td></tr></table></figure>
<h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><ol>
<li>int atoi(<strong>const char *_Str</strong>)：将String转化为int</li>
</ol>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>844.比较含退格的字符串</title>
    <url>/2020022747335/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定 <code>S</code> 和 <code>T</code> 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 <code>#</code> 代表退格字符。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：S &#x3D; &quot;ab#c&quot;, T &#x3D; &quot;ad#c&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “ac”。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：S &#x3D; &quot;ab##&quot;, T &#x3D; &quot;c#d#&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “”。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：S &#x3D; &quot;a##c&quot;, T &#x3D; &quot;#a#c&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “c”。</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：S &#x3D; &quot;a#c&quot;, T &#x3D; &quot;b&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：S 会变成 “c”，但 T 仍然是 “b”。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= S.length &lt;= 200</code></li>
<li><code>1 &lt;= T.length &lt;= 200</code></li>
<li><code>S</code> 和 <code>T</code> 只含有小写字母以及字符 <code>&#39;#&#39;</code>。</li>
</ol>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>分别将<code>S</code>和<code>T</code>入栈，遇到<code>#</code>出栈</li>
<li>比较两个栈内元素</li>
</ol>
<h3 id="C代码"><a href="#C代码" class="headerlink" title="C代码"></a>C代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">backspaceCompare</span><span class="params">(<span class="keyword">char</span> *S, <span class="keyword">char</span> *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">char</span> stack1[<span class="number">200</span>];<span class="keyword">int</span> top1 = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> stack2[<span class="number">200</span>];<span class="keyword">int</span> top2 = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(S); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (S[i] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">            top1 = top1 == <span class="number">-1</span> ? <span class="number">-1</span> : top1 - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            stack1[++top1] = S[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(T); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (T[i] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">            top2 = top2 == <span class="number">-1</span> ? <span class="number">-1</span> : top2 - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            stack2[++top2] = T[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (top1 != top2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt;= top1, j &lt;= top2; i++, j++)</span><br><span class="line">        <span class="keyword">if</span> (stack1[i] != stack2[j])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backspaceCompare</span>(<span class="params">self, S: <span class="built_in">str</span>, T: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        st1 = []</span><br><span class="line">        st2 = []</span><br><span class="line">        S = <span class="built_in">list</span>(S)</span><br><span class="line">        T = <span class="built_in">list</span>(T)</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> s == <span class="string">&quot;#&quot;</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(st1) != <span class="number">0</span>:</span><br><span class="line">                    st1.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                st1.append(s)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> T:</span><br><span class="line">            <span class="keyword">if</span> t == <span class="string">&quot;#&quot;</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(st2) != <span class="number">0</span>:</span><br><span class="line">                    st2.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                st2.append(t)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(st1) == <span class="built_in">str</span>(st2)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>142.环形链表 II</title>
    <url>/2020022628708/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p>
<p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。</p>
<p><strong>说明：</strong>不允许修改给定的链表。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">输出：tail connects to node index 1</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/26/ag8O41YDvkWQ3oz.png" alt="circularlinkedlist.png"></p>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2], pos &#x3D; 0</span><br><span class="line">输出：tail connects to node index 0</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/26/s1YK7UGb3pVNQw5.png" alt="circularlinkedlist_test2.png"></p>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1], pos &#x3D; -1</span><br><span class="line">输出：no cycle</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/26/unGX9L7f6Ura31d.png" alt="circularlinkedlist_test3.png"></p>
<p><strong>进阶：</strong><br>你是否可以不用额外空间解决此题？</p>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>双指针</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol>
<li><p>使用快慢双指针确认链表是否有环</p>
</li>
<li><p>如果有环，找到入环节点。</p>
<p>我有一点搞不太明白的就是，如果有环，那么最终慢指针停下的位置与入环节点的距离==头节点与入环节点的距离。利用这一性质，可以找到入环节点。</p>
</li>
</ol>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode *<span class="title">detectCycle</span><span class="params">(struct ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">fast</span> =</span> head, *slow = head;</span><br><span class="line">    <span class="keyword">int</span> hasCycle = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast)</span><br><span class="line">        &#123;</span><br><span class="line">            hasCycle = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasCycle)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (head != slow)</span><br><span class="line">        &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>155.最小栈</title>
    <url>/2020022620751/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<ul>
<li>push(x) — 将元素 x 推入栈中。</li>
<li>pop() — 删除栈顶的元素。</li>
<li>top() — 获取栈顶元素。</li>
<li>getMin() — 检索栈中的最小元素。</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>用数组模拟栈</p>
<h3 id="C代码"><a href="#C代码" class="headerlink" title="C代码"></a>C代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">10000</span>];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125; MinStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** initialize your data structure here. */</span></span><br><span class="line"></span><br><span class="line"><span class="function">MinStack *<span class="title">minStackCreate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MinStack *st = (MinStack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MinStack));</span><br><span class="line">    st-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> st;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minStackPush</span><span class="params">(MinStack *obj, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj-&gt;top++;</span><br><span class="line">    obj-&gt;data[obj-&gt;top] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minStackPop</span><span class="params">(MinStack *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj-&gt;top--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minStackTop</span><span class="params">(MinStack *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;top != <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> obj-&gt;data[obj-&gt;top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minStackGetMin</span><span class="params">(MinStack *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = obj-&gt;top;</span><br><span class="line">    <span class="keyword">int</span> min = obj-&gt;data[i];</span><br><span class="line">    <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        min = min &lt; obj-&gt;data[i] ? min : obj-&gt;data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minStackFree</span><span class="params">(MinStack *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>使用list模拟栈</p>
<h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.stack = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.stack.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(self.stack)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>stack</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title>225.用队列实现栈</title>
    <url>/202002263620/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>使用队列实现栈的下列操作：</p>
<ul>
<li>push(x) — 元素 x 入栈</li>
<li>pop() — 移除栈顶元素</li>
<li>top() — 获取栈顶元素</li>
<li>empty() — 返回栈是否为空</li>
</ul>
<p><strong>注意:</strong></p>
<ul>
<li>你只能使用队列的基本操作— 也就是 <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code>, 和 <code>is empty</code> 这些操作是合法的。</li>
<li>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li>
<li>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</li>
</ul>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>只操作尾指针就达到了栈的效果（其实不符合题意）</p>
<h3 id="C代码"><a href="#C代码" class="headerlink" title="C代码"></a>C代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">&#125; MyStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"></span><br><span class="line"><span class="function">MyStack *<span class="title">myStackCreate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyStack *st = (MyStack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyStack));</span><br><span class="line">    st-&gt;front = <span class="number">0</span>;</span><br><span class="line">    st-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> st;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Push element x onto stack. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myStackPush</span><span class="params">(MyStack *obj, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj-&gt;rear++;</span><br><span class="line">    obj-&gt;data[obj-&gt;rear] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myStackPop</span><span class="params">(MyStack *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = obj-&gt;data[obj-&gt;rear];</span><br><span class="line">    obj-&gt;rear--;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get the top element. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myStackTop</span><span class="params">(MyStack *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;data[obj-&gt;rear];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myStackEmpty</span><span class="params">(MyStack *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;front == obj-&gt;rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myStackFree</span><span class="params">(MyStack *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>使用list模拟栈</p>
<h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.stack = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Push element x onto stack.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.stack.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Removes the element on top of the stack and returns that element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get the top element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span>(<span class="params">self</span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns whether the stack is empty.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.stack) == <span class="number">0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>stack</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title>232.用栈实现队列</title>
    <url>/2020022644957/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>使用栈实现队列的下列操作：</p>
<ul>
<li>push(x) — 将一个元素放入队列的尾部。</li>
<li>pop() — 从队列首部移除元素。</li>
<li>peek() — 返回队列首部的元素。</li>
<li>empty() — 返回队列是否为空。</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyQueue queue &#x3D; new MyQueue();</span><br><span class="line"></span><br><span class="line">queue.push(1);</span><br><span class="line">queue.push(2);  </span><br><span class="line">queue.peek();  &#x2F;&#x2F; 返回 1</span><br><span class="line">queue.pop();   &#x2F;&#x2F; 返回 1</span><br><span class="line">queue.empty(); &#x2F;&#x2F; 返回 false</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ul>
<li>你只能使用标准的栈操作 — 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li>
<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li>
<li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</li>
</ul>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>辅助栈</p>
<ol>
<li>增加一个辅助栈st2</li>
<li>每次入栈时，先将st2中的元素压入st1，再将待入栈元素压入st2，最后将st1中的元素全部压入st2</li>
</ol>
<h3 id="C代码"><a href="#C代码" class="headerlink" title="C代码"></a>C代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data1[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> top1;</span><br><span class="line">    <span class="keyword">int</span> data2[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> top2;</span><br><span class="line">&#125; MyQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"></span><br><span class="line"><span class="function">MyQueue *<span class="title">myQueueCreate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyQueue *que = (MyQueue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyQueue));</span><br><span class="line">    que-&gt;top1 = <span class="number">-1</span>;</span><br><span class="line">    que-&gt;top2 = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> que;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myQueuePush</span><span class="params">(MyQueue *obj, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (obj-&gt;top2 != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        obj-&gt;data1[++obj-&gt;top1] = obj-&gt;data2[obj-&gt;top2--];</span><br><span class="line">    &#125;</span><br><span class="line">    obj-&gt;data2[++obj-&gt;top2] = x;</span><br><span class="line">    <span class="keyword">while</span> (obj-&gt;top1 != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        obj-&gt;data2[++obj-&gt;top2] = obj-&gt;data1[obj-&gt;top1--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myQueuePop</span><span class="params">(MyQueue *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = obj-&gt;data2[obj-&gt;top2];</span><br><span class="line">    obj-&gt;top2--;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get the front element. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myQueuePeek</span><span class="params">(MyQueue *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;data2[obj-&gt;top2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myQueueEmpty</span><span class="params">(MyQueue *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;top2 == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myQueueFree</span><span class="params">(MyQueue *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>用list模拟队列</p>
<h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.queue = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Push element x to the back of queue.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.queue.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Removes the element from in front of queue and returns that element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        val = self.queue[<span class="number">0</span>]</span><br><span class="line">        self.queue = self.queue[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get the front element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.queue[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span>(<span class="params">self</span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns whether the queue is empty.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.queue) == <span class="number">0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>stack</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title>143.重排链表</title>
    <url>/2020022040854/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个单链表 <em>L</em>：<em>L</em>0→<em>L</em>1→…→<em>L**n</em>-1→<em>L</em>n ，<br>将其重新排列后变为： <em>L</em>0→<em>L**n</em>→<em>L</em>1→<em>L**n</em>-1→<em>L</em>2→<em>L**n</em>-2→…</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ol>
<li>双指针+翻转链表</li>
<li>使用栈</li>
</ol>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><p>我使用的是法一：</p>
<ol>
<li>使用快慢双指针找到链表中点</li>
<li>将后半段链表翻转</li>
<li>拼接两个链表</li>
</ol>
<p>简述一下法二：</p>
<ol>
<li>先将所有节点进栈</li>
<li>边遍历，边出栈（出后半段就够了）</li>
</ol>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(struct ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next || !head-&gt;next-&gt;next)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//找到中点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">fast</span> =</span> head, *slow = head, *right;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    right = slow-&gt;next;</span><br><span class="line">    slow-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//翻转后半部分</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span> =</span> right, *q, *r;</span><br><span class="line">    r = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        q-&gt;next = r;</span><br><span class="line">        r = q;</span><br><span class="line">    &#125;</span><br><span class="line">    right = q;</span><br><span class="line">    <span class="comment">//遍历并连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">l1</span> =</span> head, *l2 = right, *l1next = head-&gt;next, *l2next = right-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (l2)</span><br><span class="line">    &#123;</span><br><span class="line">        l2-&gt;next = l1next;</span><br><span class="line">        l1-&gt;next = l2;</span><br><span class="line">        l1 = l1next;</span><br><span class="line">        l1next = l1next-&gt;next;</span><br><span class="line">        l2 = l2next;</span><br><span class="line">        <span class="keyword">if</span> (l2next)</span><br><span class="line">            l2next = l2next-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真是有史以来写的又臭又长的代码！</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>328.奇偶链表</title>
    <url>/2020022052539/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p>
<p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL </span><br><span class="line">输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ul>
<li>应当保持奇数节点和偶数节点的相对顺序。</li>
<li>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</li>
</ul>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>双指针</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol>
<li>使用奇偶双指针按序遍历，分别将奇序号节点和偶序号节点连接起来</li>
<li>将偶序号节点头拼接在奇序号节点后</li>
</ol>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode *<span class="title">oddEvenList</span><span class="params">(struct ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">odd</span> =</span> head, *even = head-&gt;next, *headOfEven = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (odd-&gt;next &amp;&amp; even-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        odd-&gt;next = even-&gt;next;</span><br><span class="line">        odd = odd-&gt;next;</span><br><span class="line">        even-&gt;next = odd-&gt;next;</span><br><span class="line">        even = even-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    odd-&gt;next = headOfEven;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这应该是我自己写出的最优美的代码了！</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>445.两数相加 II</title>
    <url>/2020022030492/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定两个<strong>非空</strong>链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储单个数字。将这两数相加会返回一个新的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
<p><strong>进阶:</strong></p>
<p>如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出: 7 -&gt; 8 -&gt; 0 -&gt; 7</span><br></pre></td></tr></table></figure>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>反转链表+逐位相加</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><p>这道题我本来还没思路，结果进阶说：不能翻转怎么办？</p>
<p>还能怎么办，我不进阶了，哈哈哈哈哈哈，快乐就完事了！😂</p>
<p>（直接把第2题和第206题的代码粘过来了）</p>
<p>直接：反转、反转，相加，反转</p>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode *<span class="title">reverseList</span><span class="params">(struct ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span>, *<span class="title">q</span>, *<span class="title">r</span>;</span></span><br><span class="line">    p = head;</span><br><span class="line">    r = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        q-&gt;next = r;</span><br><span class="line">        r = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode *<span class="title">addTwo</span><span class="params">(struct ListNode *l1, struct ListNode *l2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">l3</span> =</span> (struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">    l3-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span> =</span> l1, *q = l2, *r = l3;</span><br><span class="line">    <span class="keyword">int</span> a, b, c, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> || q != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a = p != <span class="literal">NULL</span> ? p-&gt;val : <span class="number">0</span>;</span><br><span class="line">        b = q != <span class="literal">NULL</span> ? q-&gt;val : <span class="number">0</span>;</span><br><span class="line">        c = (a + b + flag) % <span class="number">10</span>;</span><br><span class="line">        flag = (a + b + flag) / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        r-&gt;next = (struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">        r-&gt;val = c;</span><br><span class="line">        r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="literal">NULL</span>)</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">    &#123;</span><br><span class="line">        r-&gt;next = (struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">        r-&gt;val = <span class="number">1</span>;</span><br><span class="line">        r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l3-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">struct ListNode *<span class="title">addTwoNumbers</span><span class="params">(struct ListNode *l1, struct ListNode *l2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l1 = reverseList(l1);</span><br><span class="line">    l2 = reverseList(l2);</span><br><span class="line">    <span class="keyword">return</span> reverseList(addTwo(l1, l2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我太机智了，这是我AC最快的一次，哈哈哈哈哈哈哈！</p>
<p>先埋下这个坑，日后再来填！😝</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>61.旋转链表</title>
    <url>/2020021945490/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个链表，旋转链表，将链表每个节点向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k &#x3D; 2</span><br><span class="line">输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL</span><br><span class="line">向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 0-&gt;1-&gt;2-&gt;NULL, k &#x3D; 4</span><br><span class="line">输出: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class="line">向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL</span><br><span class="line">向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL</span><br><span class="line">向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>快慢双指针</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul>
<li><p>首先遍历链表，得到其长度，对<code>K</code>取余</p>
<p>然后使用快慢指针，先让快指针走<code>K</code>步，在让快慢指针一起走</p>
<p>然后将慢指针后边的链表放在链表头前边即可</p>
</li>
</ul>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode *<span class="title">rotateRight</span><span class="params">(struct ListNode *head, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span> =</span> head, *q;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        len++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    k = k % len;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">slow</span> =</span> head, *fast = head;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    q = slow-&gt;next;</span><br><span class="line">    slow-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    fast-&gt;next = head;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>82.删除排序链表中的重复元素 II</title>
    <url>/2020021918973/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 <em>没有重复出现</em> 的数字。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</span><br><span class="line">输出: 1-&gt;2-&gt;5</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;1-&gt;1-&gt;2-&gt;3</span><br><span class="line">输出: 2-&gt;3</span><br></pre></td></tr></table></figure>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>迭代法</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul>
<li><p>1.使用哨兵节点放置在头节点之前；</p>
<p>2.使用头指针开始遍历链表，用while循环找到不相同的值时，就删除值相同的节点</p>
<p>3.令pre指向head</p>
<p>4.循环迭代</p>
</li>
</ul>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode *<span class="title">deleteDuplicates</span><span class="params">(struct ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">prev</span> =</span> (struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">    prev-&gt;next = head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">pre</span> =</span> prev;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span> &amp;&amp; head-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = head-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;val == head-&gt;next-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (head-&gt;val == temp)</span><br><span class="line">            &#123;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">                <span class="keyword">if</span> (!head)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre-&gt;next = head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>86.分隔链表</title>
    <url>/2020021962780/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个链表和一个特定值 <em>x</em>，对链表进行分隔，使得所有小于 <em>x</em> 的节点都在大于或等于 <em>x</em> 的节点之前。</p>
<p>你应当保留两个分区中每个节点的初始相对位置。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: head &#x3D; 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x &#x3D; 3</span><br><span class="line">输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。</span><br><span class="line"></span><br><span class="line">你应当保留两个分区中每个节点的初始相对位置。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: head &#x3D; 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x &#x3D; 3</span><br><span class="line">输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</span><br></pre></td></tr></table></figure>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>迭代</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol>
<li>用head指针遍历链表，并申请两个节点；</li>
<li>比<code>x</code>大的节点接在smaller后边；比<code>x</code>小的节点接在bigger后边；</li>
<li>吧bigger接在smaller后边。</li>
</ol>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode *<span class="title">partition</span><span class="params">(struct ListNode *head, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">smaller</span> =</span> (struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">bigger</span> =</span> (struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span> =</span> smaller, *q = bigger;</span><br><span class="line">    <span class="keyword">while</span> (head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;val &lt; x)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next = head;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            q-&gt;next = head;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;next = bigger-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> smaller-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>92.反转链表 II</title>
    <url>/2020021958290/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>反转从位置 <em>m</em> 到 <em>n</em> 的链表。请使用一趟扫描完成反转。</p>
<p><strong>说明:</strong><br>1 ≤ <em>m</em> ≤ <em>n</em> ≤ 链表长度。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m &#x3D; 2, n &#x3D; 4</span><br><span class="line">输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>使用额外数组</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol>
<li>使用额外的数组将m~n的值存储起来</li>
<li>再将m~n的节点按照help数组的逆序覆盖</li>
</ol>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode *<span class="title">reverseBetween</span><span class="params">(struct ListNode *head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == n)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">int</span> len = n - m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, a = m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> *help = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span> =</span> head, *q;</span><br><span class="line">    <span class="keyword">while</span> (a)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        a--;</span><br><span class="line">    &#125;</span><br><span class="line">    q = p;</span><br><span class="line">    <span class="keyword">while</span> (m &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        help[i++] = p-&gt;val;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        m++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        q-&gt;val = help[i];</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>24.两两交换链表中的节点</title>
    <url>/2020021823378/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>迭代法</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul>
<li><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode *<span class="title">swapPairs</span><span class="params">(struct ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">prev</span> =</span> (struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">    prev-&gt;next = head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">pre</span> =</span> prev, *p = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (head &amp;&amp; head-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        pre-&gt;next = p;</span><br><span class="line">        head-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = head;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (!head)<span class="comment">//预防空指针</span></span><br><span class="line">            p = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>19.删除链表的倒数第N个节点</title>
    <url>/2020021719130/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个链表，删除链表的倒数第 <em>n</em> 个节点，并且返回链表的头结点。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n &#x3D; 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<p>给定的 <em>n</em> 保证是有效的。</p>
<p><strong>进阶：</strong></p>
<p>你能尝试使用一趟扫描实现吗？</p>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>双指针</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul>
<li>先让快指针跑n步；如果快指针为空，则说明删除头节点，然后快慢指针一起跑到末尾；</li>
</ul>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode *<span class="title">removeNthFromEnd</span><span class="params">(struct ListNode *head, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">fast</span> =</span> head, *slow = head, *q;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    q = slow-&gt;next;</span><br><span class="line">    slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>21.合并两个有序链表</title>
    <url>/2020021729474/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>迭代法</li>
<li>递归法</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul>
<li><p>我使用的是迭代法（参考官解）</p>
<p>首先，定义一个假头节点，便于将两个链表连接起来，并定义一个哨兵指针指向这个假头节点，方便我们返回最后得到的链表；</p>
<p>然后，开始遍历链表一和链表二，当链表一和链表二都不为空时，pre指针总是指向val较小的节点；</p>
<p>然后，pre指针始终指向所求的有序链表的最后一个节点；</p>
<p>最后，将链表一和链表二中仍然不为空的链表接在最后</p>
</li>
</ul>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode *<span class="title">mergeTwoLists</span><span class="params">(struct ListNode *l1, struct ListNode *l2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">pre</span> =</span> (struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">    pre-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">prev</span> =</span> pre;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = pre-&gt;next;<span class="comment">//pre指针始终指向所求的有序链表的最后一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    pre-&gt;next = l1 == <span class="literal">NULL</span> ? l2 : l1;</span><br><span class="line">    <span class="keyword">return</span> prev-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、PS"><a href="#三、PS" class="headerlink" title="三、PS"></a>三、PS</h2><p>递归法不是很理解，详细请参考👉<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode/">官方答案</a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>234.回文链表</title>
    <url>/2020021755897/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>请判断一个链表是否为回文链表。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>进阶：</strong><br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>遍历+双指针</li>
<li>快慢指针+翻转链表</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul>
<li><p>我使用的是第一种算法，首先，遍历整个链表，将所有元素存到数组中，然后使用头尾指针判断数组即可。</p>
<p>但是这种算法不是最优的，时空复杂度均为O(n)</p>
</li>
</ul>
<ul>
<li>第二种算法，首先使用快慢指针找到链表的中点（做过），再将后半段链表翻转，并与前半段链表比较即可。</li>
</ul>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(struct ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        len++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        data[m++] = p-&gt;val;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (data[i] == data[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>237.删除链表中的节点</title>
    <url>/2020021755666/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。</p>
<p>现有一个链表 — head = [4,5,1,9]，它可以表示为:</p>
<p><img src="https://i.loli.net/2020/02/17/v62DZVMGCynFS4J.png" alt="237_example.png"></p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: head &#x3D; [4,5,1,9], node &#x3D; 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: head &#x3D; [4,5,1,9], node &#x3D; 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ul>
<li>链表至少包含两个节点。</li>
<li>链表中所有节点的值都是唯一的。</li>
<li>给定的节点为非末尾节点并且一定是链表中的一个有效节点。</li>
<li>不要从你的函数中返回任何结果。</li>
</ul>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>节点赋值（C）</li>
<li>节点替换（java）</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><p>一开始我以为题出错了，没给链表咋删节点啊，看了讨论之后。嗯……还是自己太年轻了</p>
<ul>
<li>节点赋值：直接将<code>*（node-&gt;next）</code>赋值给<code>*node</code>，从而将原本的<code>*node</code>节点覆盖</li>
<li>节点替换：首先将node下一个节点的值赋值给node，再将node的下一个节点替换为node的下下个节点</li>
</ul>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><ul>
<li><p>C（这绝对是我写过最短的题解🤣）</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Definition for singly-linked list.</li>
<li>struct ListNode {</li>
<li>int val;</li>
<li>struct ListNode *next;</li>
<li><p>};<br><em>/<br>void deleteNode(struct ListNode </em>node)<br>{<br><em>node = </em>(node-&gt;next);<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>java</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        node.val = node.next.val;</span><br><span class="line">        node.next = node.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、PS"><a href="#三、PS" class="headerlink" title="三、PS"></a>三、PS</h2><p>​      我尝试过用java的方法，用C实现，但是我发现如果node是倒数第二个节点时，就会堆栈溢出，这肯定是<code>node.next = node.next.next;</code>这句代码出了问题。我觉得可能是官方给的数据最后一个节点的next没有置为<strong>NULL</strong>，导致指针在最后一个节点时，找不到他的下一个节点；而当我们自己写代码时，我认为始终令最后的一个节点的next置为<strong>NULL</strong>，这样才不会总是报错，这是一个良好的习惯。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>876.链表的中间结点</title>
    <url>/2020021736027/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个带有头结点 <code>head</code> 的非空单链表，返回链表的中间结点。</p>
<p>如果有两个中间结点，则返回第二个中间结点。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,4,5]</span><br><span class="line">输出：此列表中的结点 3 (序列化形式：[3,4,5])</span><br><span class="line">返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。</span><br><span class="line">注意，我们返回了一个 ListNode 类型的对象 ans，这样：</span><br><span class="line">ans.val &#x3D; 3, ans.next.val &#x3D; 4, ans.next.next.val &#x3D; 5, 以及 ans.next.next.next &#x3D; NULL.</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,4,5,6]</span><br><span class="line">输出：此列表中的结点 4 (序列化形式：[4,5,6])</span><br><span class="line">由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>给定链表的结点数介于 <code>1</code> 和 <code>100</code> 之间。</li>
</ul>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>双指针</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul>
<li>快慢双指针，快指针每次走两步，慢指针每次走一步</li>
</ul>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode *<span class="title">middleNode</span><span class="params">(struct ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">slow</span> =</span> head, *fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>908.最小差值 I</title>
    <url>/2020021736172/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个整数数组 <code>A</code>，对于每个整数 <code>A[i]</code>，我们可以选择任意 <code>x</code> 满足 <code>-K &lt;= x &lt;= K</code>，并将 <code>x</code> 加到 <code>A[i]</code> 中。</p>
<p>在此过程之后，我们得到一些数组 <code>B</code>。</p>
<p>返回 <code>B</code> 的最大值和 <code>B</code> 的最小值之间可能存在的最小差值。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [1], K &#x3D; 0</span><br><span class="line">输出：0</span><br><span class="line">解释：B &#x3D; [1]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [0,10], K &#x3D; 2</span><br><span class="line">输出：6</span><br><span class="line">解释：B &#x3D; [2,8]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [1,3,6], K &#x3D; 3</span><br><span class="line">输出：0</span><br><span class="line">解释：B &#x3D; [3,3,3] 或 B &#x3D; [4,4,4]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 10000</code></li>
<li><code>0 &lt;= A[i] &lt;= 10000</code></li>
<li><code>0 &lt;= K &lt;= 10000</code></li>
</ol>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>遍历数组</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul>
<li>找出数组中的最大值和最小值，所求的数应该是<code>(max - min) &gt; 2 * K ? max - min - 2 * K : 0;</code></li>
</ul>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">smallestRangeI</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> ASize, <span class="keyword">int</span> K)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = A[<span class="number">0</span>], max = A[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ASize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        min = A[i] &gt; min ? min : A[i];</span><br><span class="line">        max = A[i] &lt; max ? max : A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (max - min) &gt; <span class="number">2</span> * K ? max - min - <span class="number">2</span> * K : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、PS"><a href="#三、PS" class="headerlink" title="三、PS"></a>三、PS</h2><p>这里再多说两句：</p>
<p>首先，这道题描述的不是很清楚。</p>
<p>转述：给定一个整数<code>K</code>，使数组中的数加上<code>[-K, K]</code>的数后的差值最小。</p>
<p>后来我就想，这其实就是一道<strong>线性规划</strong>的题嘛。</p>
<p>比如说题目中的测试用例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [0,10], K &#x3D; 2</span><br><span class="line">输出：6</span><br><span class="line">解释：B &#x3D; [2,8]</span><br></pre></td></tr></table></figure>
<p>就是让散列点都向y=2靠近：</p>
<p><img src="https://i.loli.net/2020/02/17/H69UhgAYsLxq1WV.png" alt="3DC81E16CD0CEB3016C92FF18EC45BBE.png"></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>1009.十进制整数的反码</title>
    <url>/2020021636196/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>每个非负整数 <code>N</code> 都有其二进制表示。例如， <code>5</code> 可以被表示为二进制 <code>&quot;101&quot;</code>，<code>11</code> 可以用二进制 <code>&quot;1011&quot;</code> 表示，依此类推。注意，除 <code>N = 0</code> 外，任何二进制表示中都不含前导零。</p>
<p>二进制的反码表示是将每个 <code>1</code> 改为 <code>0</code> 且每个 <code>0</code> 变为 <code>1</code>。例如，二进制数 <code>&quot;101&quot;</code> 的二进制反码为 <code>&quot;010&quot;</code>。</p>
<p>给定十进制数 <code>N</code>，返回其二进制表示的反码所对应的十进制整数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：5</span><br><span class="line">输出：2</span><br><span class="line">解释：5 的二进制表示为 &quot;101&quot;，其二进制反码为 &quot;010&quot;，也就是十进制中的 2 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：7</span><br><span class="line">输出：0</span><br><span class="line">解释：7 的二进制表示为 &quot;111&quot;，其二进制反码为 &quot;000&quot;，也就是十进制中的 0 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：10</span><br><span class="line">输出：5</span><br><span class="line">解释：10 的二进制表示为 &quot;1010&quot;，其二进制反码为 &quot;0101&quot;，也就是十进制中的 5 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>0 &lt;= N &lt; 10^9</code></li>
</ol>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>位运算</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol>
<li><p>5 = “101”, 10 = “1010”</p>
</li>
<li><p>将”101”逐位取反：”101” ^ “111” = “010”</p>
<p>将”1010”逐位取反：”1010” ^ “1111” = “0101”</p>
</li>
<li><p>返回取反后的数字</p>
<p>主要就是怎么找这个：每一位都是1的数</p>
<p>使用while循环，当num&lt;N时，将num左移一位再加一</p>
</li>
</ol>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitwiseComplement</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//找每一位都是1的数</span></span><br><span class="line">    <span class="keyword">while</span> (num &lt; N)</span><br><span class="line">    &#123;</span><br><span class="line">        num = (num &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取反</span></span><br><span class="line">    <span class="keyword">return</span> N ^ num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、PS"><a href="#三、PS" class="headerlink" title="三、PS"></a>三、PS</h2><p>完全参考leetcode大佬：<a href="https://leetcode-cn.com/u/suspectx/">suspectX</a>的答案</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>bit-manipu</tag>
      </tags>
  </entry>
  <entry>
    <title>1013.将数组分成和相等的三个部分</title>
    <url>/2020021631411/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个整数数组 <code>A</code>，只有我们可以将其划分为三个和相等的非空部分时才返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p>形式上，如果我们可以找出索引 <code>i+1 &lt; j</code> 且满足 <code>(A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... + A[A.length - 1])</code> 就可以将数组三等分。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出：[0,2,1,-6,6,-7,9,1,2,0,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：0 + 2 + 1 &#x3D; -6 + 6 - 7 + 9 + 1 &#x3D; 2 + 0 + 1</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[0,2,1,-6,6,7,9,-1,2,0,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,3,6,5,-2,2,5,1,-9,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：3 + 3 &#x3D; 6 &#x3D; 5 - 2 + 2 + 5 + 1 - 9 + 4</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>3 &lt;= A.length &lt;= 50000</code></li>
<li><code>-10000 &lt;= A[i] &lt;= 10000</code></li>
</ol>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>双指针</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul>
<li>双指针向数组中间遍历，如果头尾指针遍历的累加都等于整个数组和的1/3，则判断头尾指针之间元素的累加是否等于数组的1/3即可</li>
</ul>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">summ</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; a &lt;= b; a++)</span><br><span class="line">        sum += A[a];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canThreePartsEqualSum</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> ASize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ASize; i++)</span><br><span class="line">        sum += A[i];</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">3</span> != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> oneThird = sum / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>, n = ASize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> qian = <span class="number">0</span>, hou = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (m &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (qian != oneThird)</span><br><span class="line">        &#123;</span><br><span class="line">            qian += A[m];</span><br><span class="line">            m++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (hou != oneThird)</span><br><span class="line">        &#123;</span><br><span class="line">            hou += A[n];</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (summ(A, m, n) == oneThird)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>1137.第 N 个泰波那契数</title>
    <url>/2020021617256/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>泰波那契序列 Tn 定义如下： </p>
<p>T0 = 0, T1 = 1, T2 = 1, 且在 n &gt;= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2</p>
<p>给你整数 <code>n</code>，请返回第 n 个泰波那契数 Tn 的值。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 4</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">T_3 &#x3D; 0 + 1 + 1 &#x3D; 2</span><br><span class="line">T_4 &#x3D; 1 + 1 + 2 &#x3D; 4</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 25</span><br><span class="line">输出：1389537</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= n &lt;= 37</code></li>
<li>答案保证是一个 32 位整数，即 <code>answer &lt;= 2^31 - 1</code>。</li>
</ul>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>递归</li>
<li>使用中间变量的递归（栈的思想）</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul>
<li>使用中间变量保存之前的值，进行递归（引申：二叉树的前中后序优先遍历，使用栈保存待递归的元素）</li>
</ul>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tribonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>, c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = a + b + c;</span><br><span class="line">        a = b;</span><br><span class="line">        b = c;</span><br><span class="line">        c = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">    <span class="comment">//直接递归会超时</span></span><br><span class="line">    <span class="comment">//return tribonacci(n - 1) + tribonacci(n - 2) + tribonacci(n - 3);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>2.两数相加</title>
    <url>/2020021624744/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给出两个 <strong>非空</strong> 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 <strong>一位</strong> 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 &#x3D; 807</span><br></pre></td></tr></table></figure>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul>
<li>定义两个指针，分别指向两个链表</li>
<li>每访问一个节点，申请一个新节点存放该位应该存放的值，并记录进位<code>flag</code></li>
<li>循环结束后，如果仍有进位，则在申请一个新节点用来存放进位</li>
</ul>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode *<span class="title">addTwoNumbers</span><span class="params">(struct ListNode *l1, struct ListNode *l2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">l3</span> =</span> (struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">    l3-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span> =</span> l1, *q = l2, *r = l3;</span><br><span class="line">    <span class="keyword">int</span> a, b, c, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> || q != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a = p != <span class="literal">NULL</span> ? p-&gt;val : <span class="number">0</span>;</span><br><span class="line">        b = q != <span class="literal">NULL</span> ? q-&gt;val : <span class="number">0</span>;</span><br><span class="line">        c = (a + b + flag) % <span class="number">10</span>;</span><br><span class="line">        flag = (a + b + flag) / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        r-&gt;next = (struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">        r-&gt;val = c;</span><br><span class="line">        r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="literal">NULL</span>)</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">    &#123;</span><br><span class="line">        r-&gt;next = (struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">        r-&gt;val = <span class="number">1</span>;</span><br><span class="line">        r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l3-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>852.山脉数组的峰顶索引</title>
    <url>/2020021561782/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>我们把符合下列属性的数组 <code>A</code> 称作山脉：</p>
<ul>
<li><code>A.length &gt;= 3</code></li>
<li>存在 <code>0 &lt; i &lt; A.length - 1</code> 使得<code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code></li>
</ul>
<p>给定一个确定为山脉的数组，返回任何满足 <code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code> 的 <code>i</code> 的值。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[0,1,0]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[0,2,1,0]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>3 &lt;= A.length &lt;= 10000</code></li>
<li>0 &lt;= A[i] &lt;= 10^6</li>
<li>A 是如上定义的山脉</li>
</ol>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>遍历</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul>
<li>遍历数组，遇到比前一个元素小的时候停下，返回前边元素的索引</li>
</ul>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> ASize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; ASize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] &gt; A[i - <span class="number">1</span>])</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>905.按奇偶排序数组</title>
    <url>/2020021541704/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个非负整数数组 <code>A</code>，返回一个数组，在该数组中， <code>A</code> 的所有偶数元素之后跟着所有奇数元素。</p>
<p>你可以返回满足此条件的任何数组作为答案。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,1,2,4]</span><br><span class="line">输出：[2,4,3,1]</span><br><span class="line">输出 [4,2,3,1]，[2,4,1,3] 和 [4,2,1,3] 也会被接受。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 5000</code></li>
<li><code>0 &lt;= A[i] &lt;= 5000</code></li>
</ol>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>双指针</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul>
<li>声明头尾指针向数组中间遍历，<code>i</code>指针指向偶数，<code>j</code>指针指向奇数；当不符合上述情况时，则交换<code>i</code>和<code>j</code>指针所指向的元素。</li>
</ul>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">sortArrayByParity</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> ASize, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = ASize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A[j] % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp = A[i];</span><br><span class="line">            A[i] = A[j];</span><br><span class="line">            A[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = ASize;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>dynamic-programming</tag>
      </tags>
  </entry>
  <entry>
    <title>941.有效的山脉数组</title>
    <url>/2020021532146/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个整数数组 <code>A</code>，如果它是有效的山脉数组就返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p>让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组：</p>
<ul>
<li><p><code>A.length &gt;= 3</code></p>
</li>
<li><p>在 <code>0 &lt; i &lt; A.length - 1</code>条件下，存在<code>i</code>使得：</p>
<ul>
<li><code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i]</code></li>
<li><code>A[i] &gt; A[i+1] &gt; ... &gt; A[B.length - 1]</code></li>
</ul>
</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[2,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,5,5]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[0,3,2,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>0 &lt;= A.length &lt;= 10000</code></li>
<li><code>0 &lt;= A[i] &lt;= 10000</code></li>
</ol>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>双指针</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul>
<li>找到<strong>山峰（最大值）</strong>，使用双指针从数组两端向<strong>山峰</strong>遍历</li>
</ul>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validMountainArray</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> ASize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ASize &lt; <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>, indexOfMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (m = <span class="number">0</span>; m &lt; ASize; m++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[m] &gt; max)</span><br><span class="line">        &#123;</span><br><span class="line">            max = A[m];</span><br><span class="line">            indexOfMax = m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//排除山峰在头尾的情况</span></span><br><span class="line">    <span class="keyword">if</span> (indexOfMax == <span class="number">0</span> || indexOfMax == ASize - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = ASize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; indexOfMax || j &gt; indexOfMax)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i + <span class="number">1</span>] &gt; A[i] &amp;&amp; i &lt; indexOfMax)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A[j - <span class="number">1</span>] &gt; A[j] &amp;&amp; j &gt; indexOfMax)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、PS"><a href="#三、PS" class="headerlink" title="三、PS"></a>三、PS</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = indexOfMax, j = indexOfMax;</span><br><span class="line"><span class="keyword">while</span> (i &gt; <span class="number">0</span> || j &lt; A.length - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (A[i - <span class="number">1</span>] &lt; A[i] &amp;&amp; i &gt; <span class="number">0</span>)</span><br><span class="line">        i--;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (A[j + <span class="number">1</span>] &lt; A[j] &amp;&amp; j &lt; A.length - <span class="number">1</span>)</span><br><span class="line">        j++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的思想是从中间的<strong>山峰</strong>向两端遍历，一直遇到了莫名其妙的内存溢出问题，后来改用了双指针从两端向<strong>山峰</strong>遍历</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>605.种花问题</title>
    <url>/2020021451823/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p>
<p>给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 <strong>n</strong> 。能否在不打破种植规则的情况下种入 <strong>n</strong> 朵花？能则返回True，不能则返回False。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: flowerbed &#x3D; [1,0,0,0,1], n &#x3D; 1</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: flowerbed &#x3D; [1,0,0,0,1], n &#x3D; 2</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ol>
<li>数组内已种好的花不会违反种植规则。</li>
<li>输入的数组长度范围为 [1, 20000]。</li>
<li><strong>n</strong> 是非负整数，且不会超过输入数组的大小。</li>
</ol>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul>
<li>在数组首尾添加零（去除边界的影响），每三个0可以种一朵花</li>
</ul>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="keyword">int</span> *flowerbed, <span class="keyword">int</span> flowerbedSize, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//在首尾添加零</span></span><br><span class="line">    <span class="keyword">int</span> *help = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>((flowerbedSize + <span class="number">2</span>) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    help[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    help[flowerbedSize + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= flowerbedSize; i++)</span><br><span class="line">        help[i] = flowerbed[i - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//每三个零种一朵花</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= flowerbedSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (help[i - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; help[i] == <span class="number">0</span> &amp;&amp; help[i + <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            help[i] = <span class="number">1</span>;<span class="comment">//种花</span></span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>628.三个数的最大乘积</title>
    <url>/2020021464342/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: 24</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ol>
<li>给定的整型数组长度范围是[3,104]，数组中所有的元素范围是[-1000, 1000]。</li>
<li>输入的数组中任意三个数的乘积不会超出32位有符号整数的范围。</li>
</ol>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>排序、选数</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol>
<li>对数组进行升序排序</li>
<li><p>最大乘积：</p>
<ol>
<li>全是正数：选三个最大的</li>
<li>全是负数：还选三个最大的</li>
<li>有正有负：<ul>
<li>[-4, 0, 2, 3] : 选三个最大的</li>
<li>[-4, -3, 1, 2] : 选两个负的一个正的</li>
</ul>
</li>
</ol>
</li>
<li><p>所以最大乘积只有两种情况：</p>
<ul>
<li>第一个负数的绝对值比较小倒着选三个数</li>
<li>正着选两个数，倒着选一个数</li>
</ul>
</li>
<li><p>选两个数中的较大数</p>
</li>
</ol>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//升序</span></span><br><span class="line">    <span class="keyword">return</span> (*(<span class="keyword">int</span> *)a - *(<span class="keyword">int</span> *)b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximumProduct</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>] * nums[<span class="number">1</span>] * nums[<span class="number">2</span>];</span><br><span class="line">    qsort(nums, numsSize, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), compare1);</span><br><span class="line">    <span class="keyword">int</span> max1 = nums[numsSize - <span class="number">1</span>] * nums[numsSize - <span class="number">2</span>] * nums[numsSize - <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span> max2 = nums[<span class="number">0</span>] * nums[<span class="number">1</span>] * nums[numsSize - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> max1 &gt; max2 ? max1 : max2;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>674.最长连续递增序列</title>
    <url>/2020021413254/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个未经排序的整数数组，找到最长且<strong>连续</strong>的的递增序列。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,4,7]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 最长连续递增序列是 [1,3,5], 长度为3。</span><br><span class="line">尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。 </span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,2,2,2,2]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 最长连续递增序列是 [2], 长度为1。</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>数组长度不会超过10000。</p>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>简单遍历</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul>
<li>for循环遍历整个数组，用中间变量temp记录每次的连续长度，用res与temp比较作为最大值</li>
</ul>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">1</span>, res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            temp++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            res = res &gt; temp ? res : temp;</span><br><span class="line">            temp = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res = res &gt; temp ? res : temp;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>717.1比特与2比特字符</title>
    <url>/2020021422762/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>有两种特殊字符。第一种字符可以用一比特<code>0</code>来表示。第二种字符可以用两比特(<code>10</code> 或 <code>11</code>)来表示。</p>
<p>现给一个由若干比特组成的字符串。问最后一个字符是否必定为一个一比特字符。给定的字符串总是由0结束。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">bits &#x3D; [1, 0, 0]</span><br><span class="line">输出: True</span><br><span class="line">解释: </span><br><span class="line">唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是一比特字符。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">bits &#x3D; [1, 1, 1, 0]</span><br><span class="line">输出: False</span><br><span class="line">解释: </span><br><span class="line">唯一的编码方式是两比特字符和两比特字符。所以最后一个字符不是一比特字符。</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ul>
<li><code>1 &lt;= len(bits) &lt;= 1000</code>.</li>
<li><code>bits[i]</code> 总是<code>0</code> 或 <code>1</code>.</li>
</ul>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>模拟栈</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul>
<li>把数组想象成一个栈底在数组尾部的栈，从头开始出栈，遇到以下两种情况出栈：<ul>
<li>1后边是1或0，出栈</li>
<li>单独一个0，出栈</li>
</ul>
</li>
<li>如果栈底还剩一个元素，那么返回true，否则返回false。</li>
</ul>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isOneBitCharacter</span><span class="params">(<span class="keyword">int</span> *bits, <span class="keyword">int</span> bitsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bitsSize == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; bitsSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (bits[i] == <span class="number">1</span> &amp;&amp; (bits[i + <span class="number">1</span>] == <span class="number">1</span> || bits[i + <span class="number">1</span>] == <span class="number">0</span>))</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (bits[i] == <span class="number">0</span> &amp;&amp; i != bitsSize - <span class="number">1</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span> (i == bitsSize - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>724.寻找数组的中心索引</title>
    <url>/2020021440098/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个整数类型的数组 <code>nums</code>，请编写一个能够返回数组<strong>“中心索引”</strong>的方法。</p>
<p>我们是这样定义数组<strong>中心索引</strong>的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。</p>
<p>如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">nums &#x3D; [1, 7, 3, 6, 5, 6]</span><br><span class="line">输出: 3</span><br><span class="line">解释: </span><br><span class="line">索引3 (nums[3] &#x3D; 6) 的左侧数之和(1 + 7 + 3 &#x3D; 11)，与右侧数之和(5 + 6 &#x3D; 11)相等。</span><br><span class="line">同时, 3 也是第一个符合要求的中心索引。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">nums &#x3D; [1, 2, 3]</span><br><span class="line">输出: -1</span><br><span class="line">解释: </span><br><span class="line">数组中不存在满足此条件的中心索引。</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ul>
<li><code>nums</code> 的长度范围为 <code>[0, 10000]</code>。</li>
<li>任何一个 <code>nums[i]</code> 将会是一个范围在 <code>[-1000, 1000]</code>的整数。</li>
</ul>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>前缀和（参考官解）</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul>
<li><code>leftSum == sum - leftSum - nums[i]</code>时，就找到了最左边的中心索引</li>
</ul>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, leftSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftSum == sum - nums[i] - leftSum)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        leftSum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>747.至少是其他数字两倍的最大数</title>
    <url>/2020021435259/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>在一个给定的数组<code>nums</code>中，总是存在一个最大元素 。</p>
<p>查找数组中的最大元素是否至少是数组中每个其他数字的两倍。</p>
<p>如果是，则返回最大元素的索引，否则返回-1。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [3, 6, 1, 0]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 6是最大的整数, 对于数组中的其他整数,</span><br><span class="line">6大于数组中其他元素的两倍。6的索引是1, 所以我们返回1.</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1, 2, 3, 4]</span><br><span class="line">输出: -1</span><br><span class="line">解释: 4没有超过3的两倍大, 所以我们返回 -1.</span><br></pre></td></tr></table></figure>
<p><strong>提示:</strong></p>
<ol>
<li><code>nums</code> 的长度范围在<code>[1, 50]</code>.</li>
<li>每个 <code>nums[i]</code> 的整数范围在 <code>[0, 100]</code>.</li>
</ol>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>数组遍历</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul>
<li>找到最大值，并记录其索引，如果<code>2 * nums[i] &gt; max</code>，返回-1；否则，返回最大值的索引</li>
</ul>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dominantIndex</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>], maxIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; max)</span><br><span class="line">        &#123;</span><br><span class="line">            max = nums[i];</span><br><span class="line">            maxIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == maxIndex)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * nums[i] &gt; max)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>dynamic-programming</tag>
      </tags>
  </entry>
  <entry>
    <title>561.数组拆分</title>
    <url>/2020021324149/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定长度为 <strong>2n</strong> 的数组, 你的任务是将这些数分成 <strong>n</strong> 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,4,3,2]</span><br><span class="line"></span><br><span class="line">输出: 4</span><br><span class="line">解释: n 等于 2, 最大总和为 4 &#x3D; min(1, 2) + min(3, 4).</span><br></pre></td></tr></table></figure>
<p><strong>提示:</strong></p>
<ol>
<li><strong>n</strong> 是正整数,范围在 [1, 10000].</li>
<li>数组中的元素范围在 [-10000, 10000].</li>
</ol>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><ol>
<li><p>算法描述</p>
<ul>
<li>排序+最小值累加</li>
</ul>
</li>
<li><p>个人分析</p>
<ul>
<li>首先将给定数组排序，然后每两位选择较小值进行累加</li>
</ul>
</li>
<li><p>代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//升序</span></span><br><span class="line">    <span class="keyword">return</span> (*(<span class="keyword">int</span> *)a - *(<span class="keyword">int</span> *)b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sizeOfElem = <span class="keyword">sizeof</span>(nums[<span class="number">0</span>]);</span><br><span class="line">    qsort(nums, numsSize, sizeOfElem, compare1);</span><br><span class="line">    <span class="keyword">int</span> i, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i += <span class="number">2</span>)</span><br><span class="line">        res += min(nums[i], nums[i + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>581.最短无序连续子数组</title>
    <url>/2020021335388/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个整数数组，你需要寻找一个<strong>连续的子数组</strong>，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p>
<p>你找到的子数组应是<strong>最短</strong>的，请输出它的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2, 6, 4, 8, 10, 9, 15]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。</span><br></pre></td></tr></table></figure>
<p><strong>说明 :</strong></p>
<ol>
<li>输入的数组长度范围在 [1, 10,000]。</li>
<li>输入的数组可能包含<strong>重复</strong>元素 ，所以<strong>升序</strong>的意思是<strong>&lt;=。</strong></li>
</ol>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>排序+逐位异或+双指针扫描</li>
<li>双指针</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul>
<li>首先利用快速排序数组进行升序排序，然后与原数组逐位异或，位置没变的元素就会变成0，然后利用头尾指针扫描，每遇到0，就将数组长度减一，头尾指针都遇到不为零的数时，停止扫描</li>
<li>总结时发现，只利用双指针就行了，头尾指针向中间扫描时，头指针扫描的数应该是越来越大的，而尾指针扫描的数应该是越来越小的，当头指针的后一个数比当前位置的数小时，头指针就应该停下了，尾指针亦然；当头尾指针相遇，则表明这是一个完全有序的数组，所以返回0.</li>
</ul>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">compare1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//升序</span></span><br><span class="line">    <span class="keyword">return</span> (*(<span class="keyword">int</span> *)a - *(<span class="keyword">int</span> *)b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> *help = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(numsSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">        help[i] = nums[i];</span><br><span class="line">    qsort(nums, numsSize, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), compare1);</span><br><span class="line">    <span class="comment">//逐位异或</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">        nums[i] ^= help[i];</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>, n = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = numsSize;</span><br><span class="line">    <span class="comment">//双指针</span></span><br><span class="line">    <span class="keyword">while</span> ((nums[m] == <span class="number">0</span> || nums[n] == <span class="number">0</span>) &amp;&amp; m &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[m] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res--;</span><br><span class="line">            m++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[n] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res--;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) <span class="comment">//如果队列有序，res=-1，那么应该返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>448.找到所有数组中消失的数字</title>
    <url>/2020021242765/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p><strong>Tags：</strong></p>
<p>给定一个范围在 1 ≤ a[i] ≤ <em>n</em> ( <em>n</em> = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p>
<p>找到所有在 [1, <em>n</em>] 范围之间没有出现在数组中的数字。</p>
<p>您能在不使用额外空间且时间复杂度为<em>O(n)</em>的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>类似标记数组</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul>
<li><p>将数组中的元素对应的数组值置为负数，然后遍历数组中大于零的元素，其索引就是消失的数字</p>
<p>例如：</p>
<ul>
<li>输入：[ 4, 3, 2, 7, 8, 2, 3, 1]</li>
<li>输出：[-4,-3,-2,-7,<code>8</code>,<code>2</code>,-3,-1]</li>
</ul>
</li>
</ul>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *res = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(numsSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">        nums[<span class="built_in">abs</span>(nums[i]) - <span class="number">1</span>] = -<span class="built_in">abs</span>(nums[<span class="built_in">abs</span>(nums[i]) - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">            res[j++] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = j;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>414.第三大的数</title>
    <url>/2020021138826/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3, 2, 1]</span><br><span class="line"></span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">解释: 第三大的数是 1.</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1, 2]</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释: 第三大的数不存在, 所以返回最大的数 2 .</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2, 2, 3, 1]</span><br><span class="line"></span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">解释: 注意，要求返回第三大的数，是指第三大且唯一出现的数。</span><br><span class="line">存在两个值为2的数，它们都排第二。</span><br></pre></td></tr></table></figure>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>窗口滑动</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul>
<li>初始化一个长度为三的滑动窗口，用三个变量实现。遍历数组时，使用数组中的元素更新窗口中的值，使用<code>flag</code>标记窗口中元素的更新次数，如果flag&gt;=3，则说明窗口中的元素被全部更新，即返回窗口中的最小值；否则，falg只更新了1次或2次，即第三大的数不存在, 所以返回最大的数。</li>
</ul>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">thirdMax</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>] &gt;= nums[<span class="number">1</span>] ? nums[<span class="number">0</span>] : nums[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i, flag = <span class="number">0</span>, intmin = <span class="number">1</span>;<span class="comment">//intmin是为了排除掉数组中的INT_MIN</span></span><br><span class="line">    <span class="keyword">int</span> min = -__INT_MAX__ - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = -__INT_MAX__ - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> max = -__INT_MAX__ - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == -__INT_MAX__ - <span class="number">1</span> &amp;&amp; intmin)</span><br><span class="line">        &#123;</span><br><span class="line">            flag++;</span><br><span class="line">            intmin = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; max)</span><br><span class="line">        &#123;</span><br><span class="line">            flag++;</span><br><span class="line">            min = mid;</span><br><span class="line">            mid = max;</span><br><span class="line">            max = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; mid &amp;&amp; nums[i] &lt; max)</span><br><span class="line">        &#123;</span><br><span class="line">            flag++;</span><br><span class="line">            min = mid;</span><br><span class="line">            mid = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; min &amp;&amp; nums[i] &lt; mid)</span><br><span class="line">        &#123;</span><br><span class="line">            flag++;</span><br><span class="line">            min = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag &gt;= <span class="number">3</span> ? min : max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>287.寻找重复数</title>
    <url>/2020021052913/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个包含 <em>n</em> + 1 个整数的数组 <em>nums</em>，其数字都在 1 到 <em>n</em> 之间（包括 1 和 <em>n</em>），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,4,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,1,3,4,2]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li><strong>不能</strong>更改原数组（假设数组是只读的）。</li>
<li>只能使用额外的 <em>O</em>(1) 的空间。</li>
<li>时间复杂度小于 <em>O</em>(<em>n</em>2) 。</li>
<li>数组中只有一个重复的数字，但它可能不止重复出现一次。</li>
</ol>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>快指针&amp;慢指针</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul>
<li><p>将此题抽象成环型链表问题（见141题、142题）</p>
<p>那么如何在数组中模拟快慢指针呢？</p>
<p>看了题解：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fast = nums[nums[fast]];</span><br><span class="line">slow = nums[slow];</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slow &#x3D; 0;fast &#x3D; 0;</span><br><span class="line">nums[] &#x3D; [3,1,3,4,2]</span><br><span class="line">nums[slow] &#x3D; [3,4,2,3]</span><br><span class="line">nums[nums[fast]] &#x3D; [4,3,2,4]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) <span class="comment">//一定有相同元素，所以死循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        fast = nums[nums[fast]]; <span class="comment">//快指针</span></span><br><span class="line">        slow = nums[slow];       <span class="comment">//慢指针</span></span><br><span class="line">        <span class="keyword">if</span> (slow == fast)        <span class="comment">//快慢指针相遇，开始寻找成环入口，即为重复的数</span></span><br><span class="line">        &#123;</span><br><span class="line">            fast = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">/*寻找环的入口</span></span><br><span class="line"><span class="comment">                nums[slow] == nums[fast]时，快慢指针指向的元素相等，即为所求元素</span></span><br><span class="line"><span class="comment">                快慢指针指向的元素不等时，则继续寻找*/</span></span><br><span class="line">            <span class="keyword">while</span> (nums[slow] != nums[fast])</span><br><span class="line">            &#123;</span><br><span class="line">                fast = nums[fast];</span><br><span class="line">                slow = nums[slow];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> nums[slow];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、PS"><a href="#三、PS" class="headerlink" title="三、PS"></a>三、PS</h2><p>这是一道中等难度的题目，我还不是很理解。完全参考了作者<a href="https://leetcode-cn.com/u/seu_fidget/">SEU.FidGet</a>的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        快慢指针思想, fast 和 slow 是指针, nums[slow] 表示取指针对应的元素</span></span><br><span class="line"><span class="comment">        注意 nums 数组中的数字都是在 1 到 n 之间的(在数组中进行游走不会越界),</span></span><br><span class="line"><span class="comment">        因为有重复数字的出现, 所以这个游走必然是成环的, 环的入口就是重复的元素, </span></span><br><span class="line"><span class="comment">        即按照寻找链表环入口的思路来做</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">0</span>, slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            <span class="keyword">if</span>(slow == fast) &#123;</span><br><span class="line">                fast = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(nums[slow] != nums[fast]) &#123;</span><br><span class="line">                    fast = nums[fast];</span><br><span class="line">                    slow = nums[slow];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> nums[slow];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>two-pointers</tag>
        <tag>binary-search</tag>
      </tags>
  </entry>
  <entry>
    <title>268.缺失数字</title>
    <url>/2020020958118/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个包含 <code>0, 1, 2, ..., n</code> 中 <em>n</em> 个数的序列，找出 0 .. <em>n</em> 中没有出现在序列中的那个数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,0,1]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [9,6,4,2,3,5,7,0,1]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong><br>你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现?</p>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>标记数组</li>
<li>异或</li>
<li>求和做差</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul>
<li>标记数组：申请一个<strong>n+1</strong>长度的标记数组，用这个数组记录，最后遍历标记数组即可</li>
<li>异或：按for循环中的i异或（大佬的方法）</li>
<li>求和做差：先利用数学法求出前n项和，再减去数组中的元素，剩下的差就是答案</li>
</ul>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>((numsSize + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[nums[i]] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i] != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>bit-manipu</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>283.移动零</title>
    <url>/2020020928492/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>:</p>
<ol>
<li>必须在原数组上操作，不能拷贝额外的数组。</li>
<li>尽量减少操作次数。</li>
</ol>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>双指针法</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul>
<li>指针<code>i</code>用于寻找零，指针<code>j</code>用于寻找指针<code>i</code>后边不为零的数，并令<code>nums[i]=nums[j]</code>，然后再令<code>nums[j]=0</code>，遍历整个数组。</li>
</ul>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; numsSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; numsSize)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    nums[i] = nums[j];</span><br><span class="line">                    nums[j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>189.旋转数组</title>
    <url>/2020020820560/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个数组，将数组中的元素向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,5,6,7] 和 k &#x3D; 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [-1,-100,3,99] 和 k &#x3D; 2</span><br><span class="line">输出: [3,99,-1,-100]</span><br><span class="line">解释: </span><br><span class="line">向右旋转 1 步: [99,-1,-100,3]</span><br><span class="line">向右旋转 2 步: [3,99,-1,-100]</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ul>
<li>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</li>
<li>要求使用空间复杂度为 O(1) 的 <strong>原地</strong> 算法。</li>
</ul>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>暴力法：两个for循环嵌套，每次将数组中的元素向后移动一位</li>
<li>三次翻转数组</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul>
<li>暴力法挺好理解就是超时</li>
<li>三次翻转：<ul>
<li>第一次：将整个数组翻转</li>
<li>第二次：将[0,k-1]的数组翻转</li>
<li>第三次：将[k,n-1]的数组翻转</li>
</ul>
</li>
</ul>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        temp = nums[low];</span><br><span class="line">        nums[low] = nums[high];</span><br><span class="line">        nums[high] = temp;</span><br><span class="line">        low++;</span><br><span class="line">        high--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    k = k % numsSize;</span><br><span class="line">    reverse(nums, <span class="number">0</span>, numsSize - <span class="number">1</span>);</span><br><span class="line">    reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">    reverse(nums, k, numsSize - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、PS："><a href="#三、PS：" class="headerlink" title="三、PS："></a>三、PS：</h2><p>暴力法的超时代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//超时了</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (numsSize &lt; <span class="number">2</span>)</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       <span class="keyword">int</span> minK = k % numsSize;</span><br><span class="line">       <span class="keyword">int</span> i, temp, j;</span><br><span class="line">       <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; minK; j++)</span><br><span class="line">       &#123;</span><br><span class="line">           temp = nums[numsSize - <span class="number">1</span>];</span><br><span class="line">           <span class="keyword">for</span> (i = numsSize - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">           &#123;</span><br><span class="line">               nums[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">           &#125;</span><br><span class="line">           nums[<span class="number">0</span>] = temp;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>217.存在重复元素</title>
    <url>/2020020860940/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,1,1,3,3,4,3,2,4,2]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1. 算法描述"></a>1. 算法描述</h3><ul>
<li>暴力法：两个for循环嵌套遍历</li>
<li>使用qsort()排序，再逐位检查</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2. 个人分析"></a>2. 个人分析</h3><ul>
<li>暴力法超时</li>
<li>qsort()最坏复杂度：O(nlogn)</li>
</ul>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*(<span class="keyword">int</span> *)a - *(<span class="keyword">int</span> *)b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> sizeOfElem = <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    qsort(nums, numsSize, sizeOfElem, compare);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、PS："><a href="#三、PS：" class="headerlink" title="三、PS："></a>三、PS：</h2><ul>
<li><p>暴力法超时</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; numsSize; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>qsort()快速排序：</p>
<p><code>void qsort(void *_Base, size_t _NumOfElements, size_t _SizeOfElements, int (*_PtFuncCompare)(const void *, const void *))</code></p>
<ul>
<li>_Base：待排序的数组</li>
<li>_NumOfElements：数组中元素的个数</li>
<li>_SizeOfElements：数组中元素的大小</li>
<li>(<em>_PtFuncCompare)(const void </em>, const void *))：比较指针</li>
</ul>
</li>
<li><p>qsort()函数实例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="comment">//升序</span></span><br><span class="line">    <span class="keyword">return</span> (*(<span class="keyword">int</span> *)a - *(<span class="keyword">int</span> *)b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="comment">//降序</span></span><br><span class="line">    <span class="keyword">return</span> (*(<span class="keyword">int</span> *)b - *(<span class="keyword">int</span> *)a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> numsOfArray = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> sizeOfElem = <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">    qsort(<span class="built_in">array</span>, numsOfArray, sizeOfElem, compare1);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsOfArray; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>hash-table</tag>
      </tags>
  </entry>
  <entry>
    <title>219.存在重复元素Ⅱ</title>
    <url>/2020020837186/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个整数数组和一个整数 <em>k</em>，判断数组中是否存在两个不同的索引 <em>i</em> 和 <em>j</em>，使得 <strong>nums [i] = nums [j]</strong>，并且 <em>i</em> 和 <em>j</em> 的差的绝对值最大为 <em>k</em>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,3,1], k &#x3D; 3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,0,1,1], k &#x3D; 1</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,3,1,2,3], k &#x3D; 2</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul>
<li>暴力：for()循环嵌套+if (nums[i] == nums[j] &amp;&amp; j - i &lt;= k)判断</li>
<li>屈辱😭：面向测试用例编程</li>
</ul>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul>
<li>暴力：又是妥妥的超时！！！</li>
</ul>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">35000</span>) <span class="comment">//留下了屈辱的眼泪</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; numsSize; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[j] &amp;&amp; j - i &lt;= k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、PS"><a href="#三、PS" class="headerlink" title="三、PS"></a>三、PS</h2><p>超时代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; numsSize; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[j] &amp;&amp; j - i &lt;= k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>hash-table</tag>
      </tags>
  </entry>
  <entry>
    <title>204.计数质数</title>
    <url>/2020020719049/</url>
    <content><![CDATA[<h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>统计所有小于非负整数 n 的质数的数量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: 10</span><br><span class="line">输出: 4</span><br><span class="line">解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</span><br></pre></td></tr></table></figure>
<h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><blockquote>
<p><a href="https://baike.baidu.com/item/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC%E7%AD%9B%E6%B3%95/374984?fr=aladdin#1">埃拉托斯特尼筛法</a></p>
<p>​        埃拉托斯特尼筛法，简称埃氏筛或爱氏筛，是一种由希腊数学家埃拉托斯特尼所提出的一种简单检定素数的算法。要得到自然数n以内的全部素数，必须把不大于根号n的所有素数的倍数剔除，剩下的就是素数。</p>
</blockquote>
<h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><p>   ​        声明一个长度为n的数组，索引<code>i</code>作为待判断的数，索引中的值<code>isPrime[i]</code>作为该索引是否为素数的flag，使用for循环开始逐一判断数组索引<code>i</code>是否为素数，如果是素数，则将其n以内的所有倍数过滤，再判断下一个索引<code>i</code>。</p>
<h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3>   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//爱式筛法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *isPrime = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    <span class="built_in">memset</span>(isPrime, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);<span class="comment">//初始化isPrime为0</span></span><br><span class="line">    <span class="keyword">int</span> i, j, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">for</span> (j = i + i; j &lt; n; j += i)</span><br><span class="line">            &#123; <span class="comment">//筛去i的倍数</span></span><br><span class="line">                isPrime[j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、PS"><a href="#三、PS" class="headerlink" title="三、PS:"></a>三、PS:</h2><p>   <code>void *memset(void *_Dst, int _Val, size_t _Size)</code></p>
<ul>
<li><p>memset()函数为初始化一块连续的内存空间，<strong>按照字节赋值</strong></p>
</li>
<li><p>_Dst：指针变量（起始位置）</p>
</li>
<li>_Val：初始化的值（一般为-1或0）</li>
<li>_Size：内存长度</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>hash-table</tag>
        <tag>math</tag>
      </tags>
  </entry>
</search>
