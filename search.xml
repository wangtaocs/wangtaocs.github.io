<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>530.二叉搜索树的最小绝对差</title>
    <url>/2020/03/12/530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/</url>
    <content><![CDATA[<!-- build time:Thu Mar 12 2020 22:17:48 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     3</span><br><span class="line">    &#x2F;</span><br><span class="line">   2</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中至少有 2 个节点。</li><li>本题与 783 <a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/</a> 相同</li></ul><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-中序遍历-数组遍历"><a href="#1-中序遍历-数组遍历" class="headerlink" title="1.中序遍历+数组遍历"></a>1.中序遍历+数组遍历</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><ol><li>使用中序遍历二叉搜索树，得到一个不严格的递增序列</li><li>遍历这个递增序列，找到最小差值</li></ol><h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 10000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[maxSize];</span><br><span class="line">    <span class="keyword">int</span> arrTop = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">stack</span>[<span class="title">maxSize</span>], *<span class="title">p</span> = <span class="title">root</span>;</span></span><br><span class="line">    <span class="keyword">int</span> stackTop = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (stackTop != <span class="number">-1</span> || p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">stack</span>[++stackTop] = p;</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        p = <span class="built_in">stack</span>[stackTop--];</span><br><span class="line">        arr[++arrTop] = p-&gt;val;</span><br><span class="line">        p = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = arr[<span class="number">1</span>] - arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= arrTop; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i] - arr[i - <span class="number">1</span>];</span><br><span class="line">        res = res &gt; temp ? temp : res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然和783题一样，那就顺便做了，嘿嘿嘿😄</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>543.二叉树的直径</title>
    <url>/2020/03/12/543.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
    <content><![CDATA[<!-- build time:Thu Mar 12 2020 22:23:19 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。</p><p><strong>示例 :</strong><br>给定二叉树</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line"> &#x2F; \     </span><br><span class="line">4   5</span><br></pre></td></tr></table></figure><p>返回 <strong>3</strong>, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p><p><strong>注意：</strong>两结点之间的路径长度是以它们之间边的数目表示。</p><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><ol><li><p>使用递归，求得左右子树的最大深度，直径即为左右子树的最大深度之和，由此得到了第一版代码：</p><p>遇到测试用例：<strong>[4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]</strong></p></li></ol><p><img src="https://i.loli.net/2020/03/12/Dex32TKBlkfazpQ.png" alt="Snipaste_2020-03-12_22-21-10.png"></p><ol><li>由此测试用例意识到，二叉树的直径是：在递归的过程中，左右子树的最大深度之和的<strong>最大值</strong>，由此得到第二版代码：</li></ol><h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4><p>第一版：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> l = maxDepth(root-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> r = maxDepth(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> (l &gt; r ? l : r) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> maxDepth(root-&gt;left) + maxDepth(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二版：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> l = maxDepth(root-&gt;left, res);</span><br><span class="line">    <span class="keyword">int</span> r = maxDepth(root-&gt;right, res);</span><br><span class="line">    *res = *res &lt; (l + r) ? (l + r) : *res;</span><br><span class="line">    <span class="keyword">return</span> (l &gt; r ? l : r) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span> || (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    maxDepth(root, &amp;res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>226.反转二叉树</title>
    <url>/2020/03/11/226.%E5%8F%8D%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<!-- build time:Wed Mar 11 2020 21:45:14 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>翻转一棵二叉树。</p><p><strong>示例：</strong></p><p>输入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure><p><strong>备注:</strong><br>这个问题是受到 <a href="https://twitter.com/mxcl" target="_blank" rel="noopener">Max Howell </a>的 <a href="https://twitter.com/mxcl/status/608682016205344768" target="_blank" rel="noopener">原问题</a> 启发的 ：</p><blockquote><p>谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</p></blockquote><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><ol><li>声明一个辅助指针用于交换当前节点的左右孩子</li><li>递归反转左右孩子的孩子节点</li></ol><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode *<span class="title">invertTree</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">p</span>;</span></span><br><span class="line">    p = root-&gt;left;</span><br><span class="line">    root-&gt;left = root-&gt;right;</span><br><span class="line">    root-&gt;right = p;</span><br><span class="line">    invertTree(root-&gt;left);</span><br><span class="line">    invertTree(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>404.左叶子之和</title>
    <url>/2020/03/11/404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<!-- build time:Wed Mar 11 2020 21:45:14 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>计算给定二叉树的所有左叶子之和。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><p>什么叫左叶子？</p><p>答：左孩子节点不为空且左孩子没有孩子节点。</p><p>递归判断左右子树，返回所有左叶子之和。</p><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//左叶子：</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">        res += root-&gt;left-&gt;val;</span><br><span class="line">    <span class="keyword">return</span> res + sumOfLeftLeaves(root-&gt;left) + sumOfLeftLeaves(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>235.二叉搜索树的最近公共祖先</title>
    <url>/2020/03/11/235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<!-- build time:Wed Mar 11 2020 21:45:14 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin" target="_blank" rel="noopener">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p>例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]</p><p><img src="https://i.loli.net/2020/03/11/p6gGR9iUweEfkbL.png" alt="binarysearchtree_improved.png"></p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li></ul><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><p>利用<strong>二叉搜索树</strong>的性质</p><p>当p和q的值都小于根结点时，就去左树中找；</p><p>当p和q的值都大于根结点时，就去右树中找；</p><p>否则，返回根节点。</p><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct TreeNode *<span class="title">lowestCommonAncestor</span><span class="params">(struct TreeNode *root, struct TreeNode *p, struct TreeNode *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>437.路径总和 III</title>
    <url>/2020/03/11/437.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20III/</url>
    <content><![CDATA[<!-- build time:Wed Mar 11 2020 21:45:14 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个二叉树，它的每个结点都存放着一个整数值。</p><p>找出路径和等于给定数值的路径总数。</p><p>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p>二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1], sum &#x3D; 8</span><br><span class="line"></span><br><span class="line">      10</span><br><span class="line">     &#x2F;  \</span><br><span class="line">    5   -3</span><br><span class="line">   &#x2F; \    \</span><br><span class="line">  3   2   11</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">3  -2   1</span><br><span class="line"></span><br><span class="line">返回 3。和等于 8 的路径有:</span><br><span class="line"></span><br><span class="line">1.  5 -&gt; 3</span><br><span class="line">2.  5 -&gt; 2 -&gt; 1</span><br><span class="line">3.  -3 -&gt; 11</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-双重递归"><a href="#1-双重递归" class="headerlink" title="1.双重递归"></a>1.双重递归</h3><blockquote><p>完全参考leetcode用户<a href="https://leetcode-cn.com/u/feng-huo-qian-qin-lu/" target="_blank" rel="noopener">烽火前秦路</a>的题解</p></blockquote><p>使用两层递归：</p><p>第一层：</p><ul><li>help()函数：遍历从顶点开始和为sum的路径数</li></ul><p>第二层：</p><ul><li>pathSum()函数：通过调用help()函数，遍历根节点，并递归遍历左右子树中所有和为sum的路径数</li></ul><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">help</span><span class="params">(struct TreeNode *p, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;val == sum)</span><br><span class="line">        res++;</span><br><span class="line">    res += help(p-&gt;left, sum - p-&gt;val);</span><br><span class="line">    res += help(p-&gt;right, sum - p-&gt;val);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = help(root, sum);</span><br><span class="line">    <span class="keyword">return</span> cnt + pathSum(root-&gt;left, sum) + pathSum(root-&gt;right, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>101.对称二叉树</title>
    <url>/2020/03/10/101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure><p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>如果你可以运用递归和迭代两种方法解决这个问题，会很加分。</p><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><h4 id="1-1-思路"><a href="#1-1-思路" class="headerlink" title="1.1 思路"></a>1.1 思路</h4><p>什么是对称二叉树：</p><ol><li>根节点的左右孩子相等</li><li>左孩子的左子树 == 右孩子的右子树 &amp;&amp; 左孩子的右子树 == 右孩子的左子树</li><li>递归第二个条件</li></ol><h4 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">visit</span><span class="params">(struct TreeNode *nodel, struct TreeNode *noder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nodel == <span class="literal">NULL</span> &amp;&amp; noder == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (nodel == <span class="literal">NULL</span> || noder == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (nodel-&gt;val == noder-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> visit(nodel-&gt;left, noder-&gt;right) &amp;&amp; visit(nodel-&gt;right, noder-&gt;left);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> visit(root-&gt;left, root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>depth-first-search</tag>
        <tag>breadth-first-search</tag>
      </tags>
  </entry>
  <entry>
    <title>98.验证二叉搜索树</title>
    <url>/2020/03/10/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li><li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-中序遍历（非递归）"><a href="#1-中序遍历（非递归）" class="headerlink" title="1.中序遍历（非递归）"></a>1.中序遍历（非递归）</h3><ul><li>使用中序遍历二叉树</li><li>用一个变量记录最小值</li><li>当指针p所指的值大于最小值时，更新最小值，否则返回false；</li></ul><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 1000</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">stack</span>[<span class="title">maxSize</span>], *<span class="title">p</span> = <span class="title">root</span>;</span></span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//flag是为了处理 -2147483648</span></span><br><span class="line">    <span class="keyword">int</span> a = -__INT_MAX__ - <span class="number">1</span>, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (top != <span class="number">-1</span> || p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">stack</span>[++top] = p;</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        p = <span class="built_in">stack</span>[top--];</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val &gt; a || flag == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a = p-&gt;val;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        p = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>depth-first-search</tag>
      </tags>
  </entry>
  <entry>
    <title>96.不同的二叉搜索树</title>
    <url>/2020/03/09/96.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个整数 <em>n</em>，求以 1 … <em>n</em> 为节点组成的二叉搜索树有多少种？</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">给定 n &#x3D; 3, 一共有 5 种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-应用卡塔兰数"><a href="#1-应用卡塔兰数" class="headerlink" title="1. 应用卡塔兰数"></a>1. 应用<a href="https://baike.baidu.com/item/catalan/7605685?fr=aladdin" target="_blank" rel="noopener">卡塔兰数</a></h3><ul><li><p>卡特兰数的通项式：<script type="math/tex">A_{n}=\frac{1}{n+1} C_{2 n}^{n}=C_{2 n}^{n}-C_{2 n}^{n-1}</script></p></li><li><p>卡特兰数的递推式：<script type="math/tex">A_{n+1}=\sum_{i=0}^{n} a A_{i} A_{n-i}</script></p></li></ul><p>因为通项式中的数太大会造成，所以采用递推式进行计算</p><h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        res = res * <span class="number">2</span> * (<span class="number">2</span> * i + <span class="number">1</span>) / (i + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>dynamic-programming</tag>
      </tags>
  </entry>
  <entry>
    <title>621.任务调度器</title>
    <url>/2020/03/08/621.%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。</p><p>然而，两个<strong>相同种类</strong>的任务之间必须有长度为 <strong>n</strong> 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p><p>你需要计算完成所有任务所需要的<strong>最短时间</strong>。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: tasks &#x3D; [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n &#x3D; 2</span><br><span class="line">输出: 8</span><br><span class="line">执行顺序: A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B.</span><br></pre></td></tr></table></figure><p><strong>注：</strong></p><ol><li>任务的总个数为 [1, 10000]。</li><li>n 的取值范围为 [0, 100]。</li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>设计：完全参考了<a href="https://leetcode-cn.com/problems/task-scheduler/solution/ren-wu-diao-du-qi-by-leetcode/" target="_blank" rel="noopener">官解的方法三</a></li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><p><del>我不是很理解，这里就把官解贴在这里吧</del>🙃</p><blockquote><p>在前两种方法中，我们了解到应当尽早安排出现次数较多的任务。我们假设 A 为出现次数最多的任务，假设其出现了 p 次，考虑到冷却时间，那么执行完所有任务的时间至少为 (p - 1) <em>(n + 1) + 1。我们把这个过程形象化地用图 1 表现出，可以发现，CPU 产生了 (p - 1) </em>n 个空闲时间，只有 p 个时间是在工作的。</p><p><img src="https://i.loli.net/2020/03/08/VHNaA2oPFLmXRIZ.png" alt="621_Task_Scheduler_new.png"></p><p>因此我们应当考虑把剩余的任务安排到这些空闲时间里，我们仍然按照这些任务的出现次序，从大到小进行安排，会有下面三种情况：</p><ul><li><p>某个任务和 A 出现的次数相同，例如图 2 中的任务 B。此时我们只能让 B 占据 p - 1 个空闲时间，而在非空闲时间里额外安排一个时间给 B 执行；</p></li><li><p>某个任务比 A 出现的次数少 1，例如图 2 中的任务 C。此时我们可以让 C 占据 p - 1 个空闲时间，就可以全部执行完；</p></li><li><p>某个任务比 A 出现的次数少 2 或更多，例如图 2 中的任务 D。此时我们可以按照列优先的顺序，将 D 填入空闲时间中。因为 D 出现的次数少于 p - 1，因此无论从哪个位置开始按照列优先的顺序放置，都可以保证相邻的两个 D 之间满足冷却时间的要求。</p></li></ul><p>在将所有的任务安排完成后，如果仍然有剩余的空闲时间，那么答案即为（任务的总数 + 剩余的空闲时间）；如果在安排某一个任务时，遇到了剩余的空闲时间不够的情况，那么答案一定就等于任务的总数。这是因为我们可以将空闲时间增加虚拟的一列，继续安排任务。如果不考虑这些虚拟的列，在原本空闲时间对应的那些列中的任务是可以按照要求顺序执行的，而增加了这些虚拟的列后，两个相邻的相同任务的间隔不可能减少，并且虚拟的列中的任务也满足冷却时间的要求，因此仍然顺序执行并跳过虚拟的列中剩余的“空闲时间”一定是可行的。</p></blockquote><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">int</span> *)a - *(<span class="keyword">int</span> *)b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="keyword">char</span> *tasks, <span class="keyword">int</span> tasksSize, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">map</span>, <span class="number">0</span>, <span class="number">26</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasksSize; i++)</span><br><span class="line">        <span class="built_in">map</span>[tasks[i] - <span class="string">'A'</span>]++;</span><br><span class="line">    qsort(<span class="built_in">map</span>, <span class="number">26</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), cmp);</span><br><span class="line">    <span class="keyword">int</span> max_val = <span class="built_in">map</span>[<span class="number">25</span>] - <span class="number">1</span>, idle_slots = max_val * n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">24</span>; i &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">map</span>[i] &gt; <span class="number">0</span>; i--)</span><br><span class="line">        idle_slots -= <span class="built_in">min</span>(<span class="built_in">map</span>[i], max_val);</span><br><span class="line">    <span class="keyword">return</span> idle_slots &gt; <span class="number">0</span> ? idle_slots + tasksSize : tasksSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>design</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title>641.设计循环双端队列</title>
    <url>/2020/03/08/641.%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>设计实现双端队列。<br>你的实现需要支持以下操作：</p><ul><li>MyCircularDeque(k)：构造函数,双端队列的大小为k。</li><li>insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true。</li><li>insertLast()：将一个元素添加到双端队列尾部。如果操作成功返回 true。</li><li>deleteFront()：从双端队列头部删除一个元素。 如果操作成功返回 true。</li><li>deleteLast()：从双端队列尾部删除一个元素。如果操作成功返回 true。</li><li>getFront()：从双端队列头部获得一个元素。如果双端队列为空，返回 -1。</li><li>getRear()：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1。</li><li>isEmpty()：检查双端队列是否为空。</li><li>isFull()：检查双端队列是否满了。</li></ul><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyCircularDeque circularDeque &#x3D; new MycircularDeque(3); &#x2F;&#x2F; 设置容量大小为3</span><br><span class="line">circularDeque.insertLast(1);			        &#x2F;&#x2F; 返回 true</span><br><span class="line">circularDeque.insertLast(2);			        &#x2F;&#x2F; 返回 true</span><br><span class="line">circularDeque.insertFront(3);			        &#x2F;&#x2F; 返回 true</span><br><span class="line">circularDeque.insertFront(4);			        &#x2F;&#x2F; 已经满了，返回 false</span><br><span class="line">circularDeque.getRear();  				&#x2F;&#x2F; 返回 2</span><br><span class="line">circularDeque.isFull();				        &#x2F;&#x2F; 返回 true</span><br><span class="line">circularDeque.deleteLast();			        &#x2F;&#x2F; 返回 true</span><br><span class="line">circularDeque.insertFront(4);			        &#x2F;&#x2F; 返回 true</span><br><span class="line">circularDeque.getFront();				&#x2F;&#x2F; 返回 4</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>所有值的范围为 [1, 1000]</li><li>操作次数的范围为 [1, 1000]</li><li>请不要使用内置的双端队列库。</li></ul><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>队列</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol><li>注意循环队列要对队列长度取余</li><li>多申请一个空间用于判断队列是否已满</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125; MyCircularDeque;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. Set the size of the deque to be k. */</span></span><br><span class="line"></span><br><span class="line"><span class="function">MyCircularDeque *<span class="title">myCircularDequeCreate</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyCircularDeque *obj = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyCircularDeque) * (k + <span class="number">1</span>));</span><br><span class="line">    obj-&gt;data = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (k + <span class="number">1</span>));</span><br><span class="line">    obj-&gt;front = <span class="number">0</span>;</span><br><span class="line">    obj-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    obj-&gt;length = k + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数声明，才能调用</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCircularDequeIsFull</span><span class="params">(MyCircularDeque *obj)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCircularDequeIsEmpty</span><span class="params">(MyCircularDeque *obj)</span></span>;</span><br><span class="line"><span class="comment">/** Adds an item at the front of Deque. Return true if the operation is successful. */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCircularDequeInsertFront</span><span class="params">(MyCircularDeque *obj, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (myCircularDequeIsFull(obj))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = (obj-&gt;front + obj-&gt;length - <span class="number">1</span>) % obj-&gt;length;</span><br><span class="line">    obj-&gt;data[pos] = value;</span><br><span class="line">    obj-&gt;front = pos;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Adds an item at the rear of Deque. Return true if the operation is successful. */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCircularDequeInsertLast</span><span class="params">(MyCircularDeque *obj, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (myCircularDequeIsFull(obj))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    obj-&gt;data[obj-&gt;rear] = value;</span><br><span class="line">    obj-&gt;rear = (obj-&gt;rear + <span class="number">1</span>) % obj-&gt;length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Deletes an item from the front of Deque. Return true if the operation is successful. */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCircularDequeDeleteFront</span><span class="params">(MyCircularDeque *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (myCircularDequeIsEmpty(obj))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    obj-&gt;front = (obj-&gt;front + <span class="number">1</span>) % obj-&gt;length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Deletes an item from the rear of Deque. Return true if the operation is successful. */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCircularDequeDeleteLast</span><span class="params">(MyCircularDeque *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (myCircularDequeIsEmpty(obj))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    obj-&gt;rear = (obj-&gt;rear - <span class="number">1</span> + obj-&gt;length) % obj-&gt;length;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get the front item from the deque. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myCircularDequeGetFront</span><span class="params">(MyCircularDeque *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (myCircularDequeIsEmpty(obj))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;data[obj-&gt;front];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get the last item from the deque. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myCircularDequeGetRear</span><span class="params">(MyCircularDeque *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (myCircularDequeIsEmpty(obj))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = (obj-&gt;rear + obj-&gt;length - <span class="number">1</span>) % obj-&gt;length;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;data[pos];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Checks whether the circular deque is empty or not. */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCircularDequeIsEmpty</span><span class="params">(MyCircularDeque *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;front == obj-&gt;rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Checks whether the circular deque is full or not. */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCircularDequeIsFull</span><span class="params">(MyCircularDeque *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;front == (obj-&gt;rear + <span class="number">1</span>) % obj-&gt;length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myCircularDequeFree</span><span class="params">(MyCircularDeque *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyCircularDeque struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyCircularDeque* obj = myCircularDequeCreate(k);</span></span><br><span class="line"><span class="comment"> * bool param_1 = myCircularDequeInsertFront(obj, value);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * bool param_2 = myCircularDequeInsertLast(obj, value);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * bool param_3 = myCircularDequeDeleteFront(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * bool param_4 = myCircularDequeDeleteLast(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_5 = myCircularDequeGetFront(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_6 = myCircularDequeGetRear(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * bool param_7 = myCircularDequeIsEmpty(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * bool param_8 = myCircularDequeIsFull(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * myCircularDequeFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>design</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title>933.最近的请求次数</title>
    <url>/2020/03/08/933.%E6%9C%80%E8%BF%91%E7%9A%84%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>写一个 <code>RecentCounter</code> 类来计算最近的请求。</p><p>它只有一个方法：<code>ping(int t)</code>，其中 <code>t</code> 代表以毫秒为单位的某个时间。</p><p>返回从 3000 毫秒前到现在的 <code>ping</code> 数。</p><p>任何处于 <code>[t - 3000, t]</code> 时间范围之内的 <code>ping</code> 都将会被计算在内，包括当前（指 <code>t</code> 时刻）的 <code>ping</code>。</p><p>保证每次对 <code>ping</code> 的调用都使用比之前更大的 <code>t</code> 值。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：inputs &#x3D; [&quot;RecentCounter&quot;,&quot;ping&quot;,&quot;ping&quot;,&quot;ping&quot;,&quot;ping&quot;], inputs &#x3D; [[],[1],[100],[3001],[3002]]</span><br><span class="line">输出：[null,1,2,3,3]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>每个测试用例最多调用 <code>10000</code> 次 <code>ping</code>。</li><li>每个测试用例会使用严格递增的 <code>t</code> 值来调用 <code>ping</code>。</li><li>每次调用 <code>ping</code> 都有 <code>1 &lt;= t &lt;= 10^9</code>。</li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>队列</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol><li>扫描数组，逐一进队</li><li>当队头元素 &lt; 队尾元素时，出队</li><li>返回当前队伍长度</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 100000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *<span class="built_in">queue</span>;</span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line"></span><br><span class="line">&#125; RecentCounter;</span><br><span class="line"></span><br><span class="line"><span class="function">RecentCounter *<span class="title">recentCounterCreate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RecentCounter *rt = (RecentCounter *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(RecentCounter));</span><br><span class="line">    rt-&gt;<span class="built_in">queue</span> = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(maxSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">memset</span>(rt-&gt;<span class="built_in">queue</span>, <span class="number">-1</span>, maxSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    rt-&gt;front = <span class="number">0</span>;</span><br><span class="line">    rt-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recentCounterPing</span><span class="params">(RecentCounter *obj, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj-&gt;rear = (obj-&gt;rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">    obj-&gt;<span class="built_in">queue</span>[obj-&gt;rear] = t;</span><br><span class="line">    <span class="keyword">while</span> (obj-&gt;<span class="built_in">queue</span>[obj-&gt;front + <span class="number">1</span>] &lt; t - <span class="number">3000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        obj-&gt;front = (obj-&gt;front + <span class="number">1</span>) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;rear - obj-&gt;front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recentCounterFree</span><span class="params">(RecentCounter *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(obj-&gt;<span class="built_in">queue</span>);</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RecentCounter struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RecentCounter* obj = recentCounterCreate();</span></span><br><span class="line"><span class="comment"> * int param_1 = recentCounterPing(obj, t);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * recentCounterFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title>1017.负二进制转换</title>
    <url>/2020/03/05/1017.%E8%B4%9F%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给出数字 <code>N</code>，返回由若干 <code>&quot;0&quot;</code> 和 <code>&quot;1&quot;</code>组成的字符串，该字符串为 <code>N</code> 的<strong>负二进制（<code>base -2</code>）</strong>表示。</p><p>除非字符串就是 <code>&quot;0&quot;</code>，否则返回的字符串中不能含有前导零。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：2</span><br><span class="line">输出：&quot;110&quot;</span><br><span class="line">解释：(-2) ^ 2 + (-2) ^ 1 &#x3D; 2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：&quot;111&quot;</span><br><span class="line">解释：(-2) ^ 2 + (-2) ^ 1 + (-2) ^ 0 &#x3D; 3</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：4</span><br><span class="line">输出：&quot;100&quot;</span><br><span class="line">解释：(-2) ^ 2 &#x3D; 4</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>0 &lt;= N &lt;= 10^9</code></li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>栈+二进制转化的变形</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><p>这道题是<strong>负二进制转换</strong></p><p>我们先回忆一下二进制转换：</p><ol><li>对给定的整数<strong>N</strong>进行短除，将余数压入栈中，</li><li>当最后除数为一时，停止短除，并将最后的一压入栈中，</li><li>最后将栈反转过来即可。</li></ol><p>参考这一过程，我们可以基本捋清楚负二进制转换的过程：</p><ol><li>对给定的整数<strong>N</strong>进行短除，将余数压入栈中，但是，我们会发现：余数可能为<strong>-1</strong>，所以我们对这个余数进行特殊处理，令其为一，此时的<code>N = (N - 1) / -2</code></li><li>二三步不变</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize __INT16_MAX__</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">baseNeg2</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span>[maxSize];</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (N != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mod = N % <span class="number">-2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mod &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mod = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">stack</span>[++top] = mod;</span><br><span class="line">            N = (N - <span class="number">1</span>) / <span class="number">-2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">stack</span>[++top] = mod;</span><br><span class="line">            N = N / <span class="number">-2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stack</span>[++top] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *res = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(maxSize * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (top != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res[i++] = <span class="built_in">stack</span>[top--] + <span class="string">'0'</span>;<span class="comment">//将数字转换为字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    res[i++] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>dynamic-programming</tag>
        <tag>stack</tag>
        <tag>ordered-map</tag>
      </tags>
  </entry>
  <entry>
    <title>739.每日温度</title>
    <url>/2020/03/05/739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>根据每日 <code>气温</code> 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 <code>0</code> 来代替。</p><p>例如，给定一个列表 <code>temperatures = [73, 74, 75, 71, 69, 72, 76, 73]</code>，你的输出应该是 <code>[1, 1, 4, 2, 1, 1, 0, 0]</code>。</p><p><strong>提示：</strong><code>气温</code> 列表长度的范围是 <code>[1, 30000]</code>。每个气温的值的均为华氏度，都是在 <code>[30, 100]</code> 范围内的整数。</p><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>暴力法：循环遍历，不再赘述</li><li>栈</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><p>这道题使用栈的解法：参考<a href="https://leetcode-cn.com/u/jalan/" target="_blank" rel="noopener">江不知</a>的评论</p><ol><li>声明一个<strong>存放索引</strong>的辅助栈</li><li>先将<code>T[0]</code>压入栈中</li><li>从<code>T[1]</code>开始遍历<ol><li>当辅助栈不为空时，辅助栈中的索引对应的元素小于待入栈元素时，令<code>res[栈顶索引] = i - 栈顶索引</code>，并出栈</li><li>否则，辅助栈中的索引对应的元素大于待入栈元素，入栈即可</li></ol></li><li>当辅助栈不为空时，说明：之后都不会升高，在该位置用 <code>0</code> 来代替。</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">dailyTemperatures</span><span class="params">(<span class="keyword">int</span> *T, <span class="keyword">int</span> TSize, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *res = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(TSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span>[TSize];</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>[++top] = i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; TSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (top != <span class="number">-1</span> &amp;&amp; T[<span class="built_in">stack</span>[top]] &lt; T[i])</span><br><span class="line">        &#123;</span><br><span class="line">            res[<span class="built_in">stack</span>[top]] = i - <span class="built_in">stack</span>[top];</span><br><span class="line">            top--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">stack</span>[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (top != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res[<span class="built_in">stack</span>[top]] = <span class="number">0</span>;</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = TSize;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个解法就很巧妙了，时空复杂度为O(n)，比暴力法要好一点，然而我只想到了暴力法……</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>stack</tag>
        <tag>hash-table</tag>
      </tags>
  </entry>
  <entry>
    <title>456.132模式</title>
    <url>/2020/03/04/456.132%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个整数序列：a1, a2, …, an，一个132模式的子序列 a<strong>i</strong>, a<strong>j</strong>, a<strong>k</strong> 被定义为：当 <strong>i</strong> &lt; <strong>j</strong> &lt; <strong>k</strong> 时，a<strong>i</strong> &lt; a<strong>k</strong> &lt; a<strong>j</strong>。设计一个算法，当给定有 n 个数字的序列时，验证这个序列中是否含有132模式的子序列。</p><p><strong>注意：</strong>n 的值小于15000。</p><p><strong>示例1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">输出: False</span><br><span class="line"></span><br><span class="line">解释: 序列中不存在132模式的子序列。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3, 1, 4, 2]</span><br><span class="line"></span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">解释: 序列中有 1 个132模式的子序列： [1, 4, 2].</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [-1, 3, 2, 0]</span><br><span class="line"></span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">解释: 序列中有 3 个132模式的的子序列: [-1, 3, 2], [-1, 3, 0] 和 [-1, 2, 0].</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>栈的应用</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><p>参考<a href="https://leetcode-cn.com/problems/132-pattern/solution/132mo-shi-by-leetcode-2/" target="_blank" rel="noopener">官解</a></p><ol><li>为了便于分析，我们约定：<ul><li>“1”：小</li><li>“3”：大</li><li>“2”：中</li></ul></li><li>首先考虑<code>小 &lt; 大</code>的情况，我们可以维护一个前缀最小值的数组<code>min[]</code>，这样，<code>小 &lt; 大</code>便是最优解</li><li>其次考虑<code>大 &gt; 中</code>的情况，我们需要申请一个栈，从后向前遍历数组，<ol><li>当<code>nums[j] &gt; min[j]</code>时，将<code>nums[j]</code>进栈</li><li>如果栈不为空，并且<code>nums[j] &gt; stack[top]</code>时，我们就找到了我们需要的<code>中</code>，返回<code>true</code>；</li><li>如果栈不为空，但是<code>min[j] &gt;= stack[top]</code>时，我们就需要一直出栈，直到找到我们所需要的<code>中</code></li></ol></li><li>如果遍历完整个数组，都没有找到，则返回<code>false</code></li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find132pattern</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize &lt; <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//min[]</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">min</span>[numsSize];</span><br><span class="line">    <span class="built_in">min</span>[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; numsSize; i++)</span><br><span class="line">        <span class="built_in">min</span>[i] = <span class="built_in">min</span>[i - <span class="number">1</span>] &lt; nums[i] ? <span class="built_in">min</span>[i - <span class="number">1</span>] : nums[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span>[numsSize];</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = numsSize - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &gt; <span class="built_in">min</span>[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (top != <span class="number">-1</span> &amp;&amp; <span class="built_in">min</span>[j] &gt;= <span class="built_in">stack</span>[top])</span><br><span class="line">                top--;</span><br><span class="line">            <span class="keyword">if</span> (top != <span class="number">-1</span> &amp;&amp; nums[j] &gt; <span class="built_in">stack</span>[top])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">stack</span>[++top] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>503.下一个更大元素 II</title>
    <url>/2020/03/04/503.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%20II/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,1]</span><br><span class="line">输出: [2,-1,2]</span><br><span class="line">解释: 第一个 1 的下一个更大的数是 2；</span><br><span class="line">数字 2 找不到下一个更大的数； </span><br><span class="line">第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 输入数组的长度不会超过 10000。</p><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>for循环遍历</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><p>和其第一题一样，我还是没有使用stack</p><ol><li>构造一个可以：不管从什么位置开始，都可以遍历整个数组的for循环</li><li>使用循环嵌套遍历整个数组</li><li>能找到下一个更大的数，则赋值；否则，令其值为 -1</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">nextGreaterElements</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> *res = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(numsSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = (i + <span class="number">1</span>) % numsSize; j != i; j = (j + <span class="number">1</span>) % numsSize)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                res[(*returnSize)++] = nums[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res[i] != nums[j])</span><br><span class="line">            res[(*returnSize)++] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>331.验证二叉树的前序序列化</title>
    <url>/2020/03/03/331.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 <code>#</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     _9_</span><br><span class="line">    &#x2F;   \</span><br><span class="line">   3     2</span><br><span class="line">  &#x2F; \   &#x2F; \</span><br><span class="line"> 4   1  #  6</span><br><span class="line">&#x2F; \ &#x2F; \   &#x2F; \</span><br><span class="line"># # # #   # #</span><br></pre></td></tr></table></figure><p>例如，上面的二叉树可以被序列化为字符串 <code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code>，其中 <code>#</code> 代表一个空节点。</p><p>给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。</p><p>每个以逗号分隔的字符或为一个整数或为一个表示 <code>null</code> 指针的 <code>&#39;#&#39;</code> 。</p><p>你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 <code>&quot;1,,3&quot;</code> 。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;1,#&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;9,#,#,1&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>栈、字符串切割</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol><li>将字符串以<code>,</code>切割</li><li>将子字符串逐一进栈</li><li>当栈顶元素与次栈顶元素都为<code>#</code>时，连出三次栈，并将<code>#</code>压入栈中</li><li>在遍历字符串的过程中，如果栈恰好为空，且<strong>子字符串为空</strong>时，说明符合要求，返回true；</li><li>在遍历字符串的过程中，如果栈恰好为空，且<strong>子字符串不为空</strong>时，说明不符合要求，返回false；</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 1024</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *data[maxSize];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125; <span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidSerialization</span><span class="params">(<span class="keyword">char</span> *preorder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preorder[<span class="number">0</span>] == <span class="string">'#'</span> &amp;&amp; preorder[<span class="number">1</span>] == <span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (preorder[<span class="number">0</span>] == <span class="string">'#'</span> &amp;&amp; preorder[<span class="number">1</span>] != <span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">stack</span> *st = (<span class="built_in">stack</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">stack</span>));</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; maxSize; i++)</span><br><span class="line">        st-&gt;data[i] = <span class="literal">NULL</span>;</span><br><span class="line">    st-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//切割字符串</span></span><br><span class="line">    <span class="keyword">char</span> *str = preorder;</span><br><span class="line">    <span class="keyword">char</span> delim[<span class="number">2</span>] = <span class="string">","</span>;</span><br><span class="line">    <span class="keyword">char</span> *token = <span class="literal">NULL</span>;</span><br><span class="line">    token = strtok(str, delim);</span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="keyword">char</span> ship[<span class="number">2</span>] = <span class="string">"#"</span>;</span><br><span class="line">    <span class="keyword">while</span> (token != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        st-&gt;data[++st-&gt;top] = token;</span><br><span class="line">        token = strtok(<span class="literal">NULL</span>, delim);</span><br><span class="line">        <span class="keyword">while</span> (st-&gt;data[st-&gt;top][<span class="number">0</span>] == <span class="string">'#'</span> &amp;&amp; st-&gt;data[st-&gt;top - <span class="number">1</span>][<span class="number">0</span>] == <span class="string">'#'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            st-&gt;data[st-&gt;top--] = <span class="literal">NULL</span>;</span><br><span class="line">            st-&gt;data[st-&gt;top--] = <span class="literal">NULL</span>;</span><br><span class="line">            st-&gt;data[st-&gt;top--] = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span> (st-&gt;top == <span class="number">-1</span> &amp;&amp; token != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (st-&gt;top == <span class="number">-1</span> &amp;&amp; token == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            st-&gt;data[++st-&gt;top] = ship;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>144.二叉树的前序遍历</title>
    <url>/2020/03/02/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个二叉树，返回它的 <em>前序</em> 遍历。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [1,2,3]</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>递归</li><li>迭代</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><p>这里主要说一下迭代法：</p><ol><li>先序遍历的顺序：根节点 -&gt; 左孩子 -&gt; 右孩子</li><li>首先需要声明一个辅助栈，</li><li>先访问根节点，并将其val存到数组中</li><li>接下来该访问左孩子，由于栈是<strong>FILO</strong>，所以遍历时要先让右孩子入栈，才能让左孩子先出栈</li><li>循环这个过程，直至遍历全部节点</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><ol><li><p>递归</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *arr, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[(*returnSize)++] = root-&gt;val;</span><br><span class="line">        visit(root-&gt;left, arr, returnSize);</span><br><span class="line">        visit(root-&gt;right, arr, returnSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">preorderTraversal</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">1000</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    visit(root, arr, returnSize);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>迭代</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 1000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">preorderTraversal</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(maxSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">stack</span>[<span class="title">maxSize</span>], *<span class="title">p</span> = <span class="title">root</span>;</span></span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">stack</span>[++top] = p;</span><br><span class="line">    <span class="keyword">while</span> (top != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = <span class="built_in">stack</span>[top--];</span><br><span class="line">        arr[(*returnSize)++] = p-&gt;val;</span><br><span class="line">        <span class="comment">//stack is FILO,so the preOrder push the rchild into the stack first</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">stack</span>[++top] = p-&gt;right;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">stack</span>[++top] = p-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>145.二叉树的后序遍历</title>
    <url>/2020/03/02/145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个二叉树，返回它的 <em>后序</em> 遍历。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [3,2,1]</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>递归</li><li>迭代</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><p>这里主要说一下迭代法：</p><ol><li>先序遍历的顺序：左孩子 -&gt; 右孩子 -&gt; 根节点；</li><li>我们可以与先序遍历对比一下：<ul><li>先序遍历的顺序：根节点 -&gt; 左孩子 -&gt; 右孩子</li><li>先序遍历的顺序：左孩子 -&gt; 右孩子 -&gt; 根节点</li></ul></li><li>我们可以发现：<strong>后序遍历是先序遍历的逆序序列</strong>，利用这一性质，我们进行后续遍历操作</li><li>这里我们需要两个辅助栈</li><li>首先，我们按照先序遍历的方式遍历整颗二叉树，并将遍历结果存入栈1中；</li><li>然后，再将栈1中的结果全部出栈，并存入数组中即可。</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><ol><li><p>递归</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *arr, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root)</span><br><span class="line">    &#123;</span><br><span class="line">        visit(root-&gt;left, arr, returnSize);</span><br><span class="line">        arr[(*returnSize)++] = root-&gt;val;</span><br><span class="line">        visit(root-&gt;right, arr, returnSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">inorderTraversal</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">1000</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    visit(root, arr, returnSize);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>迭代</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 1000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">postorderTraversal</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(maxSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">Stack1</span>[<span class="title">maxSize</span>];</span></span><br><span class="line">    <span class="keyword">int</span> top1 = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">Stack2</span>[<span class="title">maxSize</span>];</span></span><br><span class="line">    <span class="keyword">int</span> top2 = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">p</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    Stack1[++top1] = root;</span><br><span class="line">    <span class="keyword">while</span> (top1 != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = Stack1[top1--];</span><br><span class="line">        Stack2[++top2] = p;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            Stack1[++top1] = p-&gt;left;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            Stack1[++top1] = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//the stack2 push is the postOrderNonRecursion</span></span><br><span class="line">    <span class="keyword">while</span> (top2 != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = Stack2[top2--];</span><br><span class="line">        arr[(*returnSize)++] = p-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>150.逆波兰表达式求值</title>
    <url>/2020/03/02/150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>根据<a href="https://baike.baidu.com/item/逆波兰式/128437" target="_blank" rel="noopener">逆波兰表示法</a>，求表达式的值。</p><p>有效的运算符包括 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p><strong>说明：</strong></p><ul><li>整数除法只保留整数部分。</li><li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]</span><br><span class="line">输出: 9</span><br><span class="line">解释: ((2 + 1) * 3) &#x3D; 9</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;&#x2F;&quot;, &quot;+&quot;]</span><br><span class="line">输出: 6</span><br><span class="line">解释: (4 + (13 &#x2F; 5)) &#x3D; 6</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;&#x2F;&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]</span><br><span class="line">输出: 22</span><br><span class="line">解释: </span><br><span class="line">  ((10 * (6 &#x2F; ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">&#x3D; ((10 * (6 &#x2F; (12 * -11))) + 17) + 5</span><br><span class="line">&#x3D; ((10 * (6 &#x2F; -132)) + 17) + 5</span><br><span class="line">&#x3D; ((10 * 0) + 17) + 5</span><br><span class="line">&#x3D; (0 + 17) + 5</span><br><span class="line">&#x3D; 17 + 5</span><br><span class="line">&#x3D; 22</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>栈的简单应用</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol><li>注意将字符串负数转化为整数类型时，注意特殊处理</li><li>遇到操作符时，连出两次栈，并将计算结果入栈</li><li>否则，遇到字符串数字，转化为整数类型后，入栈</li><li>最后栈顶元素即为结果</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125; <span class="built_in">stack</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stoi</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">'-'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="built_in">strlen</span>(str); i++)</span><br><span class="line">            res = res * <span class="number">10</span> + (str[i] - <span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> - res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); i++)</span><br><span class="line">        res = res * <span class="number">10</span> + (str[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="keyword">char</span> **tokens, <span class="keyword">int</span> tokensSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span> *st = (<span class="built_in">stack</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">stack</span>));</span><br><span class="line">    st-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(tokensSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    st-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tokensSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tokens[i][<span class="number">0</span>] == <span class="string">'+'</span> &amp;&amp; tokens[i][<span class="number">1</span>] == <span class="string">'\0'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            b = st-&gt;data[st-&gt;top--];</span><br><span class="line">            a = st-&gt;data[st-&gt;top--];</span><br><span class="line">            st-&gt;data[++st-&gt;top] = a + b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tokens[i][<span class="number">0</span>] == <span class="string">'-'</span> &amp;&amp; tokens[i][<span class="number">1</span>] == <span class="string">'\0'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            b = st-&gt;data[st-&gt;top--];</span><br><span class="line">            a = st-&gt;data[st-&gt;top--];</span><br><span class="line">            st-&gt;data[++st-&gt;top] = a - b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tokens[i][<span class="number">0</span>] == <span class="string">'*'</span> &amp;&amp; tokens[i][<span class="number">1</span>] == <span class="string">'\0'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            b = st-&gt;data[st-&gt;top--];</span><br><span class="line">            a = st-&gt;data[st-&gt;top--];</span><br><span class="line">            st-&gt;data[++st-&gt;top] = a * b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tokens[i][<span class="number">0</span>] == <span class="string">'/'</span> &amp;&amp; tokens[i][<span class="number">1</span>] == <span class="string">'\0'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            b = st-&gt;data[st-&gt;top--];</span><br><span class="line">            a = st-&gt;data[st-&gt;top--];</span><br><span class="line">            st-&gt;data[++st-&gt;top] = a / b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            st-&gt;data[++st-&gt;top] = stoi(tokens[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st-&gt;data[st-&gt;top];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码有点复杂了，将就着看😜</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>173.二叉搜索树迭代器</title>
    <url>/2020/03/02/173.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。</p><p>调用 <code>next()</code> 将返回二叉搜索树中的下一个最小的数。</p><p><strong>示例：</strong></p><p><img src="https://i.loli.net/2020/03/02/Zj1g8fKkXOe4PLD.png" alt="bst-tree.png"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BSTIterator iterator &#x3D; new BSTIterator(root);</span><br><span class="line">iterator.next();    &#x2F;&#x2F; 返回 3</span><br><span class="line">iterator.next();    &#x2F;&#x2F; 返回 7</span><br><span class="line">iterator.hasNext(); &#x2F;&#x2F; 返回 true</span><br><span class="line">iterator.next();    &#x2F;&#x2F; 返回 9</span><br><span class="line">iterator.hasNext(); &#x2F;&#x2F; 返回 true</span><br><span class="line">iterator.next();    &#x2F;&#x2F; 返回 15</span><br><span class="line">iterator.hasNext(); &#x2F;&#x2F; 返回 true</span><br><span class="line">iterator.next();    &#x2F;&#x2F; 返回 20</span><br><span class="line">iterator.hasNext(); &#x2F;&#x2F; 返回 false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>next()</code> 和 <code>hasNext()</code> 操作的时间复杂度是 O(1)，并使用 O(<em>h</em>) 内存，其中 <em>h</em> 是树的高度。</li><li>你可以假设 <code>next()</code> 调用总是有效的，也就是说，当调用 <code>next()</code> 时，BST 中至少存在一个下一个最小的数。</li></ul><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>二叉搜索树的遍历问题、二叉树的中序遍历</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol><li>将给定的二叉搜索树进行中序遍历，可以得到一个升序数组</li><li>遍历数组即可。</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize __INT16_MAX__</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">&#125; BSTIterator;</span><br><span class="line"></span><br><span class="line"><span class="function">BSTIterator *<span class="title">bSTIteratorCreate</span><span class="params">(struct TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    BSTIterator *bsti = (BSTIterator *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTIterator));</span><br><span class="line">    bsti-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(maxSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    bsti-&gt;top = <span class="number">0</span>;</span><br><span class="line">    bsti-&gt;index = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">p</span> = <span class="title">root</span>, *<span class="title">stack</span>[<span class="title">maxSize</span>];</span></span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (top != <span class="number">-1</span> || p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">stack</span>[++top] = p;</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        p = <span class="built_in">stack</span>[top--];</span><br><span class="line">        bsti-&gt;data[bsti-&gt;top++] = p-&gt;val;</span><br><span class="line">        p = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bsti;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** @return the next smallest number */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bSTIteratorNext</span><span class="params">(BSTIterator *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;data[obj-&gt;index++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** @return whether we have a next smallest number */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bSTIteratorHasNext</span><span class="params">(BSTIterator *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;index &lt; obj-&gt;top)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bSTIteratorFree</span><span class="params">(BSTIterator *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BSTIterator struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * BSTIterator* obj = bSTIteratorCreate(root);</span></span><br><span class="line"><span class="comment"> * int param_1 = bSTIteratorNext(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * bool param_2 = bSTIteratorHasNext(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * bSTIteratorFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>stack</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title>94.二叉树的中序遍历</title>
    <url>/2020/03/02/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个二叉树，返回它的<em>中序</em> 遍历。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">输出: [1,3,2]</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>递归</li><li>迭代</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><p>这里主要说一下迭代法：</p><ol><li>中序遍历的顺序：左孩子 -&gt; 根节点 -&gt; 右孩子</li><li>首先需要声明一个辅助栈，</li><li>先访问左孩子，由于这是一个类似递归的过程，所以要一直沿着左孩子的方向一直向左下遍历，并将节点压入栈中；</li><li>找到整颗二叉树中最左下的孩子后，将其val存到数组中</li><li>接下来该访问根节点，继续出栈，即可得到根节点</li><li>然后在访问根节点的右孩子</li><li>循环这个过程，直至遍历全部节点</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><ol><li><p>递归</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *arr, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root)</span><br><span class="line">    &#123;</span><br><span class="line">        visit(root-&gt;left, arr, returnSize);</span><br><span class="line">        arr[(*returnSize)++] = root-&gt;val;</span><br><span class="line">        visit(root-&gt;right, arr, returnSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">inorderTraversal</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">1000</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    visit(root, arr, returnSize);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>迭代</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 1000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">inorderTraversal</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(maxSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">stack</span>[<span class="title">maxSize</span>], *<span class="title">p</span> = <span class="title">root</span>;</span></span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//the Stack may be empty in the process,</span></span><br><span class="line">    <span class="comment">//so the condition that p != NULL can keep the loop continue</span></span><br><span class="line">    <span class="keyword">while</span> (top != <span class="number">-1</span> || p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">stack</span>[++top] = p;</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        p = <span class="built_in">stack</span>[top--];</span><br><span class="line">        arr[(*returnSize)++] = p-&gt;val;</span><br><span class="line">        p = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>71.简化路径</title>
    <url>/2020/03/01/71.%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>以 Unix 风格给出一个文件的<strong>绝对路径</strong>，你需要简化它。或者换句话说，将其转换为规范路径。</p><p>在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：<a href="https://blog.csdn.net/u011327334/article/details/50355600" target="_blank" rel="noopener">Linux / Unix中的绝对路径 vs 相对路径</a></p><p>请注意，返回的规范路径必须始终以斜杠 <code>/</code> 开头，并且两个目录名之间必须只有一个斜杠 <code>/</code>。最后一个目录名（如果存在）<strong>不能</strong>以 <code>/</code> 结尾。此外，规范路径必须是表示绝对路径的<strong>最短</strong>字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;&#x2F;home&#x2F;&quot;</span><br><span class="line">输出：&quot;&#x2F;home&quot;</span><br><span class="line">解释：注意，最后一个目录名后面没有斜杠。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;&#x2F;..&#x2F;&quot;</span><br><span class="line">输出：&quot;&#x2F;&quot;</span><br><span class="line">解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;&#x2F;home&#x2F;&#x2F;foo&#x2F;&quot;</span><br><span class="line">输出：&quot;&#x2F;home&#x2F;foo&quot;</span><br><span class="line">解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;&#x2F;a&#x2F;.&#x2F;b&#x2F;..&#x2F;..&#x2F;c&#x2F;&quot;</span><br><span class="line">输出：&quot;&#x2F;c&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;&#x2F;a&#x2F;..&#x2F;..&#x2F;b&#x2F;..&#x2F;c&#x2F;&#x2F;.&#x2F;&#x2F;&quot;</span><br><span class="line">输出：&quot;&#x2F;c&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 6：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;&#x2F;a&#x2F;&#x2F;b&#x2F;&#x2F;&#x2F;&#x2F;c&#x2F;d&#x2F;&#x2F;.&#x2F;.&#x2F;&#x2F;..&quot;</span><br><span class="line">输出：&quot;&#x2F;a&#x2F;b&#x2F;c&quot;</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>字符串遍历、栈的应用</li><li>字符串切割、栈的应用</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><p>法一：</p><ol><li>逐个遍历字符串</li><li>遇到<code>.</code>不变</li><li>遇到<code>..</code>出栈</li><li>遇到<code>/</code>或其他字符时进栈</li></ol><p>​ 这是我第一次想出来的算法，后来遇到了这个测试用例：<code>&quot;/...&quot;</code>,其期望答案居然还是：<code>&quot;/...&quot;</code>。靠，我太难了！😥看了题解之后，发现C语言也有字符串切割的函数，就在<code>string.h</code>这个库里，我心一横，换方法了！</p><p>法二：</p><ol><li>使用<code>strtok()</code>函数，将字符串进行切割</li><li>因为每次切割返回的都是指针，所以我声明了一个指针数组</li><li>将切割出的子字符串的指针压入指针数组中</li><li>然后遍历指针数组</li><li>组合出最终的字符串</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>法一：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">simplifyPath</span><span class="params">(<span class="keyword">char</span> *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(path);</span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">stack</span> = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">stack</span>[++top] = <span class="string">'/'</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (path[i] == <span class="string">'.'</span> &amp;&amp; path[i + <span class="number">1</span>] == <span class="string">'.'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                top = top == <span class="number">0</span> ? <span class="number">0</span> : top - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (<span class="built_in">stack</span>[top] != <span class="string">'/'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (path[i] == <span class="string">'.'</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (path[i] == <span class="string">'/'</span> &amp;&amp; <span class="built_in">stack</span>[top] == <span class="string">'/'</span>)<span class="comment">//防止连续的'/'</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">stack</span>[++top] = path[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span>[top] == <span class="string">'/'</span> &amp;&amp; top &gt; <span class="number">0</span>)</span><br><span class="line">        top--;</span><br><span class="line">    <span class="built_in">stack</span>[++top] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, <span class="built_in">stack</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>法二：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.按照 / 切割字符串</span></span><br><span class="line"><span class="comment">2.遇到 . continue</span></span><br><span class="line"><span class="comment">3.遇到 .. 出栈</span></span><br><span class="line"><span class="comment">4.遇到 字母 进栈，并且进一个 /</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 1024</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *data[maxSize];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125; <span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">simplifyPath</span><span class="params">(<span class="keyword">char</span> *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span> *st = (<span class="built_in">stack</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">stack</span>));</span><br><span class="line">    <span class="comment">//初始化指针数组，这点很重要</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">for</span> (u = <span class="number">0</span>; u &lt; maxSize; u++)</span><br><span class="line">        st-&gt;data[u] = <span class="literal">NULL</span>;</span><br><span class="line">    st-&gt;top = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *str = path;</span><br><span class="line">    <span class="keyword">char</span> delim[<span class="number">2</span>] = <span class="string">"/"</span>;</span><br><span class="line">    <span class="keyword">char</span> *token = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//切割字符串</span></span><br><span class="line">    token = strtok(str, delim);</span><br><span class="line">    st-&gt;data[++st-&gt;top] = delim;</span><br><span class="line">    <span class="comment">// . 无操作</span></span><br><span class="line">    <span class="comment">// .. 连出两次栈</span></span><br><span class="line">    <span class="keyword">while</span> (token != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (token[<span class="number">0</span>] == <span class="string">'.'</span> &amp;&amp; token[<span class="number">1</span>] == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (token[<span class="number">0</span>] == <span class="string">'.'</span> &amp;&amp; token[<span class="number">1</span>] == <span class="string">'.'</span> &amp;&amp; token[<span class="number">2</span>] == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">if</span> (st-&gt;top &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                st-&gt;data[st-&gt;top--] = <span class="literal">NULL</span>;</span><br><span class="line">                st-&gt;data[st-&gt;top--] = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                st-&gt;top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            st-&gt;data[++st-&gt;top] = token;</span><br><span class="line">            st-&gt;data[++st-&gt;top] = delim;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到下一个子字符串的指针</span></span><br><span class="line">        token = strtok(<span class="literal">NULL</span>, delim);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历指针数组所对应的字符串，将其组合成想要的字符串</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">char</span> *res = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(maxSize * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; st-&gt;data[i] != <span class="literal">NULL</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="built_in">strlen</span>(st-&gt;data[i]); j++)</span><br><span class="line">            res[++k] = st-&gt;data[i][j];</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>)</span><br><span class="line">        res[++k] = <span class="string">'\0'</span>;</span><br><span class="line">    res[k] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码写的稀烂，枯了😥</p><h2 id="三、PS"><a href="#三、PS" class="headerlink" title="三、PS"></a>三、PS</h2><p>使用了新的库函数：<code>strtok()</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strtok</span><span class="params">(<span class="keyword">char</span> *__restrict__ _Str, <span class="keyword">const</span> <span class="keyword">char</span> *__restrict__ _Delim)</span></span></span><br></pre></td></tr></table></figure><ul><li>char *<strong>restrict</strong> _Str: 待切割的字符串</li><li>const char *<strong>restrict</strong> _Delim：包含分隔符的 C 字符串</li></ul><p>使用<code>strtok()</code>：</p><blockquote><p>菜鸟教程</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">char</span> str[<span class="number">80</span>] = <span class="string">"This is - www.runoob.com - website"</span>;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> s[<span class="number">2</span>] = <span class="string">"-"</span>;</span><br><span class="line">   <span class="keyword">char</span> *token;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 获取第一个子字符串 */</span></span><br><span class="line">   token = strtok(str, s);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 继续获取其他的子字符串 */</span></span><br><span class="line">   <span class="keyword">while</span>( token != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">      <span class="built_in">printf</span>( <span class="string">"%s\n"</span>, token );</span><br><span class="line">    </span><br><span class="line">      token = strtok(<span class="literal">NULL</span>, s);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>stack</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言递归的那点事</title>
    <url>/2020/03/01/C%E8%AF%AD%E8%A8%80%E9%80%92%E5%BD%92%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h1 id="浅析递归"><a href="#浅析递归" class="headerlink" title="浅析递归"></a>浅析递归</h1><p>​ 递归是一种绝大多数语言都支持的编程方式。但是我本人并不建议使用。</p><h2 id="1-是什么？"><a href="#1-是什么？" class="headerlink" title="1.是什么？"></a>1.是什么？</h2><h3 id="1-1-释义"><a href="#1-1-释义" class="headerlink" title="1.1 释义"></a>1.1 释义</h3><p>​ 允许函数循环调用自己的过程</p><h3 id="1-2-原理"><a href="#1-2-原理" class="headerlink" title="1.2 原理"></a>1.2 原理</h3><ol><li>每级函数调用都有自己的变量</li><li>每次函数调用都会返回一次</li><li>递归函数中位于递归调用之前的语句顺序执行</li><li>递归函数中位于递归调用之后的语句逆序执行</li><li>每级递归都有自己的变量，但并不会拷贝函数代码</li><li><strong>递归函数必须有让递归调用停止的语句，否则将无限递归</strong></li></ol><h2 id="2-为什么？"><a href="#2-为什么？" class="headerlink" title="2.为什么？"></a>2.为什么？</h2><h3 id="2-1-优点"><a href="#2-1-优点" class="headerlink" title="2.1 优点"></a>2.1 优点</h3><p>​ 递归的代码简洁优雅。繁杂的执行过程交由操作系统辅助解决。</p><h3 id="2-2-缺点"><a href="#2-2-缺点" class="headerlink" title="2.2 缺点"></a>2.2 缺点</h3><p>​ 相较于其优点，缺点更加显而易见，由于函数每次递归调用自己时，操作系统都要为其保留函数的运行现场（俗称系统栈），这种系统级的开销会浪费较多的资源，因而代码的效率并不高。而且还不方便人们的阅读，难以理解。</p><h2 id="3-怎么做？"><a href="#3-怎么做？" class="headerlink" title="3.怎么做？"></a>3.怎么做？</h2><p>Talk is cheap,show you the code.</p><h3 id="3-1-普通递归"><a href="#3-1-普通递归" class="headerlink" title="3.1 普通递归"></a>3.1 普通递归</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    ——《C Primer Plus》p595</span></span><br><span class="line"><span class="comment">    函数执行过程：</span></span><br><span class="line"><span class="comment">    1.主函数调用up_and_down(), 并传递参数 1 ;</span></span><br><span class="line"><span class="comment">    2.开始执行up_and_down(), 接受参数 1 ;</span></span><br><span class="line"><span class="comment">    3.(#1)输出参数 n == 1 , 以及参数 n == 1 的地址</span></span><br><span class="line"><span class="comment">    4.进行if判断, n == 1 &lt; 4, 再次调用up_and_down(), 并传递参数 2,与此同时，保留函数第一次执行的运行现场;</span></span><br><span class="line"><span class="comment">    5.进行第一次递归:</span></span><br><span class="line"><span class="comment">        1.(#1)输出参数 n == 2 , 以及参数 n == 2 的地址</span></span><br><span class="line"><span class="comment">        2.进行if判断, n == 2 &lt; 4, 再次调用up_and_down(), 并传递参数 3,与此同时，保留函数第二次执行的运行现场;</span></span><br><span class="line"><span class="comment">        3.进行第二次递归:</span></span><br><span class="line"><span class="comment">            1.(#1)输出参数 n == 3 , 以及参数 n == 3 的地址</span></span><br><span class="line"><span class="comment">            2.进行if判断, n == 3 &lt; 4, 再次调用up_and_down(), 并传递参数 4,与此同时，保留函数第三次执行的运行现场;</span></span><br><span class="line"><span class="comment">            3.进行第三次递归:</span></span><br><span class="line"><span class="comment">                1.(#1)输出参数 n == 4 , 以及参数 n == 4 的地址</span></span><br><span class="line"><span class="comment">                2.进行if判断, n == 4 &lt; 4, 不满足if条件，不执行if内的语句</span></span><br><span class="line"><span class="comment">                3.(#2)输出参数 n == 4 , 以及参数 n == 4 的地址</span></span><br><span class="line"><span class="comment">            4.回归第三次的执行现场</span></span><br><span class="line"><span class="comment">            5.(#2)输出参数 n == 3 , 以及参数 n == 3 的地址</span></span><br><span class="line"><span class="comment">        4.回归第二次的执行现场</span></span><br><span class="line"><span class="comment">        5.(#2)输出参数 n == 2 , 以及参数 n == 2 的地址</span></span><br><span class="line"><span class="comment">    4.回归第一次的执行现场</span></span><br><span class="line"><span class="comment">    5.(#2)输出参数 n == 1 , 以及参数 n == 1 的地址</span></span><br><span class="line"><span class="comment">    6.up_and_down()执行完毕, 回归main()</span></span><br><span class="line"><span class="comment">    7.return 0.</span></span><br><span class="line"><span class="comment">    8.main()执行完毕</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up_and_down</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    up_and_down(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up_and_down</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Level %d: n location %p\n"</span>, n, &amp;n); <span class="comment">//#1</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">4</span>)</span><br><span class="line">        up_and_down(n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"LEVEL %d: n location %p\n"</span>, n, &amp;n); <span class="comment">//#2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-尾递归"><a href="#3-2-尾递归" class="headerlink" title="3.2 尾递归"></a>3.2 尾递归</h3><p>递归调用在主函数的return语句之前。尾递归形式简单，相当于循环。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">rfact</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"This program calculates factorials.\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Enter a value in the range 0-12 (q to quit):\n"</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No negative numbers, please.\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; <span class="number">12</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Keep input under 13.\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"recursion: %d factorial = %ld\n"</span>, num, fact(num));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"recursion: %d factorial = %ld\n"</span>, num, rfact(num));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Enter a value in the range 0-12 (q to quit):\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Bye.\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> ans;</span><br><span class="line">    <span class="keyword">for</span> (ans = <span class="number">1</span>; n &gt; <span class="number">1</span>; n--)</span><br><span class="line">    &#123;</span><br><span class="line">        ans *= n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">rfact</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> ans;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">        ans = n * rfact(n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>496.下一个更大元素 I</title>
    <url>/2020/02/27/496.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%20I/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定两个<strong>没有重复元素</strong>的数组 <code>nums1</code> 和 <code>nums2</code> ，其中<code>nums1</code> 是 <code>nums2</code> 的子集。找到 <code>nums1</code> 中每个元素在 <code>nums2</code> 中的下一个比其大的值。</p><p><code>nums1</code> 中数字 <strong>x</strong> 的下一个更大元素是指 <strong>x</strong> 在 <code>nums2</code> 中对应位置的右边的第一个比 <strong>x</strong> 大的元素。如果不存在，对应位置输出-1。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2].</span><br><span class="line">输出: [-1,3,-1]</span><br><span class="line">解释:</span><br><span class="line">    对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。</span><br><span class="line">    对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。</span><br><span class="line">    对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums1 &#x3D; [2,4], nums2 &#x3D; [1,2,3,4].</span><br><span class="line">输出: [3,-1]</span><br><span class="line">解释:</span><br><span class="line">    对于num1中的数字2，第二个数组中的下一个较大数字是3。</span><br><span class="line">    对于num1中的数字4，第二个数组中没有下一个更大的数字，因此输出 -1。</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li><code>nums1</code>和<code>nums2</code>中所有元素是唯一的。</li><li><code>nums1</code>和<code>nums2</code> 的数组大小都不超过1000。</li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>官解：单调栈</li><li>个人解：for循环遍历</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><p>C语言没有栈和hashmap，所以我使用了for循环遍历</p><ol><li>在<code>nums2</code>中，找到<code>nums1</code>中的元素<code>nums2[j]</code></li><li>在<code>nums2</code>中找到<code>nums2[j]</code>后边更大的数</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">nextGreaterElement</span><span class="params">(<span class="keyword">int</span> *nums1, <span class="keyword">int</span> nums1Size, <span class="keyword">int</span> *nums2, <span class="keyword">int</span> nums2Size, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *returnSize = nums1Size;</span><br><span class="line">    <span class="keyword">if</span> (nums1Size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> *res = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(nums1Size * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nums1Size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; nums2Size; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] == nums2[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (; j &lt; nums2Size; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums2[j] &gt; nums1[i])</span><br><span class="line">                    &#123;</span><br><span class="line">                        res[i] = nums2[j];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        res[i] = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>628.棒球比赛</title>
    <url>/2020/02/27/628.%E6%A3%92%E7%90%83%E6%AF%94%E8%B5%9B/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>你现在是棒球比赛记录员。<br>给定一个字符串列表，每个字符串可以是以下四种类型之一：</p><ol><li><code>整数</code>（一轮的得分）：直接表示您在本轮中获得的积分数。</li><li><code>&quot;+&quot;</code>（一轮的得分）：表示本轮获得的得分是前两轮<code>有效</code> 回合得分的总和。</li><li><code>&quot;D&quot;</code>（一轮的得分）：表示本轮获得的得分是前一轮<code>有效</code> 回合得分的两倍。</li><li><code>&quot;C&quot;</code>（一个操作，这不是一个回合的分数）：表示您获得的最后一个<code>有效</code> 回合的分数是无效的，应该被移除。</li></ol><p>每一轮的操作都是永久性的，可能会对前一轮和后一轮产生影响。<br>你需要返回你在所有回合中得分的总和。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [&quot;5&quot;,&quot;2&quot;,&quot;C&quot;,&quot;D&quot;,&quot;+&quot;]</span><br><span class="line">输出: 30</span><br><span class="line">解释: </span><br><span class="line">第1轮：你可以得到5分。总和是：5。</span><br><span class="line">第2轮：你可以得到2分。总和是：7。</span><br><span class="line">操作1：第2轮的数据无效。总和是：5。</span><br><span class="line">第3轮：你可以得到10分（第2轮的数据已被删除）。总数是：15。</span><br><span class="line">第4轮：你可以得到5 + 10 &#x3D; 15分。总数是：30。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [&quot;5&quot;,&quot;-2&quot;,&quot;4&quot;,&quot;C&quot;,&quot;D&quot;,&quot;9&quot;,&quot;+&quot;,&quot;+&quot;]</span><br><span class="line">输出: 27</span><br><span class="line">解释: </span><br><span class="line">第1轮：你可以得到5分。总和是：5。</span><br><span class="line">第2轮：你可以得到-2分。总数是：3。</span><br><span class="line">第3轮：你可以得到4分。总和是：7。</span><br><span class="line">操作1：第3轮的数据无效。总数是：3。</span><br><span class="line">第4轮：你可以得到-4分（第三轮的数据已被删除）。总和是：-1。</span><br><span class="line">第5轮：你可以得到9分。总数是：8。</span><br><span class="line">第6轮：你可以得到-4 + 9 &#x3D; 5分。总数是13。</span><br><span class="line">第7轮：你可以得到9 + 5 &#x3D; 14分。总数是27。</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>输入列表的大小将介于1和1000之间。</li><li>列表中的每个整数都将介于-30000和30000之间。</li></ul><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>栈</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol><li>遇到<strong>C</strong>：出栈</li><li>遇到<strong>D</strong>：栈顶元素*2，入栈</li><li>遇到<strong>+</strong>：栈顶两个元素求和，入栈</li><li>遇到数字：入栈</li><li>求栈中所有元素的和</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calPoints</span><span class="params">(<span class="keyword">char</span> **ops, <span class="keyword">int</span> opsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span>[<span class="number">1000</span>], top = <span class="number">-1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; opsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (ops[i][<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'C'</span>:</span><br><span class="line">            top--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">            <span class="built_in">stack</span>[++top] = <span class="built_in">stack</span>[top] * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">            <span class="built_in">stack</span>[++top] = <span class="built_in">stack</span>[top] + <span class="built_in">stack</span>[top - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">stack</span>[++top] = atoi(ops[i]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= top; i++)</span><br><span class="line">        res += <span class="built_in">stack</span>[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、PS"><a href="#三、PS" class="headerlink" title="三、PS"></a>三、PS</h2><ol><li>int atoi(<strong>const char *_Str</strong>)：将String转化为int</li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>844.比较含退格的字符串</title>
    <url>/2020/02/27/844.%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定 <code>S</code> 和 <code>T</code> 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 <code>#</code> 代表退格字符。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：S &#x3D; &quot;ab#c&quot;, T &#x3D; &quot;ad#c&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “ac”。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：S &#x3D; &quot;ab##&quot;, T &#x3D; &quot;c#d#&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “”。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：S &#x3D; &quot;a##c&quot;, T &#x3D; &quot;#a#c&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “c”。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：S &#x3D; &quot;a#c&quot;, T &#x3D; &quot;b&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：S 会变成 “c”，但 T 仍然是 “b”。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= S.length &lt;= 200</code></li><li><code>1 &lt;= T.length &lt;= 200</code></li><li><code>S</code> 和 <code>T</code> 只含有小写字母以及字符 <code>&#39;#&#39;</code>。</li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>栈</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol><li>分别将<code>S</code>和<code>T</code>入栈，遇到<code>#</code>出栈</li><li>比较两个栈内元素</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">backspaceCompare</span><span class="params">(<span class="keyword">char</span> *S, <span class="keyword">char</span> *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">char</span> stack1[<span class="number">200</span>];<span class="keyword">int</span> top1 = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> stack2[<span class="number">200</span>];<span class="keyword">int</span> top2 = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(S); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (S[i] == <span class="string">'#'</span>)</span><br><span class="line">            top1 = top1 == <span class="number">-1</span> ? <span class="number">-1</span> : top1 - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            stack1[++top1] = S[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(T); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (T[i] == <span class="string">'#'</span>)</span><br><span class="line">            top2 = top2 == <span class="number">-1</span> ? <span class="number">-1</span> : top2 - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            stack2[++top2] = T[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (top1 != top2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt;= top1, j &lt;= top2; i++, j++)</span><br><span class="line">        <span class="keyword">if</span> (stack1[i] != stack2[j])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>142.环形链表 II</title>
    <url>/2020/02/26/142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%20II/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p><p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。</p><p><strong>说明：</strong>不允许修改给定的链表。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">输出：tail connects to node index 1</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/26/ag8O41YDvkWQ3oz.png" alt="circularlinkedlist.png"></p><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,2], pos &#x3D; 0</span><br><span class="line">输出：tail connects to node index 0</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/26/s1YK7UGb3pVNQw5.png" alt="circularlinkedlist_test2.png"></p><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1], pos &#x3D; -1</span><br><span class="line">输出：no cycle</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/26/unGX9L7f6Ura31d.png" alt="circularlinkedlist_test3.png"></p><p><strong>进阶：</strong><br>你是否可以不用额外空间解决此题？</p><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>双指针</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol><li><p>使用快慢双指针确认链表是否有环</p></li><li><p>如果有环，找到入环节点。</p><p>我有一点搞不太明白的就是，如果有环，那么最终慢指针停下的位置与入环节点的距离==头节点与入环节点的距离。利用这一性质，可以找到入环节点。</p></li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode *<span class="title">detectCycle</span><span class="params">(struct ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">fast</span> = <span class="title">head</span>, *<span class="title">slow</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">int</span> hasCycle = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast)</span><br><span class="line">        &#123;</span><br><span class="line">            hasCycle = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasCycle)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (head != slow)</span><br><span class="line">        &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>155.最小栈</title>
    <url>/2020/02/26/155.%E6%9C%80%E5%B0%8F%E6%A0%88/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p><ul><li>push(x) — 将元素 x 推入栈中。</li><li>pop() — 删除栈顶的元素。</li><li>top() — 获取栈顶元素。</li><li>getMin() — 检索栈中的最小元素。</li></ul><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>用数组实现栈</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol><li>这道题没什么的，很简单</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">10000</span>];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125; MinStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** initialize your data structure here. */</span></span><br><span class="line"></span><br><span class="line"><span class="function">MinStack *<span class="title">minStackCreate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MinStack *st = (MinStack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MinStack));</span><br><span class="line">    st-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> st;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minStackPush</span><span class="params">(MinStack *obj, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj-&gt;top++;</span><br><span class="line">    obj-&gt;data[obj-&gt;top] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minStackPop</span><span class="params">(MinStack *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj-&gt;top--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minStackTop</span><span class="params">(MinStack *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;top != <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> obj-&gt;data[obj-&gt;top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minStackGetMin</span><span class="params">(MinStack *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = obj-&gt;top;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">min</span> = obj-&gt;data[i];</span><br><span class="line">    <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">min</span> = <span class="built_in">min</span> &lt; obj-&gt;data[i] ? <span class="built_in">min</span> : obj-&gt;data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minStackFree</span><span class="params">(MinStack *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = minStackCreate();</span></span><br><span class="line"><span class="comment"> * minStackPush(obj, x);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * minStackPop(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_3 = minStackTop(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_4 = minStackGetMin(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * minStackFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>stack</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title>225.用队列实现栈</title>
    <url>/2020/02/26/225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>使用队列实现栈的下列操作：</p><ul><li>push(x) — 元素 x 入栈</li><li>pop() — 移除栈顶元素</li><li>top() — 获取栈顶元素</li><li>empty() — 返回栈是否为空</li></ul><p><strong>注意:</strong></p><ul><li>你只能使用队列的基本操作— 也就是 <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code>, 和 <code>is empty</code> 这些操作是合法的。</li><li>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li><li>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</li></ul><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol><li>没啥可说的</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">&#125; MyStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"></span><br><span class="line"><span class="function">MyStack *<span class="title">myStackCreate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyStack *st = (MyStack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyStack));</span><br><span class="line">    st-&gt;front = <span class="number">0</span>;</span><br><span class="line">    st-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> st;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Push element x onto stack. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myStackPush</span><span class="params">(MyStack *obj, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj-&gt;rear++;</span><br><span class="line">    obj-&gt;data[obj-&gt;rear] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myStackPop</span><span class="params">(MyStack *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = obj-&gt;data[obj-&gt;rear];</span><br><span class="line">    obj-&gt;rear--;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get the top element. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myStackTop</span><span class="params">(MyStack *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;data[obj-&gt;rear];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myStackEmpty</span><span class="params">(MyStack *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;front == obj-&gt;rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myStackFree</span><span class="params">(MyStack *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack* obj = myStackCreate();</span></span><br><span class="line"><span class="comment"> * myStackPush(obj, x);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_2 = myStackPop(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_3 = myStackTop(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * bool param_4 = myStackEmpty(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * myStackFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>stack</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title>232.用栈实现队列</title>
    <url>/2020/02/26/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>使用栈实现队列的下列操作：</p><ul><li>push(x) — 将一个元素放入队列的尾部。</li><li>pop() — 从队列首部移除元素。</li><li>peek() — 返回队列首部的元素。</li><li>empty() — 返回队列是否为空。</li></ul><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyQueue queue &#x3D; new MyQueue();</span><br><span class="line"></span><br><span class="line">queue.push(1);</span><br><span class="line">queue.push(2);  </span><br><span class="line">queue.peek();  &#x2F;&#x2F; 返回 1</span><br><span class="line">queue.pop();   &#x2F;&#x2F; 返回 1</span><br><span class="line">queue.empty(); &#x2F;&#x2F; 返回 false</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>你只能使用标准的栈操作 — 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li><li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</li></ul><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>辅助栈</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol><li>增加一个辅助栈st2</li><li>每次入栈时，先将st2中的元素压入st1，再将待入栈元素压入st2，最后将st1中的元素全部压入st2</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data1[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> top1;</span><br><span class="line">    <span class="keyword">int</span> data2[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> top2;</span><br><span class="line">&#125; MyQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"></span><br><span class="line"><span class="function">MyQueue *<span class="title">myQueueCreate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyQueue *que = (MyQueue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyQueue));</span><br><span class="line">    que-&gt;top1 = <span class="number">-1</span>;</span><br><span class="line">    que-&gt;top2 = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> que;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myQueuePush</span><span class="params">(MyQueue *obj, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (obj-&gt;top2 != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        obj-&gt;data1[++obj-&gt;top1] = obj-&gt;data2[obj-&gt;top2--];</span><br><span class="line">    &#125;</span><br><span class="line">    obj-&gt;data2[++obj-&gt;top2] = x;</span><br><span class="line">    <span class="keyword">while</span> (obj-&gt;top1 != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        obj-&gt;data2[++obj-&gt;top2] = obj-&gt;data1[obj-&gt;top1--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myQueuePop</span><span class="params">(MyQueue *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = obj-&gt;data2[obj-&gt;top2];</span><br><span class="line">    obj-&gt;top2--;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get the front element. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myQueuePeek</span><span class="params">(MyQueue *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;data2[obj-&gt;top2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myQueueEmpty</span><span class="params">(MyQueue *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;top2 == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myQueueFree</span><span class="params">(MyQueue *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue* obj = myQueueCreate();</span></span><br><span class="line"><span class="comment"> * myQueuePush(obj, x);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_2 = myQueuePop(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * int param_3 = myQueuePeek(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * bool param_4 = myQueueEmpty(obj);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * myQueueFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>stack</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title>143.重排链表</title>
    <url>/2020/02/20/143.%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个单链表 <em>L</em>：<em>L</em>0→<em>L</em>1→…→<em>L**n</em>-1→<em>L</em>n ，<br>将其重新排列后变为： <em>L</em>0→<em>L**n</em>→<em>L</em>1→<em>L**n</em>-1→<em>L</em>2→<em>L**n</em>-2→…</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ol><li>双指针+翻转链表</li><li>使用栈</li></ol><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><p>我使用的是法一：</p><ol><li>使用快慢双指针找到链表中点</li><li>将后半段链表翻转</li><li>拼接两个链表</li></ol><p>简述一下法二：</p><ol><li>先将所有节点进栈</li><li>边遍历，边出栈（出后半段就够了）</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(struct ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next || !head-&gt;next-&gt;next)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//找到中点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">fast</span> = <span class="title">head</span>, *<span class="title">slow</span> = <span class="title">head</span>, *<span class="title">right</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    right = slow-&gt;next;</span><br><span class="line">    slow-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//翻转后半部分</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span> = <span class="title">right</span>, *<span class="title">q</span>, *<span class="title">r</span>;</span></span><br><span class="line">    r = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        q-&gt;next = r;</span><br><span class="line">        r = q;</span><br><span class="line">    &#125;</span><br><span class="line">    right = q;</span><br><span class="line">    <span class="comment">//遍历并连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">l1</span> = <span class="title">head</span>, *<span class="title">l2</span> = <span class="title">right</span>, *<span class="title">l1next</span> = <span class="title">head</span>-&gt;<span class="title">next</span>, *<span class="title">l2next</span> = <span class="title">right</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (l2)</span><br><span class="line">    &#123;</span><br><span class="line">        l2-&gt;next = l1next;</span><br><span class="line">        l1-&gt;next = l2;</span><br><span class="line">        l1 = l1next;</span><br><span class="line">        l1next = l1next-&gt;next;</span><br><span class="line">        l2 = l2next;</span><br><span class="line">        <span class="keyword">if</span> (l2next)</span><br><span class="line">            l2next = l2next-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真是有史以来写的又臭又长的代码！</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>328.奇偶链表</title>
    <url>/2020/02/20/328.%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p><p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL </span><br><span class="line">输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>应当保持奇数节点和偶数节点的相对顺序。</li><li>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</li></ul><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>双指针</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol><li>使用奇偶双指针按序遍历，分别将奇序号节点和偶序号节点连接起来</li><li>将偶序号节点头拼接在奇序号节点后</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode *<span class="title">oddEvenList</span><span class="params">(struct ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">odd</span> = <span class="title">head</span>, *<span class="title">even</span> = <span class="title">head</span>-&gt;<span class="title">next</span>, *<span class="title">headOfEven</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (odd-&gt;next &amp;&amp; even-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        odd-&gt;next = even-&gt;next;</span><br><span class="line">        odd = odd-&gt;next;</span><br><span class="line">        even-&gt;next = odd-&gt;next;</span><br><span class="line">        even = even-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    odd-&gt;next = headOfEven;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这应该是我自己写出的最优美的代码了！</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>445.两数相加 II</title>
    <url>/2020/02/20/445.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%20II/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定两个<strong>非空</strong>链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储单个数字。将这两数相加会返回一个新的链表。</p><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><p><strong>进阶:</strong></p><p>如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出: 7 -&gt; 8 -&gt; 0 -&gt; 7</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>反转链表+逐位相加</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><p>这道题我本来还没思路，结果进阶说：不能翻转怎么办？</p><p>还能怎么办，我不进阶了，哈哈哈哈哈哈，快乐就完事了！😂</p><p>（直接把第2题和第206题的代码粘过来了）</p><p>直接：反转、反转，相加，反转</p><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode *<span class="title">reverseList</span><span class="params">(struct ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span>, *<span class="title">q</span>, *<span class="title">r</span>;</span></span><br><span class="line">    p = head;</span><br><span class="line">    r = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        q-&gt;next = r;</span><br><span class="line">        r = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode *<span class="title">addTwo</span><span class="params">(struct ListNode *l1, struct ListNode *l2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">l3</span> = (<span class="title">struct</span> <span class="title">ListNode</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    l3-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span> = <span class="title">l1</span>, *<span class="title">q</span> = <span class="title">l2</span>, *<span class="title">r</span> = <span class="title">l3</span>;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> || q != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a = p != <span class="literal">NULL</span> ? p-&gt;val : <span class="number">0</span>;</span><br><span class="line">        b = q != <span class="literal">NULL</span> ? q-&gt;val : <span class="number">0</span>;</span><br><span class="line">        c = (a + b + flag) % <span class="number">10</span>;</span><br><span class="line">        flag = (a + b + flag) / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        r-&gt;next = (struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">        r-&gt;val = c;</span><br><span class="line">        r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="literal">NULL</span>)</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">    &#123;</span><br><span class="line">        r-&gt;next = (struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">        r-&gt;val = <span class="number">1</span>;</span><br><span class="line">        r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l3-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">struct ListNode *<span class="title">addTwoNumbers</span><span class="params">(struct ListNode *l1, struct ListNode *l2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l1 = reverseList(l1);</span><br><span class="line">    l2 = reverseList(l2);</span><br><span class="line">    <span class="keyword">return</span> reverseList(addTwo(l1, l2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我太机智了，这是我AC最快的一次，哈哈哈哈哈哈哈！</p><p>先埋下这个坑，日后再来填！😝</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>61.旋转链表</title>
    <url>/2020/02/19/61.%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个链表，旋转链表，将链表每个节点向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k &#x3D; 2</span><br><span class="line">输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL</span><br><span class="line">向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 0-&gt;1-&gt;2-&gt;NULL, k &#x3D; 4</span><br><span class="line">输出: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class="line">向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL</span><br><span class="line">向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL</span><br><span class="line">向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>快慢双指针</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li><p>首先遍历链表，得到其长度，对<code>K</code>取余</p><p>然后使用快慢指针，先让快指针走<code>K</code>步，在让快慢指针一起走</p><p>然后将慢指针后边的链表放在链表头前边即可</p></li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode *<span class="title">rotateRight</span><span class="params">(struct ListNode *head, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span> = <span class="title">head</span>, *<span class="title">q</span>;</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        len++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    k = k % len;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">slow</span> = <span class="title">head</span>, *<span class="title">fast</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    q = slow-&gt;next;</span><br><span class="line">    slow-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    fast-&gt;next = head;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>82.删除排序链表中的重复元素 II</title>
    <url>/2020/02/19/82.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%20II/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 <em>没有重复出现</em> 的数字。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</span><br><span class="line">输出: 1-&gt;2-&gt;5</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;1-&gt;1-&gt;2-&gt;3</span><br><span class="line">输出: 2-&gt;3</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>迭代法</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li><p>1.使用哨兵节点放置在头节点之前；</p><p>2.使用头指针开始遍历链表，用while循环找到不相同的值时，就删除值相同的节点</p><p>3.令pre指向head</p><p>4.循环迭代</p></li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode *<span class="title">deleteDuplicates</span><span class="params">(struct ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">prev</span> = (<span class="title">struct</span> <span class="title">ListNode</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    prev-&gt;next = head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">pre</span> = <span class="title">prev</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span> &amp;&amp; head-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = head-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;val == head-&gt;next-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (head-&gt;val == temp)</span><br><span class="line">            &#123;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">                <span class="keyword">if</span> (!head)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre-&gt;next = head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>86.分隔链表</title>
    <url>/2020/02/19/86.%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个链表和一个特定值 <em>x</em>，对链表进行分隔，使得所有小于 <em>x</em> 的节点都在大于或等于 <em>x</em> 的节点之前。</p><p>你应当保留两个分区中每个节点的初始相对位置。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: head &#x3D; 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x &#x3D; 3</span><br><span class="line">输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。</span><br><span class="line"></span><br><span class="line">你应当保留两个分区中每个节点的初始相对位置。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: head &#x3D; 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x &#x3D; 3</span><br><span class="line">输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>迭代</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol><li>用head指针遍历链表，并申请两个节点；</li><li>比<code>x</code>大的节点接在smaller后边；比<code>x</code>小的节点接在bigger后边；</li><li>吧bigger接在smaller后边。</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode *<span class="title">partition</span><span class="params">(struct ListNode *head, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">smaller</span> = (<span class="title">struct</span> <span class="title">ListNode</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">bigger</span> = (<span class="title">struct</span> <span class="title">ListNode</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span> = <span class="title">smaller</span>, *<span class="title">q</span> = <span class="title">bigger</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;val &lt; x)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next = head;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            q-&gt;next = head;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;next = bigger-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> smaller-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>92.反转链表 II</title>
    <url>/2020/02/19/92.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%20II/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>反转从位置 <em>m</em> 到 <em>n</em> 的链表。请使用一趟扫描完成反转。</p><p><strong>说明:</strong><br>1 ≤ <em>m</em> ≤ <em>n</em> ≤ 链表长度。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m &#x3D; 2, n &#x3D; 4</span><br><span class="line">输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>使用额外数组</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol><li>使用额外的数组将m~n的值存储起来</li><li>再将m~n的节点按照help数组的逆序覆盖</li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode *<span class="title">reverseBetween</span><span class="params">(struct ListNode *head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == n)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">int</span> len = n - m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, a = m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> *help = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span> = <span class="title">head</span>, *<span class="title">q</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (a)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        a--;</span><br><span class="line">    &#125;</span><br><span class="line">    q = p;</span><br><span class="line">    <span class="keyword">while</span> (m &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        help[i++] = p-&gt;val;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        m++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        q-&gt;val = help[i];</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>24.两两交换链表中的节点</title>
    <url>/2020/02/18/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>迭代法</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode *<span class="title">swapPairs</span><span class="params">(struct ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">prev</span> = (<span class="title">struct</span> <span class="title">ListNode</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    prev-&gt;next = head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">pre</span> = <span class="title">prev</span>, *<span class="title">p</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (head &amp;&amp; head-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        pre-&gt;next = p;</span><br><span class="line">        head-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = head;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (!head)<span class="comment">//预防空指针</span></span><br><span class="line">            p = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>19.删除链表的倒数第N个节点</title>
    <url>/2020/02/17/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个链表，删除链表的倒数第 <em>n</em> 个节点，并且返回链表的头结点。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n &#x3D; 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>给定的 <em>n</em> 保证是有效的。</p><p><strong>进阶：</strong></p><p>你能尝试使用一趟扫描实现吗？</p><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>双指针</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li>先让快指针跑n步；如果快指针为空，则说明删除头节点，然后快慢指针一起跑到末尾；</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode *<span class="title">removeNthFromEnd</span><span class="params">(struct ListNode *head, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">fast</span> = <span class="title">head</span>, *<span class="title">slow</span> = <span class="title">head</span>, *<span class="title">q</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    q = slow-&gt;next;</span><br><span class="line">    slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>21.合并两个有序链表</title>
    <url>/2020/02/17/21.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>迭代法</li><li>递归法</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li><p>我使用的是迭代法（参考官解）</p><p>首先，定义一个假头节点，便于将两个链表连接起来，并定义一个哨兵指针指向这个假头节点，方便我们返回最后得到的链表；</p><p>然后，开始遍历链表一和链表二，当链表一和链表二都不为空时，pre指针总是指向val较小的节点；</p><p>然后，pre指针始终指向所求的有序链表的最后一个节点；</p><p>最后，将链表一和链表二中仍然不为空的链表接在最后</p></li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode *<span class="title">mergeTwoLists</span><span class="params">(struct ListNode *l1, struct ListNode *l2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">pre</span> = (<span class="title">struct</span> <span class="title">ListNode</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    pre-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">prev</span> = <span class="title">pre</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = pre-&gt;next;<span class="comment">//pre指针始终指向所求的有序链表的最后一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    pre-&gt;next = l1 == <span class="literal">NULL</span> ? l2 : l1;</span><br><span class="line">    <span class="keyword">return</span> prev-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、PS"><a href="#三、PS" class="headerlink" title="三、PS"></a>三、PS</h2><p>递归法不是很理解，详细请参考👉<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode/" target="_blank" rel="noopener">官方答案</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>234.回文链表</title>
    <url>/2020/02/17/234.%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>请判断一个链表是否为回文链表。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>进阶：</strong><br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>遍历+双指针</li><li>快慢指针+翻转链表</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li><p>我使用的是第一种算法，首先，遍历整个链表，将所有元素存到数组中，然后使用头尾指针判断数组即可。</p><p>但是这种算法不是最优的，时空复杂度均为O(n)</p></li></ul><ul><li>第二种算法，首先使用快慢指针找到链表的中点（做过），再将后半段链表翻转，并与前半段链表比较即可。</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(struct ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        len++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        data[m++] = p-&gt;val;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (data[i] == data[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>237.删除链表中的节点</title>
    <url>/2020/02/17/237.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。</p><p>现有一个链表 — head = [4,5,1,9]，它可以表示为:</p><p><img src="https://i.loli.net/2020/02/17/v62DZVMGCynFS4J.png" alt="237_example.png"></p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: head &#x3D; [4,5,1,9], node &#x3D; 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: head &#x3D; [4,5,1,9], node &#x3D; 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>链表至少包含两个节点。</li><li>链表中所有节点的值都是唯一的。</li><li>给定的节点为非末尾节点并且一定是链表中的一个有效节点。</li><li>不要从你的函数中返回任何结果。</li></ul><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>节点赋值（C）</li><li>节点替换（java）</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><p>一开始我以为题出错了，没给链表咋删节点啊，看了讨论之后。嗯……还是自己太年轻了</p><ul><li>节点赋值：直接将<code>*（node-&gt;next）</code>赋值给<code>*node</code>，从而将原本的<code>*node</code>节点覆盖</li><li>节点替换：首先将node下一个节点的值赋值给node，再将node的下一个节点替换为node的下下个节点</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><ul><li><p>C（这绝对是我写过最短的题解🤣）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br></pre></td></tr></table></figure><ul><li>Definition for singly-linked list.</li><li>struct ListNode {</li><li>int val;</li><li>struct ListNode *next;</li><li><p>};<br><em>/<br>void deleteNode(struct ListNode </em>node)<br>{<br><em>node = </em>(node-&gt;next);<br>}</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li></ul></li><li><p>java</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        node.val = node.next.val;</span><br><span class="line">        node.next = node.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、PS"><a href="#三、PS" class="headerlink" title="三、PS"></a>三、PS</h2><p>​ 我尝试过用java的方法，用C实现，但是我发现如果node是倒数第二个节点时，就会堆栈溢出，这肯定是<code>node.next = node.next.next;</code>这句代码出了问题。我觉得可能是官方给的数据最后一个节点的next没有置为<strong>NULL</strong>，导致指针在最后一个节点时，找不到他的下一个节点；而当我们自己写代码时，我认为始终令最后的一个节点的next置为<strong>NULL</strong>，这样才不会总是报错，这是一个良好的习惯。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>876.链表的中间结点</title>
    <url>/2020/02/17/876.%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个带有头结点 <code>head</code> 的非空单链表，返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,4,5]</span><br><span class="line">输出：此列表中的结点 3 (序列化形式：[3,4,5])</span><br><span class="line">返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。</span><br><span class="line">注意，我们返回了一个 ListNode 类型的对象 ans，这样：</span><br><span class="line">ans.val &#x3D; 3, ans.next.val &#x3D; 4, ans.next.next.val &#x3D; 5, 以及 ans.next.next.next &#x3D; NULL.</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,4,5,6]</span><br><span class="line">输出：此列表中的结点 4 (序列化形式：[4,5,6])</span><br><span class="line">由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>给定链表的结点数介于 <code>1</code> 和 <code>100</code> 之间。</li></ul><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>双指针</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li>快慢双指针，快指针每次走两步，慢指针每次走一步</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode *<span class="title">middleNode</span><span class="params">(struct ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">slow</span> = <span class="title">head</span>, *<span class="title">fast</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>908.最小差值 I</title>
    <url>/2020/02/17/908.%E6%9C%80%E5%B0%8F%E5%B7%AE%E5%80%BC%20I/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个整数数组 <code>A</code>，对于每个整数 <code>A[i]</code>，我们可以选择任意 <code>x</code> 满足 <code>-K &lt;= x &lt;= K</code>，并将 <code>x</code> 加到 <code>A[i]</code> 中。</p><p>在此过程之后，我们得到一些数组 <code>B</code>。</p><p>返回 <code>B</code> 的最大值和 <code>B</code> 的最小值之间可能存在的最小差值。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [1], K &#x3D; 0</span><br><span class="line">输出：0</span><br><span class="line">解释：B &#x3D; [1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [0,10], K &#x3D; 2</span><br><span class="line">输出：6</span><br><span class="line">解释：B &#x3D; [2,8]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [1,3,6], K &#x3D; 3</span><br><span class="line">输出：0</span><br><span class="line">解释：B &#x3D; [3,3,3] 或 B &#x3D; [4,4,4]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= A.length &lt;= 10000</code></li><li><code>0 &lt;= A[i] &lt;= 10000</code></li><li><code>0 &lt;= K &lt;= 10000</code></li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>遍历数组</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li>找出数组中的最大值和最小值，所求的数应该是<code>(max - min) &gt; 2 * K ? max - min - 2 * K : 0;</code></li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">smallestRangeI</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> ASize, <span class="keyword">int</span> K)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">min</span> = A[<span class="number">0</span>], <span class="built_in">max</span> = A[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ASize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">min</span> = A[i] &gt; <span class="built_in">min</span> ? <span class="built_in">min</span> : A[i];</span><br><span class="line">        <span class="built_in">max</span> = A[i] &lt; <span class="built_in">max</span> ? <span class="built_in">max</span> : A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">max</span> - <span class="built_in">min</span>) &gt; <span class="number">2</span> * K ? <span class="built_in">max</span> - <span class="built_in">min</span> - <span class="number">2</span> * K : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、PS"><a href="#三、PS" class="headerlink" title="三、PS"></a>三、PS</h2><p>这里再多说两句：</p><p>首先，这道题描述的不是很清楚。</p><p>转述：给定一个整数<code>K</code>，使数组中的数加上<code>[-K, K]</code>的数后的差值最小。</p><p>后来我就想，这其实就是一道<strong>线性规划</strong>的题嘛。</p><p>比如说题目中的测试用例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [0,10], K &#x3D; 2</span><br><span class="line">输出：6</span><br><span class="line">解释：B &#x3D; [2,8]</span><br></pre></td></tr></table></figure><p>就是让散列点都向y=2靠近：</p><p><img src="https://i.loli.net/2020/02/17/H69UhgAYsLxq1WV.png" alt="3DC81E16CD0CEB3016C92FF18EC45BBE.png"></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>1009.十进制整数的反码</title>
    <url>/2020/02/16/1009.%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B4%E6%95%B0%E7%9A%84%E5%8F%8D%E7%A0%81/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>每个非负整数 <code>N</code> 都有其二进制表示。例如， <code>5</code> 可以被表示为二进制 <code>&quot;101&quot;</code>，<code>11</code> 可以用二进制 <code>&quot;1011&quot;</code> 表示，依此类推。注意，除 <code>N = 0</code> 外，任何二进制表示中都不含前导零。</p><p>二进制的反码表示是将每个 <code>1</code> 改为 <code>0</code> 且每个 <code>0</code> 变为 <code>1</code>。例如，二进制数 <code>&quot;101&quot;</code> 的二进制反码为 <code>&quot;010&quot;</code>。</p><p>给定十进制数 <code>N</code>，返回其二进制表示的反码所对应的十进制整数。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：5</span><br><span class="line">输出：2</span><br><span class="line">解释：5 的二进制表示为 &quot;101&quot;，其二进制反码为 &quot;010&quot;，也就是十进制中的 2 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：7</span><br><span class="line">输出：0</span><br><span class="line">解释：7 的二进制表示为 &quot;111&quot;，其二进制反码为 &quot;000&quot;，也就是十进制中的 0 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：10</span><br><span class="line">输出：5</span><br><span class="line">解释：10 的二进制表示为 &quot;1010&quot;，其二进制反码为 &quot;0101&quot;，也就是十进制中的 5 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>0 &lt;= N &lt; 10^9</code></li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>位运算</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol><li><p>5 = “101”, 10 = “1010”</p></li><li><p>将”101”逐位取反：”101” ^ “111” = “010”</p><p>将”1010”逐位取反：”1010” ^ “1111” = “0101”</p></li><li><p>返回取反后的数字</p><p>主要就是怎么找这个：每一位都是1的数</p><p>使用while循环，当num&lt;N时，将num左移一位再加一</p></li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitwiseComplement</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//找每一位都是1的数</span></span><br><span class="line">    <span class="keyword">while</span> (num &lt; N)</span><br><span class="line">    &#123;</span><br><span class="line">        num = (num &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取反</span></span><br><span class="line">    <span class="keyword">return</span> N ^ num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、PS"><a href="#三、PS" class="headerlink" title="三、PS"></a>三、PS</h2><p>完全参考leetcode大佬：<a href="https://leetcode-cn.com/u/suspectx/" target="_blank" rel="noopener">suspectX</a>的答案</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>bit-manipu</tag>
      </tags>
  </entry>
  <entry>
    <title>1013.将数组分成和相等的三个部分</title>
    <url>/2020/02/16/1013.%E5%B0%86%E6%95%B0%E7%BB%84%E5%88%86%E6%88%90%E5%92%8C%E7%9B%B8%E7%AD%89%E7%9A%84%E4%B8%89%E4%B8%AA%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个整数数组 <code>A</code>，只有我们可以将其划分为三个和相等的非空部分时才返回 <code>true</code>，否则返回 <code>false</code>。</p><p>形式上，如果我们可以找出索引 <code>i+1 &lt; j</code> 且满足 <code>(A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... + A[A.length - 1])</code> 就可以将数组三等分。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出：[0,2,1,-6,6,-7,9,1,2,0,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：0 + 2 + 1 &#x3D; -6 + 6 - 7 + 9 + 1 &#x3D; 2 + 0 + 1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[0,2,1,-6,6,7,9,-1,2,0,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,3,6,5,-2,2,5,1,-9,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：3 + 3 &#x3D; 6 &#x3D; 5 - 2 + 2 + 5 + 1 - 9 + 4</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>3 &lt;= A.length &lt;= 50000</code></li><li><code>-10000 &lt;= A[i] &lt;= 10000</code></li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>双指针</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li>双指针向数组中间遍历，如果头尾指针遍历的累加都等于整个数组和的1/3，则判断头尾指针之间元素的累加是否等于数组的1/3即可</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">summ</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; a &lt;= b; a++)</span><br><span class="line">        sum += A[a];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canThreePartsEqualSum</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> ASize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ASize; i++)</span><br><span class="line">        sum += A[i];</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">3</span> != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> oneThird = sum / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>, n = ASize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> qian = <span class="number">0</span>, hou = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (m &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (qian != oneThird)</span><br><span class="line">        &#123;</span><br><span class="line">            qian += A[m];</span><br><span class="line">            m++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (hou != oneThird)</span><br><span class="line">        &#123;</span><br><span class="line">            hou += A[n];</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (summ(A, m, n) == oneThird)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>1137.第 N 个泰波那契数</title>
    <url>/2020/02/16/1137.%E7%AC%AC%20N%20%E4%B8%AA%E6%B3%B0%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>泰波那契序列 Tn 定义如下：</p><p>T0 = 0, T1 = 1, T2 = 1, 且在 n &gt;= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2</p><p>给你整数 <code>n</code>，请返回第 n 个泰波那契数 Tn 的值。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 4</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">T_3 &#x3D; 0 + 1 + 1 &#x3D; 2</span><br><span class="line">T_4 &#x3D; 1 + 1 + 2 &#x3D; 4</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 25</span><br><span class="line">输出：1389537</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 37</code></li><li>答案保证是一个 32 位整数，即 <code>answer &lt;= 2^31 - 1</code>。</li></ul><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>递归</li><li>使用中间变量的递归（栈的思想）</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li>使用中间变量保存之前的值，进行递归（引申：二叉树的前中后序优先遍历，使用栈保存待递归的元素）</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tribonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>, c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = a + b + c;</span><br><span class="line">        a = b;</span><br><span class="line">        b = c;</span><br><span class="line">        c = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">    <span class="comment">//直接递归会超时</span></span><br><span class="line">    <span class="comment">//return tribonacci(n - 1) + tribonacci(n - 2) + tribonacci(n - 3);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>2.两数相加</title>
    <url>/2020/02/16/2.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给出两个 <strong>非空</strong> 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 <strong>一位</strong> 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 &#x3D; 807</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li>定义两个指针，分别指向两个链表</li><li>每访问一个节点，申请一个新节点存放该位应该存放的值，并记录进位<code>flag</code></li><li>循环结束后，如果仍有进位，则在申请一个新节点用来存放进位</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode *<span class="title">addTwoNumbers</span><span class="params">(struct ListNode *l1, struct ListNode *l2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">l3</span> = (<span class="title">struct</span> <span class="title">ListNode</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    l3-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span> = <span class="title">l1</span>, *<span class="title">q</span> = <span class="title">l2</span>, *<span class="title">r</span> = <span class="title">l3</span>;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> || q != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a = p != <span class="literal">NULL</span> ? p-&gt;val : <span class="number">0</span>;</span><br><span class="line">        b = q != <span class="literal">NULL</span> ? q-&gt;val : <span class="number">0</span>;</span><br><span class="line">        c = (a + b + flag) % <span class="number">10</span>;</span><br><span class="line">        flag = (a + b + flag) / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        r-&gt;next = (struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">        r-&gt;val = c;</span><br><span class="line">        r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="literal">NULL</span>)</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">    &#123;</span><br><span class="line">        r-&gt;next = (struct ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">        r-&gt;val = <span class="number">1</span>;</span><br><span class="line">        r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l3-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>852.山脉数组的峰顶索引</title>
    <url>/2020/02/15/852.%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E7%9A%84%E5%B3%B0%E9%A1%B6%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>我们把符合下列属性的数组 <code>A</code> 称作山脉：</p><ul><li><code>A.length &gt;= 3</code></li><li>存在 <code>0 &lt; i &lt; A.length - 1</code> 使得<code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code></li></ul><p>给定一个确定为山脉的数组，返回任何满足 <code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code> 的 <code>i</code> 的值。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[0,1,0]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[0,2,1,0]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>3 &lt;= A.length &lt;= 10000</code></li><li>0 &lt;= A[i] &lt;= 10^6</li><li>A 是如上定义的山脉</li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>遍历</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li>遍历数组，遇到比前一个元素小的时候停下，返回前边元素的索引</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> ASize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; ASize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] &gt; A[i - <span class="number">1</span>])</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>905.按奇偶排序数组</title>
    <url>/2020/02/15/905.%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个非负整数数组 <code>A</code>，返回一个数组，在该数组中， <code>A</code> 的所有偶数元素之后跟着所有奇数元素。</p><p>你可以返回满足此条件的任何数组作为答案。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,1,2,4]</span><br><span class="line">输出：[2,4,3,1]</span><br><span class="line">输出 [4,2,3,1]，[2,4,1,3] 和 [4,2,1,3] 也会被接受。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= A.length &lt;= 5000</code></li><li><code>0 &lt;= A[i] &lt;= 5000</code></li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>双指针</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li>声明头尾指针向数组中间遍历，<code>i</code>指针指向偶数，<code>j</code>指针指向奇数；当不符合上述情况时，则交换<code>i</code>和<code>j</code>指针所指向的元素。</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">sortArrayByParity</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> ASize, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = ASize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A[j] % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp = A[i];</span><br><span class="line">            A[i] = A[j];</span><br><span class="line">            A[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = ASize;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>dynamic-programming</tag>
      </tags>
  </entry>
  <entry>
    <title>941.有效的山脉数组</title>
    <url>/2020/02/15/941.%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个整数数组 <code>A</code>，如果它是有效的山脉数组就返回 <code>true</code>，否则返回 <code>false</code>。</p><p>让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组：</p><ul><li><p><code>A.length &gt;= 3</code></p></li><li><p>在 <code>0 &lt; i &lt; A.length - 1</code>条件下，存在<code>i</code>使得：</p><ul><li><code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i]</code></li><li><code>A[i] &gt; A[i+1] &gt; ... &gt; A[B.length - 1]</code></li></ul></li></ul><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[2,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,5,5]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[0,3,2,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>0 &lt;= A.length &lt;= 10000</code></li><li><code>0 &lt;= A[i] &lt;= 10000</code></li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>双指针</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li>找到<strong>山峰（最大值）</strong>，使用双指针从数组两端向<strong>山峰</strong>遍历</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validMountainArray</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> ASize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ASize &lt; <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>, indexOfMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (m = <span class="number">0</span>; m &lt; ASize; m++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[m] &gt; <span class="built_in">max</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">max</span> = A[m];</span><br><span class="line">            indexOfMax = m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//排除山峰在头尾的情况</span></span><br><span class="line">    <span class="keyword">if</span> (indexOfMax == <span class="number">0</span> || indexOfMax == ASize - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = ASize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; indexOfMax || j &gt; indexOfMax)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i + <span class="number">1</span>] &gt; A[i] &amp;&amp; i &lt; indexOfMax)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A[j - <span class="number">1</span>] &gt; A[j] &amp;&amp; j &gt; indexOfMax)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、PS"><a href="#三、PS" class="headerlink" title="三、PS"></a>三、PS</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = indexOfMax, j = indexOfMax;</span><br><span class="line"><span class="keyword">while</span> (i &gt; <span class="number">0</span> || j &lt; A.length - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (A[i - <span class="number">1</span>] &lt; A[i] &amp;&amp; i &gt; <span class="number">0</span>)</span><br><span class="line">        i--;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (A[j + <span class="number">1</span>] &lt; A[j] &amp;&amp; j &lt; A.length - <span class="number">1</span>)</span><br><span class="line">        j++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的思想是从中间的<strong>山峰</strong>向两端遍历，一直遇到了莫名其妙的内存溢出问题，后来改用了双指针从两端向<strong>山峰</strong>遍历</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>605.种花问题</title>
    <url>/2020/02/14/605.%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p><p>给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 <strong>n</strong> 。能否在不打破种植规则的情况下种入 <strong>n</strong> 朵花？能则返回True，不能则返回False。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: flowerbed &#x3D; [1,0,0,0,1], n &#x3D; 1</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: flowerbed &#x3D; [1,0,0,0,1], n &#x3D; 2</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>数组内已种好的花不会违反种植规则。</li><li>输入的数组长度范围为 [1, 20000]。</li><li><strong>n</strong> 是非负整数，且不会超过输入数组的大小。</li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li>在数组首尾添加零（去除边界的影响），每三个0可以种一朵花</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="keyword">int</span> *flowerbed, <span class="keyword">int</span> flowerbedSize, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//在首尾添加零</span></span><br><span class="line">    <span class="keyword">int</span> *help = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>((flowerbedSize + <span class="number">2</span>) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    help[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    help[flowerbedSize + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= flowerbedSize; i++)</span><br><span class="line">        help[i] = flowerbed[i - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//每三个零种一朵花</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= flowerbedSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (help[i - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; help[i] == <span class="number">0</span> &amp;&amp; help[i + <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            help[i] = <span class="number">1</span>;<span class="comment">//种花</span></span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>628.三个数的最大乘积</title>
    <url>/2020/02/14/628.%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: 24</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>给定的整型数组长度范围是[3,104]，数组中所有的元素范围是[-1000, 1000]。</li><li>输入的数组中任意三个数的乘积不会超出32位有符号整数的范围。</li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>排序、选数</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ol><li>对数组进行升序排序</li><li><p>最大乘积：</p><ol><li>全是正数：选三个最大的</li><li>全是负数：还选三个最大的</li><li>有正有负：<ul><li>[-4, 0, 2, 3] : 选三个最大的</li><li>[-4, -3, 1, 2] : 选两个负的一个正的</li></ul></li></ol></li><li><p>所以最大乘积只有两种情况：</p><ul><li>第一个负数的绝对值比较小倒着选三个数</li><li>正着选两个数，倒着选一个数</li></ul></li><li><p>选两个数中的较大数</p></li></ol><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//升序</span></span><br><span class="line">    <span class="keyword">return</span> (*(<span class="keyword">int</span> *)a - *(<span class="keyword">int</span> *)b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximumProduct</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>] * nums[<span class="number">1</span>] * nums[<span class="number">2</span>];</span><br><span class="line">    qsort(nums, numsSize, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), compare1);</span><br><span class="line">    <span class="keyword">int</span> max1 = nums[numsSize - <span class="number">1</span>] * nums[numsSize - <span class="number">2</span>] * nums[numsSize - <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span> max2 = nums[<span class="number">0</span>] * nums[<span class="number">1</span>] * nums[numsSize - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> max1 &gt; max2 ? max1 : max2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>674.最长连续递增序列</title>
    <url>/2020/02/14/674.%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个未经排序的整数数组，找到最长且<strong>连续</strong>的的递增序列。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,4,7]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 最长连续递增序列是 [1,3,5], 长度为3。</span><br><span class="line">尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,2,2,2,2]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 最长连续递增序列是 [2], 长度为1。</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>数组长度不会超过10000。</p><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>简单遍历</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li>for循环遍历整个数组，用中间变量temp记录每次的连续长度，用res与temp比较作为最大值</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">1</span>, res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            temp++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            res = res &gt; temp ? res : temp;</span><br><span class="line">            temp = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res = res &gt; temp ? res : temp;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>717.1比特与2比特字符</title>
    <url>/2020/02/14/717.1%E6%AF%94%E7%89%B9%E4%B8%8E2%E6%AF%94%E7%89%B9%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>有两种特殊字符。第一种字符可以用一比特<code>0</code>来表示。第二种字符可以用两比特(<code>10</code> 或 <code>11</code>)来表示。</p><p>现给一个由若干比特组成的字符串。问最后一个字符是否必定为一个一比特字符。给定的字符串总是由0结束。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">bits &#x3D; [1, 0, 0]</span><br><span class="line">输出: True</span><br><span class="line">解释: </span><br><span class="line">唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是一比特字符。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">bits &#x3D; [1, 1, 1, 0]</span><br><span class="line">输出: False</span><br><span class="line">解释: </span><br><span class="line">唯一的编码方式是两比特字符和两比特字符。所以最后一个字符不是一比特字符。</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><code>1 &lt;= len(bits) &lt;= 1000</code>.</li><li><code>bits[i]</code> 总是<code>0</code> 或 <code>1</code>.</li></ul><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>模拟栈</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li>把数组想象成一个栈底在数组尾部的栈，从头开始出栈，遇到以下两种情况出栈：<ul><li>1后边是1或0，出栈</li><li>单独一个0，出栈</li></ul></li><li>如果栈底还剩一个元素，那么返回true，否则返回false。</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isOneBitCharacter</span><span class="params">(<span class="keyword">int</span> *bits, <span class="keyword">int</span> bitsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bitsSize == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; bitsSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (bits[i] == <span class="number">1</span> &amp;&amp; (bits[i + <span class="number">1</span>] == <span class="number">1</span> || bits[i + <span class="number">1</span>] == <span class="number">0</span>))</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (bits[i] == <span class="number">0</span> &amp;&amp; i != bitsSize - <span class="number">1</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span> (i == bitsSize - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>724.寻找数组的中心索引</title>
    <url>/2020/02/14/724.%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个整数类型的数组 <code>nums</code>，请编写一个能够返回数组<strong>“中心索引”</strong>的方法。</p><p>我们是这样定义数组<strong>中心索引</strong>的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。</p><p>如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">nums &#x3D; [1, 7, 3, 6, 5, 6]</span><br><span class="line">输出: 3</span><br><span class="line">解释: </span><br><span class="line">索引3 (nums[3] &#x3D; 6) 的左侧数之和(1 + 7 + 3 &#x3D; 11)，与右侧数之和(5 + 6 &#x3D; 11)相等。</span><br><span class="line">同时, 3 也是第一个符合要求的中心索引。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">nums &#x3D; [1, 2, 3]</span><br><span class="line">输出: -1</span><br><span class="line">解释: </span><br><span class="line">数组中不存在满足此条件的中心索引。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li><code>nums</code> 的长度范围为 <code>[0, 10000]</code>。</li><li>任何一个 <code>nums[i]</code> 将会是一个范围在 <code>[-1000, 1000]</code>的整数。</li></ul><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>前缀和（参考官解）</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li><code>leftSum == sum - leftSum - nums[i]</code>时，就找到了最左边的中心索引</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, leftSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftSum == sum - nums[i] - leftSum)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        leftSum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>747.至少是其他数字两倍的最大数</title>
    <url>/2020/02/14/747.%E8%87%B3%E5%B0%91%E6%98%AF%E5%85%B6%E4%BB%96%E6%95%B0%E5%AD%97%E4%B8%A4%E5%80%8D%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>在一个给定的数组<code>nums</code>中，总是存在一个最大元素 。</p><p>查找数组中的最大元素是否至少是数组中每个其他数字的两倍。</p><p>如果是，则返回最大元素的索引，否则返回-1。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [3, 6, 1, 0]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 6是最大的整数, 对于数组中的其他整数,</span><br><span class="line">6大于数组中其他元素的两倍。6的索引是1, 所以我们返回1.</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1, 2, 3, 4]</span><br><span class="line">输出: -1</span><br><span class="line">解释: 4没有超过3的两倍大, 所以我们返回 -1.</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ol><li><code>nums</code> 的长度范围在<code>[1, 50]</code>.</li><li>每个 <code>nums[i]</code> 的整数范围在 <code>[0, 100]</code>.</li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>数组遍历</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li>找到最大值，并记录其索引，如果<code>2 * nums[i] &gt; max</code>，返回-1；否则，返回最大值的索引</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dominantIndex</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = nums[<span class="number">0</span>], maxIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="built_in">max</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">max</span> = nums[i];</span><br><span class="line">            maxIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == maxIndex)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * nums[i] &gt; <span class="built_in">max</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>dynamic-programming</tag>
      </tags>
  </entry>
  <entry>
    <title>561.数组拆分</title>
    <url>/2020/02/13/561.%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86%E2%85%A0/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定长度为 <strong>2n</strong> 的数组, 你的任务是将这些数分成 <strong>n</strong> 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,4,3,2]</span><br><span class="line"></span><br><span class="line">输出: 4</span><br><span class="line">解释: n 等于 2, 最大总和为 4 &#x3D; min(1, 2) + min(3, 4).</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ol><li><strong>n</strong> 是正整数,范围在 [1, 10000].</li><li>数组中的元素范围在 [-10000, 10000].</li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><ol><li><p>算法描述</p><ul><li>排序+最小值累加</li></ul></li><li><p>个人分析</p><ul><li>首先将给定数组排序，然后每两位选择较小值进行累加</li></ul></li><li><p>代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//升序</span></span><br><span class="line">    <span class="keyword">return</span> (*(<span class="keyword">int</span> *)a - *(<span class="keyword">int</span> *)b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sizeOfElem = <span class="keyword">sizeof</span>(nums[<span class="number">0</span>]);</span><br><span class="line">    qsort(nums, numsSize, sizeOfElem, compare1);</span><br><span class="line">    <span class="keyword">int</span> i, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i += <span class="number">2</span>)</span><br><span class="line">        res += <span class="built_in">min</span>(nums[i], nums[i + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>581.最短无序连续子数组</title>
    <url>/2020/02/13/581.%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个整数数组，你需要寻找一个<strong>连续的子数组</strong>，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p><p>你找到的子数组应是<strong>最短</strong>的，请输出它的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2, 6, 4, 8, 10, 9, 15]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。</span><br></pre></td></tr></table></figure><p><strong>说明 :</strong></p><ol><li>输入的数组长度范围在 [1, 10,000]。</li><li>输入的数组可能包含<strong>重复</strong>元素 ，所以<strong>升序</strong>的意思是<strong>&lt;=。</strong></li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>排序+逐位异或+双指针扫描</li><li>双指针</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li>首先利用快速排序数组进行升序排序，然后与原数组逐位异或，位置没变的元素就会变成0，然后利用头尾指针扫描，每遇到0，就将数组长度减一，头尾指针都遇到不为零的数时，停止扫描</li><li>总结时发现，只利用双指针就行了，头尾指针向中间扫描时，头指针扫描的数应该是越来越大的，而尾指针扫描的数应该是越来越小的，当头指针的后一个数比当前位置的数小时，头指针就应该停下了，尾指针亦然；当头尾指针相遇，则表明这是一个完全有序的数组，所以返回0.</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">compare1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//升序</span></span><br><span class="line">    <span class="keyword">return</span> (*(<span class="keyword">int</span> *)a - *(<span class="keyword">int</span> *)b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> *help = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(numsSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">        help[i] = nums[i];</span><br><span class="line">    qsort(nums, numsSize, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), compare1);</span><br><span class="line">    <span class="comment">//逐位异或</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">        nums[i] ^= help[i];</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>, n = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = numsSize;</span><br><span class="line">    <span class="comment">//双指针</span></span><br><span class="line">    <span class="keyword">while</span> ((nums[m] == <span class="number">0</span> || nums[n] == <span class="number">0</span>) &amp;&amp; m &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[m] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res--;</span><br><span class="line">            m++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[n] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res--;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) <span class="comment">//如果队列有序，res=-1，那么应该返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>448.找到所有数组中消失的数字</title>
    <url>/2020/02/12/448.%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p><strong>Tags：</strong></p><p>给定一个范围在 1 ≤ a[i] ≤ <em>n</em> ( <em>n</em> = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p><p>找到所有在 [1, <em>n</em>] 范围之间没有出现在数组中的数字。</p><p>您能在不使用额外空间且时间复杂度为<em>O(n)</em>的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>类似标记数组</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li><p>将数组中的元素对应的数组值置为负数，然后遍历数组中大于零的元素，其索引就是消失的数字</p><p>例如：</p><ul><li>输入：[ 4, 3, 2, 7, 8, 2, 3, 1]</li><li>输出：[-4,-3,-2,-7,<code>8</code>,<code>2</code>,-3,-1]</li></ul></li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> *returnSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *res = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(numsSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">        nums[<span class="built_in">abs</span>(nums[i]) - <span class="number">1</span>] = -<span class="built_in">abs</span>(nums[<span class="built_in">abs</span>(nums[i]) - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">            res[j++] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = j;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>414.第三大的数</title>
    <url>/2020/02/11/414.%E7%AC%AC%E4%B8%89%E5%A4%A7%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3, 2, 1]</span><br><span class="line"></span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">解释: 第三大的数是 1.</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1, 2]</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释: 第三大的数不存在, 所以返回最大的数 2 .</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2, 2, 3, 1]</span><br><span class="line"></span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">解释: 注意，要求返回第三大的数，是指第三大且唯一出现的数。</span><br><span class="line">存在两个值为2的数，它们都排第二。</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>窗口滑动</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li>初始化一个长度为三的滑动窗口，用三个变量实现。遍历数组时，使用数组中的元素更新窗口中的值，使用<code>flag</code>标记窗口中元素的更新次数，如果flag&gt;=3，则说明窗口中的元素被全部更新，即返回窗口中的最小值；否则，falg只更新了1次或2次，即第三大的数不存在, 所以返回最大的数。</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">thirdMax</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>] &gt;= nums[<span class="number">1</span>] ? nums[<span class="number">0</span>] : nums[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i, flag = <span class="number">0</span>, intmin = <span class="number">1</span>;<span class="comment">//intmin是为了排除掉数组中的INT_MIN</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">min</span> = -__INT_MAX__ - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = -__INT_MAX__ - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = -__INT_MAX__ - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == -__INT_MAX__ - <span class="number">1</span> &amp;&amp; intmin)</span><br><span class="line">        &#123;</span><br><span class="line">            flag++;</span><br><span class="line">            intmin = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="built_in">max</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag++;</span><br><span class="line">            <span class="built_in">min</span> = mid;</span><br><span class="line">            mid = <span class="built_in">max</span>;</span><br><span class="line">            <span class="built_in">max</span> = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; mid &amp;&amp; nums[i] &lt; <span class="built_in">max</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag++;</span><br><span class="line">            <span class="built_in">min</span> = mid;</span><br><span class="line">            mid = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; <span class="built_in">min</span> &amp;&amp; nums[i] &lt; mid)</span><br><span class="line">        &#123;</span><br><span class="line">            flag++;</span><br><span class="line">            <span class="built_in">min</span> = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag &gt;= <span class="number">3</span> ? <span class="built_in">min</span> : <span class="built_in">max</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>287.寻找重复数</title>
    <url>/2020/02/10/287.%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个包含 <em>n</em> + 1 个整数的数组 <em>nums</em>，其数字都在 1 到 <em>n</em> 之间（包括 1 和 <em>n</em>），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,4,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,1,3,4,2]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ol><li><strong>不能</strong>更改原数组（假设数组是只读的）。</li><li>只能使用额外的 <em>O</em>(1) 的空间。</li><li>时间复杂度小于 <em>O</em>(<em>n</em>2) 。</li><li>数组中只有一个重复的数字，但它可能不止重复出现一次。</li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>快指针&amp;慢指针</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li><p>将此题抽象成环型链表问题（见141题、142题）</p><p>那么如何在数组中模拟快慢指针呢？</p><p>看了题解：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fast = nums[nums[fast]];</span><br><span class="line">slow = nums[slow];</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slow &#x3D; 0;fast &#x3D; 0;</span><br><span class="line">nums[] &#x3D; [3,1,3,4,2]</span><br><span class="line">nums[slow] &#x3D; [3,4,2,3]</span><br><span class="line">nums[nums[fast]] &#x3D; [4,3,2,4]</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) <span class="comment">//一定有相同元素，所以死循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        fast = nums[nums[fast]]; <span class="comment">//快指针</span></span><br><span class="line">        slow = nums[slow];       <span class="comment">//慢指针</span></span><br><span class="line">        <span class="keyword">if</span> (slow == fast)        <span class="comment">//快慢指针相遇，开始寻找成环入口，即为重复的数</span></span><br><span class="line">        &#123;</span><br><span class="line">            fast = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">/*寻找环的入口</span></span><br><span class="line"><span class="comment">                nums[slow] == nums[fast]时，快慢指针指向的元素相等，即为所求元素</span></span><br><span class="line"><span class="comment">                快慢指针指向的元素不等时，则继续寻找*/</span></span><br><span class="line">            <span class="keyword">while</span> (nums[slow] != nums[fast])</span><br><span class="line">            &#123;</span><br><span class="line">                fast = nums[fast];</span><br><span class="line">                slow = nums[slow];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> nums[slow];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、PS"><a href="#三、PS" class="headerlink" title="三、PS"></a>三、PS</h2><p>这是一道中等难度的题目，我还不是很理解。完全参考了作者<a href="https://leetcode-cn.com/u/seu_fidget/" target="_blank" rel="noopener">SEU.FidGet</a>的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        快慢指针思想, fast 和 slow 是指针, nums[slow] 表示取指针对应的元素</span></span><br><span class="line"><span class="comment">        注意 nums 数组中的数字都是在 1 到 n 之间的(在数组中进行游走不会越界),</span></span><br><span class="line"><span class="comment">        因为有重复数字的出现, 所以这个游走必然是成环的, 环的入口就是重复的元素, </span></span><br><span class="line"><span class="comment">        即按照寻找链表环入口的思路来做</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">0</span>, slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            <span class="keyword">if</span>(slow == fast) &#123;</span><br><span class="line">                fast = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(nums[slow] != nums[fast]) &#123;</span><br><span class="line">                    fast = nums[fast];</span><br><span class="line">                    slow = nums[slow];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> nums[slow];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>two-pointers</tag>
        <tag>binary-search</tag>
      </tags>
  </entry>
  <entry>
    <title>268.缺失数字</title>
    <url>/2020/02/09/268.%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个包含 <code>0, 1, 2, ..., n</code> 中 <em>n</em> 个数的序列，找出 0 .. <em>n</em> 中没有出现在序列中的那个数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,0,1]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [9,6,4,2,3,5,7,0,1]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure><p><strong>说明:</strong><br>你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现?</p><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>标记数组</li><li>异或</li><li>求和做差</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li>标记数组：申请一个<strong>n+1</strong>长度的标记数组，用这个数组记录，最后遍历标记数组即可</li><li>异或：按for循环中的i异或（大佬的方法）</li><li>求和做差：先利用数学法求出前n项和，再减去数组中的元素，剩下的差就是答案</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>((numsSize + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[nums[i]] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i] != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>bit-manipu</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>283.移动零</title>
    <url>/2020/02/09/283.%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><p><strong>说明</strong>:</p><ol><li>必须在原数组上操作，不能拷贝额外的数组。</li><li>尽量减少操作次数。</li></ol><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>双指针法</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li>指针<code>i</code>用于寻找零，指针<code>j</code>用于寻找指针<code>i</code>后边不为零的数，并令<code>nums[i]=nums[j]</code>，然后再令<code>nums[j]=0</code>，遍历整个数组。</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; numsSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; numsSize)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    nums[i] = nums[j];</span><br><span class="line">                    nums[j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>189.旋转数组</title>
    <url>/2020/02/08/189.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个数组，将数组中的元素向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,5,6,7] 和 k &#x3D; 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [-1,-100,3,99] 和 k &#x3D; 2</span><br><span class="line">输出: [3,99,-1,-100]</span><br><span class="line">解释: </span><br><span class="line">向右旋转 1 步: [99,-1,-100,3]</span><br><span class="line">向右旋转 2 步: [3,99,-1,-100]</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</li><li>要求使用空间复杂度为 O(1) 的 <strong>原地</strong> 算法。</li></ul><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>暴力法：两个for循环嵌套，每次将数组中的元素向后移动一位</li><li>三次翻转数组</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li>暴力法挺好理解就是超时</li><li>三次翻转：<ul><li>第一次：将整个数组翻转</li><li>第二次：将[0,k-1]的数组翻转</li><li>第三次：将[k,n-1]的数组翻转</li></ul></li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        temp = nums[low];</span><br><span class="line">        nums[low] = nums[high];</span><br><span class="line">        nums[high] = temp;</span><br><span class="line">        low++;</span><br><span class="line">        high--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    k = k % numsSize;</span><br><span class="line">    reverse(nums, <span class="number">0</span>, numsSize - <span class="number">1</span>);</span><br><span class="line">    reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">    reverse(nums, k, numsSize - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、PS："><a href="#三、PS：" class="headerlink" title="三、PS："></a>三、PS：</h2><p>暴力法的超时代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//超时了</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (numsSize &lt; <span class="number">2</span>)</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       <span class="keyword">int</span> minK = k % numsSize;</span><br><span class="line">       <span class="keyword">int</span> i, temp, j;</span><br><span class="line">       <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; minK; j++)</span><br><span class="line">       &#123;</span><br><span class="line">           temp = nums[numsSize - <span class="number">1</span>];</span><br><span class="line">           <span class="keyword">for</span> (i = numsSize - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">           &#123;</span><br><span class="line">               nums[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">           &#125;</span><br><span class="line">           nums[<span class="number">0</span>] = temp;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>217.存在重复元素</title>
    <url>/2020/02/08/217.%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个整数数组，判断是否存在重复元素。</p><p>如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,1,1,3,3,4,3,2,4,2]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1. 算法描述"></a>1. 算法描述</h3><ul><li>暴力法：两个for循环嵌套遍历</li><li>使用qsort()排序，再逐位检查</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2. 个人分析"></a>2. 个人分析</h3><ul><li>暴力法超时</li><li>qsort()最坏复杂度：O(nlogn)</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*(<span class="keyword">int</span> *)a - *(<span class="keyword">int</span> *)b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> sizeOfElem = <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    qsort(nums, numsSize, sizeOfElem, compare);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、PS："><a href="#三、PS：" class="headerlink" title="三、PS："></a>三、PS：</h2><ul><li><p>暴力法超时</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; numsSize; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>qsort()快速排序：</p><p><code>void qsort(void *_Base, size_t _NumOfElements, size_t _SizeOfElements, int (*_PtFuncCompare)(const void *, const void *))</code></p><ul><li>_Base：待排序的数组</li><li>_NumOfElements：数组中元素的个数</li><li>_SizeOfElements：数组中元素的大小</li><li>(<em>_PtFuncCompare)(const void </em>, const void *))：比较指针</li></ul></li><li><p>qsort()函数实例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="comment">//升序</span></span><br><span class="line">    <span class="keyword">return</span> (*(<span class="keyword">int</span> *)a - *(<span class="keyword">int</span> *)b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="comment">//降序</span></span><br><span class="line">    <span class="keyword">return</span> (*(<span class="keyword">int</span> *)b - *(<span class="keyword">int</span> *)a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> numsOfArray = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> sizeOfElem = <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">    qsort(<span class="built_in">array</span>, numsOfArray, sizeOfElem, compare1);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsOfArray; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, <span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>hash-table</tag>
      </tags>
  </entry>
  <entry>
    <title>219.存在重复元素Ⅱ</title>
    <url>/2020/02/08/219.%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E2%85%A1/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>给定一个整数数组和一个整数 <em>k</em>，判断数组中是否存在两个不同的索引 <em>i</em> 和 <em>j</em>，使得 <strong>nums [i] = nums [j]</strong>，并且 <em>i</em> 和 <em>j</em> 的差的绝对值最大为 <em>k</em>。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,3,1], k &#x3D; 3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,0,1,1], k &#x3D; 1</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,3,1,2,3], k &#x3D; 2</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><ul><li>暴力：for()循环嵌套+if (nums[i] == nums[j] &amp;&amp; j - i &lt;= k)判断</li><li>屈辱😭：面向测试用例编程</li></ul><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><ul><li>暴力：又是妥妥的超时！！！</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">35000</span>) <span class="comment">//留下了屈辱的眼泪</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; numsSize; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[j] &amp;&amp; j - i &lt;= k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、PS"><a href="#三、PS" class="headerlink" title="三、PS"></a>三、PS</h2><p>超时代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span> *nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; numsSize; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[j] &amp;&amp; j - i &lt;= k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>hash-table</tag>
      </tags>
  </entry>
  <entry>
    <title>204.计数质数</title>
    <url>/2020/02/07/204.%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0/</url>
    <content><![CDATA[<!-- build time:Tue Mar 10 2020 20:51:36 GMT+0800 (GMT+08:00) --><h2 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h2><p>统计所有小于非负整数 n 的质数的数量。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: 10</span><br><span class="line">输出: 4</span><br><span class="line">解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</span><br></pre></td></tr></table></figure><h2 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h2><h3 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h3><blockquote><p><a href="https://baike.baidu.com/item/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC%E7%AD%9B%E6%B3%95/374984?fr=aladdin#1" target="_blank" rel="noopener">埃拉托斯特尼筛法</a></p><p>​ 埃拉托斯特尼筛法，简称埃氏筛或爱氏筛，是一种由希腊数学家埃拉托斯特尼所提出的一种简单检定素数的算法。要得到自然数n以内的全部素数，必须把不大于根号n的所有素数的倍数剔除，剩下的就是素数。</p></blockquote><h3 id="2-个人分析"><a href="#2-个人分析" class="headerlink" title="2.个人分析"></a>2.个人分析</h3><p>​ 声明一个长度为n的数组，索引<code>i</code>作为待判断的数，索引中的值<code>isPrime[i]</code>作为该索引是否为素数的flag，使用for循环开始逐一判断数组索引<code>i</code>是否为素数，如果是素数，则将其n以内的所有倍数过滤，再判断下一个索引<code>i</code>。</p><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//爱式筛法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *isPrime = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    <span class="built_in">memset</span>(isPrime, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);<span class="comment">//初始化isPrime为0</span></span><br><span class="line">    <span class="keyword">int</span> i, j, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">for</span> (j = i + i; j &lt; n; j += i)</span><br><span class="line">            &#123; <span class="comment">//筛去i的倍数</span></span><br><span class="line">                isPrime[j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、PS"><a href="#三、PS" class="headerlink" title="三、PS:"></a>三、PS:</h2><p><code>void *memset(void *_Dst, int _Val, size_t _Size)</code></p><ul><li><p>memset()函数为初始化一块连续的内存空间，<strong>按照字节赋值</strong></p></li><li><p>_Dst：指针变量（起始位置）</p></li><li>_Val：初始化的值（一般为-1或0）</li><li>_Size：内存长度</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>math</tag>
        <tag>hash-table</tag>
      </tags>
  </entry>
</search>
